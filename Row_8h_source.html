<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: Row.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('Row_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Row.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="Row_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef SimTK_SIMMATRIX_SMALLMATRIX_ROW_H_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define SimTK_SIMMATRIX_SMALLMATRIX_ROW_H_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* -------------------------------------------------------------------------- *</span>
<a name="l00005"></a>00005 <span class="comment"> *                       Simbody(tm): SimTKcommon                             *</span>
<a name="l00006"></a>00006 <span class="comment"> * -------------------------------------------------------------------------- *</span>
<a name="l00007"></a>00007 <span class="comment"> * This is part of the SimTK biosimulation toolkit originating from           *</span>
<a name="l00008"></a>00008 <span class="comment"> * Simbios, the NIH National Center for Physics-Based Simulation of           *</span>
<a name="l00009"></a>00009 <span class="comment"> * Biological Structures at Stanford, funded under the NIH Roadmap for        *</span>
<a name="l00010"></a>00010 <span class="comment"> * Medical Research, grant U54 GM072970. See https://simtk.org/home/simbody.  *</span>
<a name="l00011"></a>00011 <span class="comment"> *                                                                            *</span>
<a name="l00012"></a>00012 <span class="comment"> * Portions copyright (c) 2005-12 Stanford University and the Authors.        *</span>
<a name="l00013"></a>00013 <span class="comment"> * Authors: Michael Sherman                                                   *</span>
<a name="l00014"></a>00014 <span class="comment"> * Contributors: Peter Eastman                                                *</span>
<a name="l00015"></a>00015 <span class="comment"> *                                                                            *</span>
<a name="l00016"></a>00016 <span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may    *</span>
<a name="l00017"></a>00017 <span class="comment"> * not use this file except in compliance with the License. You may obtain a  *</span>
<a name="l00018"></a>00018 <span class="comment"> * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *</span>
<a name="l00019"></a>00019 <span class="comment"> *                                                                            *</span>
<a name="l00020"></a>00020 <span class="comment"> * Unless required by applicable law or agreed to in writing, software        *</span>
<a name="l00021"></a>00021 <span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,          *</span>
<a name="l00022"></a>00022 <span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *</span>
<a name="l00023"></a>00023 <span class="comment"> * See the License for the specific language governing permissions and        *</span>
<a name="l00024"></a>00024 <span class="comment"> * limitations under the License.                                             *</span>
<a name="l00025"></a>00025 <span class="comment"> * -------------------------------------------------------------------------- */</span>
<a name="l00026"></a>00026 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html" title="Mandatory first inclusion for any Simbody source or header file.">SimTKcommon/internal/common.h</a>&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="keyword">namespace </span>SimTK {
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">// The following functions are used internally by Row.</span>
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="namespaceSimTK_1_1Impl.html">00038</a> <span class="keyword">namespace </span>Impl {
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">// For those wimpy compilers that don&#39;t unroll short, constant-limit loops, </span>
<a name="l00041"></a>00041 <span class="comment">// Peter Eastman added these recursive template implementations of </span>
<a name="l00042"></a>00042 <span class="comment">// elementwise add, subtract, and copy. Sherm added multiply and divide.</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00045"></a><a class="code" href="namespaceSimTK_1_1Impl.html#a863cb805509416e0e564c532faf1cf03">00045</a> <a class="code" href="namespaceSimTK_1_1Impl.html#a863cb805509416e0e564c532faf1cf03">conformingAdd</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E2,S2&gt;</a>&amp; r2, 
<a name="l00046"></a>00046               <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;1,<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;::template</a> Result&lt;E2&gt;::Add&gt;&amp; result) {
<a name="l00047"></a>00047     result[0] = r1[0] + r2[0];
<a name="l00048"></a>00048 }
<a name="l00049"></a>00049 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00050"></a><a class="code" href="namespaceSimTK_1_1Impl.html#a43b36c44295959c17fa58b0758df6cf5">00050</a> <a class="code" href="namespaceSimTK_1_1Impl.html#a863cb805509416e0e564c532faf1cf03">conformingAdd</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r2, 
<a name="l00051"></a>00051               <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N,<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;::template</a> Result&lt;E2&gt;::Add&gt;&amp; result) {
<a name="l00052"></a>00052     <a class="code" href="namespaceSimTK_1_1Impl.html#a863cb805509416e0e564c532faf1cf03">conformingAdd</a>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E1,S1<span class="keyword">&gt;</span>&amp;&gt;(r1), 
<a name="l00053"></a>00053                   <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E2,S2<span class="keyword">&gt;</span>&amp;&gt;(r2), 
<a name="l00054"></a>00054                   <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,typename <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;</a>::
<a name="l00055"></a>00055                               template Result&lt;E2&gt;::Add<span class="keyword">&gt;</span>&amp;&gt;(result));
<a name="l00056"></a>00056     result[N-1] = r1[N-1] + r2[N-1];
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00060"></a><a class="code" href="namespaceSimTK_1_1Impl.html#a4e8ea3dbdc2198b2f9f9c508077edd91">00060</a> <a class="code" href="namespaceSimTK_1_1Impl.html#a4e8ea3dbdc2198b2f9f9c508077edd91">conformingSubtract</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E2,S2&gt;</a>&amp; r2, 
<a name="l00061"></a>00061                    <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;1,<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;::template</a> Result&lt;E2&gt;::Sub&gt;&amp; result) {
<a name="l00062"></a>00062     result[0] = r1[0] - r2[0];
<a name="l00063"></a>00063 }
<a name="l00064"></a>00064 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00065"></a><a class="code" href="namespaceSimTK_1_1Impl.html#a38c70de1e254c0d608cf446c76b63dc6">00065</a> <a class="code" href="namespaceSimTK_1_1Impl.html#a4e8ea3dbdc2198b2f9f9c508077edd91">conformingSubtract</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r2,
<a name="l00066"></a>00066                    <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N,<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;::template</a> Result&lt;E2&gt;::Sub&gt;&amp; result) {
<a name="l00067"></a>00067     <a class="code" href="namespaceSimTK_1_1Impl.html#a4e8ea3dbdc2198b2f9f9c508077edd91">conformingSubtract</a>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E1,S1<span class="keyword">&gt;</span>&amp;&gt;(r1), 
<a name="l00068"></a>00068                        <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E2,S2<span class="keyword">&gt;</span>&amp;&gt;(r2), 
<a name="l00069"></a>00069                        <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,typename <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;</a>::
<a name="l00070"></a>00070                                    template Result&lt;E2&gt;::Sub<span class="keyword">&gt;</span>&amp;&gt;(result));
<a name="l00071"></a>00071     result[N-1] = r1[N-1] - r2[N-1];
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00075"></a><a class="code" href="namespaceSimTK_1_1Impl.html#ac4d35b8308f45851e1100c600ab94344">00075</a> <a class="code" href="namespaceSimTK_1_1Impl.html#ac4d35b8308f45851e1100c600ab94344">elementwiseMultiply</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E2,S2&gt;</a>&amp; r2, 
<a name="l00076"></a>00076               <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;1,<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;::template</a> Result&lt;E2&gt;::Mul&gt;&amp; result) {
<a name="l00077"></a>00077     result[0] = r1[0] * r2[0];
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00080"></a><a class="code" href="namespaceSimTK_1_1Impl.html#a32cd95c189f6b8a7494cdb95bf44758c">00080</a> <a class="code" href="namespaceSimTK_1_1Impl.html#ac4d35b8308f45851e1100c600ab94344">elementwiseMultiply</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r2, 
<a name="l00081"></a>00081               <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N,<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;::template</a> Result&lt;E2&gt;::Mul&gt;&amp; result) {
<a name="l00082"></a>00082     <a class="code" href="namespaceSimTK_1_1Impl.html#ac4d35b8308f45851e1100c600ab94344">elementwiseMultiply</a>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E1,S1<span class="keyword">&gt;</span>&amp;&gt;(r1), 
<a name="l00083"></a>00083                         <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E2,S2<span class="keyword">&gt;</span>&amp;&gt;(r2), 
<a name="l00084"></a>00084                         <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,typename <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;</a>::
<a name="l00085"></a>00085                                     template Result&lt;E2&gt;::Mul<span class="keyword">&gt;</span>&amp;&gt;(result));
<a name="l00086"></a>00086     result[N-1] = r1[N-1] * r2[N-1];
<a name="l00087"></a>00087 }
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00090"></a><a class="code" href="namespaceSimTK_1_1Impl.html#a2b8ba3dbd4c81b2d69e2ee9e640d3dc2">00090</a> <a class="code" href="namespaceSimTK_1_1Impl.html#a2b8ba3dbd4c81b2d69e2ee9e640d3dc2">elementwiseDivide</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E2,S2&gt;</a>&amp; r2, 
<a name="l00091"></a>00091               <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;1,<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;::template</a> Result&lt;E2&gt;::Dvd&gt;&amp; result) {
<a name="l00092"></a>00092     result[0] = r1[0] / r2[0];
<a name="l00093"></a>00093 }
<a name="l00094"></a>00094 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00095"></a><a class="code" href="namespaceSimTK_1_1Impl.html#ad5438b135982e740122bbbb79caee553">00095</a> <a class="code" href="namespaceSimTK_1_1Impl.html#a2b8ba3dbd4c81b2d69e2ee9e640d3dc2">elementwiseDivide</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r2, 
<a name="l00096"></a>00096               <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N,<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;::template</a> Result&lt;E2&gt;::Dvd&gt;&amp; result) {
<a name="l00097"></a>00097     <a class="code" href="namespaceSimTK_1_1Impl.html#a2b8ba3dbd4c81b2d69e2ee9e640d3dc2">elementwiseDivide</a>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E1,S1<span class="keyword">&gt;</span>&amp;&gt;(r1), 
<a name="l00098"></a>00098                         <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E2,S2<span class="keyword">&gt;</span>&amp;&gt;(r2), 
<a name="l00099"></a>00099                         <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,typename <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E1&gt;</a>::
<a name="l00100"></a>00100                                     template Result&lt;E2&gt;::Dvd<span class="keyword">&gt;</span>&amp;&gt;(result));
<a name="l00101"></a>00101     result[N-1] = r1[N-1] / r2[N-1];
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00105"></a><a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">00105</a> <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">copy</a>(<a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;1,E2,S2&gt;</a>&amp; r2) {
<a name="l00106"></a>00106     r1[0] = r2[0];
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keywordtype">void</span>
<a name="l00109"></a><a class="code" href="namespaceSimTK_1_1Impl.html#a7898463bb3cc74612fa7d29e64413995">00109</a> <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">copy</a>(<a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; r1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r2) {
<a name="l00110"></a>00110     <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">copy</a>(<span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E1,S1<span class="keyword">&gt;</span>&amp;&gt;(r1), 
<a name="l00111"></a>00111          <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,E2,S2<span class="keyword">&gt;</span>&amp;&gt;(r2));
<a name="l00112"></a>00112     r1[N-1] = r2[N-1];
<a name="l00113"></a>00113 }
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00118"></a><a class="code" href="classSimTK_1_1Row.html">00118</a> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> ELT, <span class="keywordtype">int</span> STRIDE&gt; <span class="keyword">class </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a> {
<a name="l00119"></a>00119     <span class="keyword">typedef</span> ELT                                 E;
<a name="l00120"></a>00120     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ac60083a4dfbd9d4b52eba40d0daa5e7d">CNT&lt;E&gt;::TNeg</a>               ENeg;
<a name="l00121"></a>00121     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a8fa907a1105e1986cc3a6693bee289a4">CNT&lt;E&gt;::TWithoutNegator</a>    EWithoutNegator;
<a name="l00122"></a>00122     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a99691326a3ebcde21f820c7d1948b8ec">CNT&lt;E&gt;::TReal</a>              EReal;
<a name="l00123"></a>00123     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae974547ef47fa4b20eecb968a5ed34dd">CNT&lt;E&gt;::TImag</a>              EImag;
<a name="l00124"></a>00124     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#acf221e39666a67f13d33eb1ec42595eb">CNT&lt;E&gt;::TComplex</a>           EComplex;
<a name="l00125"></a>00125     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#abbc59ab05d09d534ab26f1abd1612c67">CNT&lt;E&gt;::THerm</a>              EHerm;
<a name="l00126"></a>00126     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#abee71fda19f27c7d84caede6599154d6">CNT&lt;E&gt;::TPosTrans</a>          EPosTrans;
<a name="l00127"></a>00127     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a63dea5955adff218f158da672d2e51e7">CNT&lt;E&gt;::TSqHermT</a>           ESqHermT;
<a name="l00128"></a>00128     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae6f64a355b6f5dd6183a49b958899b5d">CNT&lt;E&gt;::TSqTHerm</a>           ESqTHerm;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a8a063f3c7cb38f49db3f593bba18478d">CNT&lt;E&gt;::TSqrt</a>              ESqrt;
<a name="l00131"></a>00131     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#aeb6a416120e5b20ba65c36ce8b68c230">CNT&lt;E&gt;::TAbs</a>               EAbs;
<a name="l00132"></a>00132     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#aca0bf92df6b4a845b221a9f2377c4635">CNT&lt;E&gt;::TStandard</a>          EStandard;
<a name="l00133"></a>00133     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a8d762c72fc4c640cfadfa1c0d8569679">CNT&lt;E&gt;::TInvert</a>            EInvert;
<a name="l00134"></a>00134     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a8f5b3ad31cbda4d37e3b3fe9443d30b8">CNT&lt;E&gt;::TNormalize</a>         ENormalize;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#aeb30bb49aaaaf6baa2a953a2b2d9a970">CNT&lt;E&gt;::Scalar</a>             EScalar;
<a name="l00137"></a>00137     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a240ab22b41c9dd30843f2cd21d247a3f">CNT&lt;E&gt;::ULessScalar</a>        EULessScalar;
<a name="l00138"></a>00138     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#aff55e5df3a09f157237bdac6a216c42c">CNT&lt;E&gt;::Number</a>             ENumber;
<a name="l00139"></a>00139     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a363c3f8c73184bf95abb1abec4ecd951">CNT&lt;E&gt;::StdNumber</a>          EStdNumber;
<a name="l00140"></a>00140     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>          EPrecision;
<a name="l00141"></a>00141     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a32c5aa3c649c3819f9c60bd04218e669">CNT&lt;E&gt;::ScalarNormSq</a>       EScalarNormSq;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="keyword">public</span>:
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     <span class="keyword">enum</span> {
<a name="l00146"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da5526374cb3726e781ce716427a34e4a4">00146</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da5526374cb3726e781ce716427a34e4a4">NRows</a>               = 1,
<a name="l00147"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69dae6b0ecbbb565782e585178aa48b20ec8">00147</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69dae6b0ecbbb565782e585178aa48b20ec8">NCols</a>               = N,
<a name="l00148"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da005ed054cf62f045a25fb389ef5613d2">00148</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da005ed054cf62f045a25fb389ef5613d2">NPackedElements</a>     = N,
<a name="l00149"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da3ae362555ddcef1b099b54404cda495f">00149</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da3ae362555ddcef1b099b54404cda495f">NActualElements</a>     = N * STRIDE,   <span class="comment">// includes trailing gap</span>
<a name="l00150"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da3857ae46c16cb7b49899586efa3929ee">00150</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da3857ae46c16cb7b49899586efa3929ee">NActualScalars</a>      = <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E&gt;::NActualScalars</a> * <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da3ae362555ddcef1b099b54404cda495f">NActualElements</a>,
<a name="l00151"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da40b9d98ff7f78ef1e57710b83fd82473">00151</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da40b9d98ff7f78ef1e57710b83fd82473">RowSpacing</a>          = <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da3ae362555ddcef1b099b54404cda495f">NActualElements</a>,
<a name="l00152"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8d80af559e65583df96f721c216bd180">00152</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8d80af559e65583df96f721c216bd180">ColSpacing</a>          = STRIDE,
<a name="l00153"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da6c1a3e35ad67d57f2d943dfc335b5028">00153</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da6c1a3e35ad67d57f2d943dfc335b5028">ImagOffset</a>          = <a class="code" href="classSimTK_1_1NTraits.html">NTraits&lt;ENumber&gt;::ImagOffset</a>,
<a name="l00154"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da1efb036a405e6298119e3d7fd0b4a98a">00154</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da1efb036a405e6298119e3d7fd0b4a98a">RealStrideFactor</a>    = 1, <span class="comment">// composite types don&#39;t change size when</span>
<a name="l00155"></a>00155                                  <span class="comment">// cast from complex to real or imaginary</span>
<a name="l00156"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da307e4f5f28ff4064f9c157d4e5dad471">00156</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da307e4f5f28ff4064f9c157d4e5dad471">ArgDepth</a>            = ((int)<a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E&gt;::ArgDepth</a> &lt; (<span class="keywordtype">int</span>)<a class="code" href="namespaceSimTK.html#a74b018aadcd7d398d49a6b9983deab46af1be5f4d29c00737dfc358cecd7fb6a9">MAX_RESOLVED_DEPTH</a> 
<a name="l00157"></a>00157                                 ? <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E&gt;::ArgDepth</a> + 1 
<a name="l00158"></a>00158                                 : <a class="code" href="namespaceSimTK.html#a74b018aadcd7d398d49a6b9983deab46af1be5f4d29c00737dfc358cecd7fb6a9">MAX_RESOLVED_DEPTH</a>),
<a name="l00159"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69daf0d8f5a7b201663226135d3162341ee6">00159</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69daf0d8f5a7b201663226135d3162341ee6">IsScalar</a>            = 0,
<a name="l00160"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da000734bee9699622e2b6479af93ada37">00160</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da000734bee9699622e2b6479af93ada37">IsULessScalar</a>       = 0,
<a name="l00161"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8782067c15e950ae04045df6f98ef90d">00161</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8782067c15e950ae04045df6f98ef90d">IsNumber</a>            = 0,
<a name="l00162"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69daa79535100a87e4b94af8d1c6c3152df4">00162</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69daa79535100a87e4b94af8d1c6c3152df4">IsStdNumber</a>         = 0,
<a name="l00163"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da7def17b1f1952cb22fd5bc3d6494019c">00163</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da7def17b1f1952cb22fd5bc3d6494019c">IsPrecision</a>         = 0,
<a name="l00164"></a><a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da55253a2d371aeeb8ca91cd454f274370">00164</a>         <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da55253a2d371aeeb8ca91cd454f274370">SignInterpretation</a>  = <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E&gt;::SignInterpretation</a>
<a name="l00165"></a>00165     };
<a name="l00166"></a>00166 
<a name="l00167"></a><a class="code" href="classSimTK_1_1Row.html#ab5cf60da2bb1743d1b8f2af38f8ad27c">00167</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,STRIDE&gt;</a>                 <a class="code" href="classSimTK_1_1Row.html#ab5cf60da2bb1743d1b8f2af38f8ad27c">T</a>;
<a name="l00168"></a><a class="code" href="classSimTK_1_1Row.html#a361879be2c27f84c9dd6f3b6b17c51a4">00168</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,ENeg,STRIDE&gt;</a>              <a class="code" href="classSimTK_1_1Row.html#a361879be2c27f84c9dd6f3b6b17c51a4">TNeg</a>;
<a name="l00169"></a><a class="code" href="classSimTK_1_1Row.html#a53c4047485a6de6182dcd82ac675a302">00169</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EWithoutNegator,STRIDE&gt;</a>   <a class="code" href="classSimTK_1_1Row.html#a53c4047485a6de6182dcd82ac675a302">TWithoutNegator</a>;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EReal,STRIDE*CNT&lt;E&gt;::RealStrideFactor</a>&gt;         
<a name="l00172"></a><a class="code" href="classSimTK_1_1Row.html#a7034da7ace6f65aef7f726cf21966e76">00172</a>                                             <a class="code" href="classSimTK_1_1Row.html#a7034da7ace6f65aef7f726cf21966e76">TReal</a>;
<a name="l00173"></a>00173     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EImag,STRIDE*CNT&lt;E&gt;::RealStrideFactor</a>&gt;         
<a name="l00174"></a><a class="code" href="classSimTK_1_1Row.html#aa45de0454312ad5b857e2018dc0b4c29">00174</a>                                             <a class="code" href="classSimTK_1_1Row.html#aa45de0454312ad5b857e2018dc0b4c29">TImag</a>;
<a name="l00175"></a><a class="code" href="classSimTK_1_1Row.html#ade49d10743114309ebddbec3e37b773a">00175</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EComplex,STRIDE&gt;</a>          <a class="code" href="classSimTK_1_1Row.html#ade49d10743114309ebddbec3e37b773a">TComplex</a>;
<a name="l00176"></a><a class="code" href="classSimTK_1_1Row.html#affa8acc5dc7f4d1072b90be48057c68b">00176</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec&lt;N,EHerm,STRIDE&gt;</a>             <a class="code" href="classSimTK_1_1Row.html#affa8acc5dc7f4d1072b90be48057c68b">THerm</a>;
<a name="l00177"></a><a class="code" href="classSimTK_1_1Row.html#a9e0db17fb6caf22f4f197e7ca3542bd2">00177</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec&lt;N,E,STRIDE&gt;</a>                 <a class="code" href="classSimTK_1_1Row.html#a9e0db17fb6caf22f4f197e7ca3542bd2">TPosTrans</a>;
<a name="l00178"></a><a class="code" href="classSimTK_1_1Row.html#ad1081c99b49ed61c4a5a88e77c3fc95a">00178</a>     <span class="keyword">typedef</span> E                               <a class="code" href="classSimTK_1_1Row.html#ad1081c99b49ed61c4a5a88e77c3fc95a">TElement</a>;
<a name="l00179"></a><a class="code" href="classSimTK_1_1Row.html#ae1329b0e4f21542b68df12bf7394316c">00179</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>                             <a class="code" href="classSimTK_1_1Row.html#ae1329b0e4f21542b68df12bf7394316c">TRow</a>;
<a name="l00180"></a><a class="code" href="classSimTK_1_1Row.html#a5a44dd9a478aff194ff131805471e941">00180</a>     <span class="keyword">typedef</span> E                               <a class="code" href="classSimTK_1_1Row.html#a5a44dd9a478aff194ff131805471e941">TCol</a>;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     <span class="comment">// These are the results of calculations, so are returned in new, packed</span>
<a name="l00183"></a>00183     <span class="comment">// memory. Be sure to refer to element types here which are also packed.</span>
<a name="l00184"></a><a class="code" href="classSimTK_1_1Row.html#a0f36faeff4f4018824277c08dd715c01">00184</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec&lt;N,ESqrt,1&gt;</a>                  <a class="code" href="classSimTK_1_1Row.html#a0f36faeff4f4018824277c08dd715c01">TSqrt</a>;      <span class="comment">// Note stride</span>
<a name="l00185"></a><a class="code" href="classSimTK_1_1Row.html#a0c8548a08d21bf81b44b33b318a999c3">00185</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EAbs,1&gt;</a>                   <a class="code" href="classSimTK_1_1Row.html#a0c8548a08d21bf81b44b33b318a999c3">TAbs</a>;       <span class="comment">// Note stride</span>
<a name="l00186"></a><a class="code" href="classSimTK_1_1Row.html#a3a8ee9364160ba82b82a3127eec71761">00186</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EStandard,1&gt;</a>              <a class="code" href="classSimTK_1_1Row.html#a3a8ee9364160ba82b82a3127eec71761">TStandard</a>;
<a name="l00187"></a><a class="code" href="classSimTK_1_1Row.html#a76892dc0b458fd83c57a4b6dd1d01069">00187</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec&lt;N,EInvert,1&gt;</a>                <a class="code" href="classSimTK_1_1Row.html#a76892dc0b458fd83c57a4b6dd1d01069">TInvert</a>;    <span class="comment">// packed</span>
<a name="l00188"></a><a class="code" href="classSimTK_1_1Row.html#a976d06ec371d1b02361472a388333b2c">00188</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,ENormalize,1&gt;</a>             <a class="code" href="classSimTK_1_1Row.html#a976d06ec371d1b02361472a388333b2c">TNormalize</a>;
<a name="l00189"></a>00189 
<a name="l00190"></a><a class="code" href="classSimTK_1_1Row.html#abf3b1292df86f194ccecc8e73a9e2efc">00190</a>     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1SymMat.html" title="RS is total spacing between rows in memory (default 1)">SymMat&lt;N,ESqHermT&gt;</a>              <a class="code" href="classSimTK_1_1Row.html#abf3b1292df86f194ccecc8e73a9e2efc">TSqHermT</a>;   <span class="comment">// result of self outer product</span>
<a name="l00191"></a><a class="code" href="classSimTK_1_1Row.html#a622ee041022ce6347b824b7e8d841e8f">00191</a>     <span class="keyword">typedef</span> EScalarNormSq                   <a class="code" href="classSimTK_1_1Row.html#a622ee041022ce6347b824b7e8d841e8f">TSqTHerm</a>;   <span class="comment">// result of self dot product</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     <span class="comment">// These recurse right down to the underlying scalar type no matter how</span>
<a name="l00194"></a>00194     <span class="comment">// deep the elements are.</span>
<a name="l00195"></a><a class="code" href="classSimTK_1_1Row.html#a480792b8290a5eb86b5713ec2166a61c">00195</a>     <span class="keyword">typedef</span> EScalar                         <a class="code" href="classSimTK_1_1Row.html#a480792b8290a5eb86b5713ec2166a61c">Scalar</a>;
<a name="l00196"></a><a class="code" href="classSimTK_1_1Row.html#a1124fc1305a32af7e6732a34447c8da0">00196</a>     <span class="keyword">typedef</span> EULessScalar                    <a class="code" href="classSimTK_1_1Row.html#a1124fc1305a32af7e6732a34447c8da0">ULessScalar</a>;
<a name="l00197"></a><a class="code" href="classSimTK_1_1Row.html#aff5dfe42c1011ddd0dccec53968bc96c">00197</a>     <span class="keyword">typedef</span> ENumber                         <a class="code" href="classSimTK_1_1Row.html#aff5dfe42c1011ddd0dccec53968bc96c">Number</a>;
<a name="l00198"></a><a class="code" href="classSimTK_1_1Row.html#a7b66c71b8c910533108297072eca6610">00198</a>     <span class="keyword">typedef</span> EStdNumber                      <a class="code" href="classSimTK_1_1Row.html#a7b66c71b8c910533108297072eca6610">StdNumber</a>;
<a name="l00199"></a><a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">00199</a>     <span class="keyword">typedef</span> EPrecision                      <a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>;
<a name="l00200"></a><a class="code" href="classSimTK_1_1Row.html#ad80261c205d899c22801b362e2b7e038">00200</a>     <span class="keyword">typedef</span> EScalarNormSq                   <a class="code" href="classSimTK_1_1Row.html#ad80261c205d899c22801b362e2b7e038">ScalarNormSq</a>;
<a name="l00201"></a>00201 
<a name="l00202"></a><a class="code" href="classSimTK_1_1Row.html#ac2d8cf89c68930bfc28e887b9a6963ab">00202</a>     <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classSimTK_1_1Row.html#ac2d8cf89c68930bfc28e887b9a6963ab">size</a>() { <span class="keywordflow">return</span> N; }
<a name="l00203"></a><a class="code" href="classSimTK_1_1Row.html#a95371dd8657828bd1716072493153425">00203</a>     <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classSimTK_1_1Row.html#a95371dd8657828bd1716072493153425">nrow</a>() { <span class="keywordflow">return</span> 1; }
<a name="l00204"></a><a class="code" href="classSimTK_1_1Row.html#a9230ae82277efe1f59851e4b3a12d266">00204</a>     <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classSimTK_1_1Row.html#a9230ae82277efe1f59851e4b3a12d266">ncol</a>() { <span class="keywordflow">return</span> N; }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <span class="comment">// Scalar norm square is sum( conjugate squares of all scalars )</span>
<a name="l00208"></a><a class="code" href="classSimTK_1_1Row.html#a3df9077e61e3d0616f8318119bb95933">00208</a>     ScalarNormSq <a class="code" href="classSimTK_1_1Row.html#a3df9077e61e3d0616f8318119bb95933">scalarNormSqr</a>()<span class="keyword"> const </span>{ 
<a name="l00209"></a>00209         ScalarNormSq <a class="code" href="classSimTK_1_1Row.html#a2f9bc13fd5bfc50bb218e0200b9c283f">sum</a>(0);
<a name="l00210"></a>00210         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) sum += CNT&lt;E&gt;::scalarNormSqr(d[i*STRIDE]);
<a name="l00211"></a>00211         <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a2f9bc13fd5bfc50bb218e0200b9c283f">sum</a>;
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="comment">// sqrt() is elementwise square root; that is, the return value has the same</span>
<a name="l00215"></a>00215     <span class="comment">// dimension as this Vec but with each element replaced by whatever it thinks</span>
<a name="l00216"></a>00216     <span class="comment">// its square root is.</span>
<a name="l00217"></a><a class="code" href="classSimTK_1_1Row.html#a2e45f8907009fd4971edb5a91a30e1e9">00217</a>     TSqrt <a class="code" href="classSimTK_1_1Row.html#a2e45f8907009fd4971edb5a91a30e1e9">sqrt</a>()<span class="keyword"> const </span>{
<a name="l00218"></a>00218         TSqrt rsqrt;
<a name="l00219"></a>00219         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) rsqrt[i] = CNT&lt;E&gt;::sqrt(d[i*STRIDE]);
<a name="l00220"></a>00220         <span class="keywordflow">return</span> rsqrt;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="comment">// abs() is elementwise absolute value; that is, the return value has the same</span>
<a name="l00224"></a>00224     <span class="comment">// dimension as this Row but with each element replaced by whatever it thinks</span>
<a name="l00225"></a>00225     <span class="comment">// its absolute value is.</span>
<a name="l00226"></a><a class="code" href="classSimTK_1_1Row.html#a268c52fa7bea8e873099e29c48b519c6">00226</a>     TAbs <a class="code" href="classSimTK_1_1Row.html#a268c52fa7bea8e873099e29c48b519c6">abs</a>()<span class="keyword"> const </span>{
<a name="l00227"></a>00227         TAbs rabs;
<a name="l00228"></a>00228         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;<a class="code" href="namespaceSimTK.html#a63210772f3bd9e4b2eb35309408b173e">i&lt;N;++i) rabs[i] = CNT&lt;E&gt;::abs</a>(d[i*STRIDE]);
<a name="l00229"></a>00229         <span class="keywordflow">return</span> rabs;
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231 
<a name="l00232"></a><a class="code" href="classSimTK_1_1Row.html#aa614278c5db45f281ddd6b0c0f3e581d">00232</a>     TStandard <a class="code" href="classSimTK_1_1Row.html#aa614278c5db45f281ddd6b0c0f3e581d">standardize</a>()<span class="keyword"> const </span>{
<a name="l00233"></a>00233         TStandard rstd;
<a name="l00234"></a>00234         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) rstd[i] = CNT&lt;E&gt;::standardize(d[i*STRIDE]);
<a name="l00235"></a>00235         <span class="keywordflow">return</span> rstd;
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="comment">// Sum just adds up all the elements, getting rid of negators and</span>
<a name="l00239"></a>00239     <span class="comment">// conjugates in the process.</span>
<a name="l00240"></a><a class="code" href="classSimTK_1_1Row.html#a2f9bc13fd5bfc50bb218e0200b9c283f">00240</a>     EStandard <a class="code" href="classSimTK_1_1Row.html#a2f9bc13fd5bfc50bb218e0200b9c283f">sum</a>()<span class="keyword"> const </span>{
<a name="l00241"></a>00241         E <a class="code" href="classSimTK_1_1Row.html#a2f9bc13fd5bfc50bb218e0200b9c283f">sum</a>(0);
<a name="l00242"></a>00242         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;N;++i) sum += d[i*STRIDE];
<a name="l00243"></a>00243         <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#aa614278c5db45f281ddd6b0c0f3e581d">CNT&lt;E&gt;::standardize</a>(sum);
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="comment">// This gives the resulting rowvector type when (v[i] op P) is applied to each element of v.</span>
<a name="l00247"></a>00247     <span class="comment">// It is a row of length N, stride 1, and element types which are the regular</span>
<a name="l00248"></a>00248     <span class="comment">// composite result of E op P. Typically P is a scalar type but it doesn&#39;t have to be.</span>
<a name="l00249"></a><a class="code" href="structSimTK_1_1Row_1_1EltResult.html">00249</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1Row_1_1EltResult.html">EltResult</a> { 
<a name="l00250"></a><a class="code" href="structSimTK_1_1Row_1_1EltResult.html#a6a4bcf0b3b0db8e777d46580e09ced32">00250</a>         <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> <a class="code" href="structSimTK_1_1Row_1_1Result.html#a6bc38bb5810280246fe786d6960f2e76">Result&lt;P&gt;::Mul</a>, 1&gt; <a class="code" href="structSimTK_1_1Row_1_1EltResult.html#a6a4bcf0b3b0db8e777d46580e09ced32">Mul</a>;
<a name="l00251"></a><a class="code" href="structSimTK_1_1Row_1_1EltResult.html#aee109905ae73e3123a12cc64f58c3210">00251</a>         <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> <a class="code" href="structSimTK_1_1Row_1_1Result.html#aedb8102a431dd610a631f58088ca8c71">Result&lt;P&gt;::Dvd</a>, 1&gt; <a class="code" href="structSimTK_1_1Row_1_1EltResult.html#aee109905ae73e3123a12cc64f58c3210">Dvd</a>;
<a name="l00252"></a><a class="code" href="structSimTK_1_1Row_1_1EltResult.html#a5b2d0a834122a4ece0e153ff528df1ae">00252</a>         <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> <a class="code" href="structSimTK_1_1Row_1_1Result.html#a0f9d8e9110855006006a02dab077d49e">Result&lt;P&gt;::Add</a>, 1&gt; <a class="code" href="structSimTK_1_1Row_1_1EltResult.html#a5b2d0a834122a4ece0e153ff528df1ae">Add</a>;
<a name="l00253"></a><a class="code" href="structSimTK_1_1Row_1_1EltResult.html#aeac33556ee2b472c0242037a5633b8c4">00253</a>         <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> <a class="code" href="structSimTK_1_1Row_1_1Result.html#af1fe82823421a710206e21426561ce5d">Result&lt;P&gt;::Sub</a>, 1&gt; <a class="code" href="structSimTK_1_1Row_1_1EltResult.html#aeac33556ee2b472c0242037a5633b8c4">Sub</a>;
<a name="l00254"></a>00254     };
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="comment">// This is the composite result for v op P where P is some kind of appropriately shaped</span>
<a name="l00257"></a>00257     <span class="comment">// non-scalar type.</span>
<a name="l00258"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html">00258</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1Row_1_1Result.html">Result</a> { 
<a name="l00259"></a>00259         <span class="keyword">typedef</span> MulCNTs&lt;1,N,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da307e4f5f28ff4064f9c157d4e5dad471">ArgDepth</a>,<a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8d80af559e65583df96f721c216bd180">ColSpacing</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da40b9d98ff7f78ef1e57710b83fd82473">RowSpacing</a>,
<a name="l00260"></a>00260             <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NRows</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NCols</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ArgDepth</a>,
<a name="l00261"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#adc72acd444c3afd4fd9cac4996fd4842">00261</a>             P, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ColSpacing</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::RowSpacing</a>&gt; <a class="code" href="structSimTK_1_1Row_1_1Result.html#adc72acd444c3afd4fd9cac4996fd4842">MulOp</a>;
<a name="l00262"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#a6bc38bb5810280246fe786d6960f2e76">00262</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> MulOp::Type <a class="code" href="structSimTK_1_1Row_1_1Result.html#a6bc38bb5810280246fe786d6960f2e76">Mul</a>;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264         <span class="keyword">typedef</span> MulCNTsNonConforming&lt;1,N,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da307e4f5f28ff4064f9c157d4e5dad471">ArgDepth</a>,<a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8d80af559e65583df96f721c216bd180">ColSpacing</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da40b9d98ff7f78ef1e57710b83fd82473">RowSpacing</a>,
<a name="l00265"></a>00265             <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NRows</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NCols</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ArgDepth</a>,
<a name="l00266"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#a339e0a3dac358f68f813c8e50479791b">00266</a>             P, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ColSpacing</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::RowSpacing</a>&gt; <a class="code" href="structSimTK_1_1Row_1_1Result.html#a339e0a3dac358f68f813c8e50479791b">MulOpNonConforming</a>;
<a name="l00267"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#aa1106b9fd459c791702ef71fc4e63c6b">00267</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> MulOpNonConforming::Type <a class="code" href="structSimTK_1_1Row_1_1Result.html#aa1106b9fd459c791702ef71fc4e63c6b">MulNon</a>;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         <span class="keyword">typedef</span> DvdCNTs&lt;1,N,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da307e4f5f28ff4064f9c157d4e5dad471">ArgDepth</a>,<a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8d80af559e65583df96f721c216bd180">ColSpacing</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da40b9d98ff7f78ef1e57710b83fd82473">RowSpacing</a>,
<a name="l00271"></a>00271             <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NRows</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NCols</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ArgDepth</a>,
<a name="l00272"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#aa6f1586a78838b2af381d6d15af2a727">00272</a>             P, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ColSpacing</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::RowSpacing</a>&gt; <a class="code" href="structSimTK_1_1Row_1_1Result.html#aa6f1586a78838b2af381d6d15af2a727">DvdOp</a>;
<a name="l00273"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#aedb8102a431dd610a631f58088ca8c71">00273</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> DvdOp::Type <a class="code" href="structSimTK_1_1Row_1_1Result.html#aedb8102a431dd610a631f58088ca8c71">Dvd</a>;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         <span class="keyword">typedef</span> AddCNTs&lt;1,N,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da307e4f5f28ff4064f9c157d4e5dad471">ArgDepth</a>,<a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8d80af559e65583df96f721c216bd180">ColSpacing</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da40b9d98ff7f78ef1e57710b83fd82473">RowSpacing</a>,
<a name="l00276"></a>00276             <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NRows</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NCols</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ArgDepth</a>,
<a name="l00277"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#a519bd5790550601d933f5743477507e2">00277</a>             P, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ColSpacing</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::RowSpacing</a>&gt; <a class="code" href="structSimTK_1_1Row_1_1Result.html#a519bd5790550601d933f5743477507e2">AddOp</a>;
<a name="l00278"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#a0f9d8e9110855006006a02dab077d49e">00278</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> AddOp::Type <a class="code" href="structSimTK_1_1Row_1_1Result.html#a0f9d8e9110855006006a02dab077d49e">Add</a>;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         <span class="keyword">typedef</span> SubCNTs&lt;1,N,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da307e4f5f28ff4064f9c157d4e5dad471">ArgDepth</a>,<a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da8d80af559e65583df96f721c216bd180">ColSpacing</a>,<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da40b9d98ff7f78ef1e57710b83fd82473">RowSpacing</a>,
<a name="l00281"></a>00281             <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NRows</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::NCols</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ArgDepth</a>,
<a name="l00282"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#a7465bd8b43eae27a12664d612df36372">00282</a>             P, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::ColSpacing</a>, <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;P&gt;::RowSpacing</a>&gt; <a class="code" href="structSimTK_1_1Row_1_1Result.html#a7465bd8b43eae27a12664d612df36372">SubOp</a>;
<a name="l00283"></a><a class="code" href="structSimTK_1_1Row_1_1Result.html#af1fe82823421a710206e21426561ce5d">00283</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> SubOp::Type <a class="code" href="structSimTK_1_1Row_1_1Result.html#af1fe82823421a710206e21426561ce5d">Sub</a>;
<a name="l00284"></a>00284     };
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="comment">// Shape-preserving element substitution (always packed)</span>
<a name="l00287"></a><a class="code" href="structSimTK_1_1Row_1_1Substitute.html">00287</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> P&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1Row_1_1Substitute.html">Substitute</a> {
<a name="l00288"></a><a class="code" href="structSimTK_1_1Row_1_1Substitute.html#a3818409a903267880a287747bbd0cf32">00288</a>         <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,P&gt;</a> <a class="code" href="structSimTK_1_1Row_1_1Substitute.html#a3818409a903267880a287747bbd0cf32">Type</a>;
<a name="l00289"></a>00289     };
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <span class="comment">// Default construction initializes to NaN when debugging but</span>
<a name="l00292"></a>00292     <span class="comment">// is left uninitialized otherwise.</span>
<a name="l00293"></a><a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">00293</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(){ 
<a name="l00294"></a>00294 <span class="preprocessor">    #ifndef NDEBUG</span>
<a name="l00295"></a>00295 <span class="preprocessor"></span>        <a class="code" href="classSimTK_1_1Row.html#a2c76e2c75a2d812201c1196aed1b8e3f" title="Set every scalar in this Row to NaN; this is the default initial value in Debug builds, but not in Release.">setToNaN</a>();
<a name="l00296"></a>00296 <span class="preprocessor">    #endif</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span>    }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299     <span class="comment">// It&#39;s important not to use the default copy constructor or copy</span>
<a name="l00300"></a>00300     <span class="comment">// assignment because the compiler doesn&#39;t understand that we may</span>
<a name="l00301"></a>00301     <span class="comment">// have noncontiguous storage and will try to copy the whole array.</span>
<a name="l00302"></a><a class="code" href="classSimTK_1_1Row.html#a969fdd7c3d4e71a66e1f6cc137ba072a">00302</a>     <a class="code" href="classSimTK_1_1Row.html#a969fdd7c3d4e71a66e1f6cc137ba072a">Row</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; src) {
<a name="l00303"></a>00303         <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">Impl::copy</a>(*<span class="keyword">this</span>, src);
<a name="l00304"></a>00304     }
<a name="l00305"></a><a class="code" href="classSimTK_1_1Row.html#aeb77180daa8675e0f1ec5c531685edc3">00305</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#aeb77180daa8675e0f1ec5c531685edc3">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; src) {    <span class="comment">// no harm if src and &#39;this&#39; are the same</span>
<a name="l00306"></a>00306         <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">Impl::copy</a>(*<span class="keyword">this</span>, src);
<a name="l00307"></a>00307         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="comment">// We want an implicit conversion from a Row of the same length</span>
<a name="l00311"></a>00311     <span class="comment">// and element type but with a different stride.</span>
<a name="l00312"></a><a class="code" href="classSimTK_1_1Row.html#a66143e750388048a0ebcf407d3747485">00312</a>     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html#a66143e750388048a0ebcf407d3747485">Row</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,SS&gt;</a>&amp; src) {
<a name="l00313"></a>00313         <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">Impl::copy</a>(*<span class="keyword">this</span>, src);
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <span class="comment">// We want an implicit conversion from a Row of the same length</span>
<a name="l00317"></a>00317     <span class="comment">// and *negated* element type, possibly with a different stride.</span>
<a name="l00318"></a><a class="code" href="classSimTK_1_1Row.html#ab7d3ecfac811f2e10b7e0a10c4a58889">00318</a>     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html#ab7d3ecfac811f2e10b7e0a10c4a58889">Row</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,ENeg,SS&gt;</a>&amp; src) {
<a name="l00319"></a>00319         <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">Impl::copy</a>(*<span class="keyword">this</span>, src);
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     <span class="comment">// Construct a Row from a Row of the same length, with any</span>
<a name="l00323"></a>00323     <span class="comment">// stride. Works as long as the element types are compatible.</span>
<a name="l00324"></a><a class="code" href="classSimTK_1_1Row.html#a32b546cefb72f6413342baa27c44c09d">00324</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Row.html#a32b546cefb72f6413342baa27c44c09d">Row</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EE,SS&gt;</a>&amp; vv) {
<a name="l00325"></a>00325         <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">Impl::copy</a>(*<span class="keyword">this</span>, vv);
<a name="l00326"></a>00326     }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     <span class="comment">// Construction using an element assigns to each element.</span>
<a name="l00329"></a><a class="code" href="classSimTK_1_1Row.html#a5f3fb71e69f5bc4d8e9b78002d3586c9">00329</a>     <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e)
<a name="l00330"></a>00330       { <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE]=e; }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332     <span class="comment">// Construction using a negated element assigns to each element.</span>
<a name="l00333"></a><a class="code" href="classSimTK_1_1Row.html#adca7cddbdcec6a4bceff90373c11f634">00333</a>     <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> ENeg&amp; ne)
<a name="l00334"></a>00334       { <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE]=ne; }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336     <span class="comment">// Given an int, turn it into a suitable floating point number</span>
<a name="l00337"></a>00337     <span class="comment">// and then feed that to the above single-element constructor.</span>
<a name="l00338"></a><a class="code" href="classSimTK_1_1Row.html#a93854da7e681f0ed7af3706b7b25cdaa">00338</a>     <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keywordtype">int</span> i) 
<a name="l00339"></a>00339       { <span class="keyword">new</span> (<span class="keyword">this</span>) <a class="code" href="classSimTK_1_1Row.html#a93854da7e681f0ed7af3706b7b25cdaa">Row</a>(E(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(i))); }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341     <span class="comment">// A bevy of constructors for Rows up to length 6.</span>
<a name="l00342"></a><a class="code" href="classSimTK_1_1Row.html#a9c9dae82d01e32aaf8aef7a580b21a95">00342</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e0,<span class="keyword">const</span> E&amp; e1)
<a name="l00343"></a>00343       { assert(N==2);(*this)[0]=e0;(*this)[1]=e1; }
<a name="l00344"></a><a class="code" href="classSimTK_1_1Row.html#a2179f169f0bab9c8804e3c06924343ed">00344</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e0,<span class="keyword">const</span> E&amp; e1,<span class="keyword">const</span> E&amp; e2)
<a name="l00345"></a>00345       { assert(N==3);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2; }
<a name="l00346"></a><a class="code" href="classSimTK_1_1Row.html#aa6c70b4fe3165727b837b6f93f15ff3f">00346</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e0,<span class="keyword">const</span> E&amp; e1,<span class="keyword">const</span> E&amp; e2,<span class="keyword">const</span> E&amp; e3)
<a name="l00347"></a>00347       { assert(N==4);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;(*this)[3]=e3; }
<a name="l00348"></a><a class="code" href="classSimTK_1_1Row.html#aa20dff17fc631e9ebeb1953683ece96b">00348</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e0,<span class="keyword">const</span> E&amp; e1,<span class="keyword">const</span> E&amp; e2,<span class="keyword">const</span> E&amp; e3,<span class="keyword">const</span> E&amp; e4)
<a name="l00349"></a>00349       { assert(N==5);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
<a name="l00350"></a>00350         (*this)[3]=e3;(*this)[4]=e4; }
<a name="l00351"></a><a class="code" href="classSimTK_1_1Row.html#a44d79c2a5b8c2b6c9bc4c669eaa819c1">00351</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e0,<span class="keyword">const</span> E&amp; e1,<span class="keyword">const</span> E&amp; e2,<span class="keyword">const</span> E&amp; e3,<span class="keyword">const</span> E&amp; e4,<span class="keyword">const</span> E&amp; e5)
<a name="l00352"></a>00352       { assert(N==6);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
<a name="l00353"></a>00353         (*this)[3]=e3;(*this)[4]=e4;(*this)[5]=e5; }
<a name="l00354"></a><a class="code" href="classSimTK_1_1Row.html#af4f0a3961c6cb1ec2efc0fdfeebaad07">00354</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e0,<span class="keyword">const</span> E&amp; e1,<span class="keyword">const</span> E&amp; e2,<span class="keyword">const</span> E&amp; e3,<span class="keyword">const</span> E&amp; e4,<span class="keyword">const</span> E&amp; e5,<span class="keyword">const</span> E&amp; e6)
<a name="l00355"></a>00355       { assert(N==7);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
<a name="l00356"></a>00356         (*this)[3]=e3;(*this)[4]=e4;(*this)[5]=e5;(*this)[6]=e6; }
<a name="l00357"></a><a class="code" href="classSimTK_1_1Row.html#ac70e294ade4785caedf850252ad1505b">00357</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e0,<span class="keyword">const</span> E&amp; e1,<span class="keyword">const</span> E&amp; e2,<span class="keyword">const</span> E&amp; e3,<span class="keyword">const</span> E&amp; e4,<span class="keyword">const</span> E&amp; e5,<span class="keyword">const</span> E&amp; e6,<span class="keyword">const</span> E&amp; e7)
<a name="l00358"></a>00358       { assert(N==8);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
<a name="l00359"></a>00359         (*this)[3]=e3;(*this)[4]=e4;(*this)[5]=e5;(*this)[6]=e6;(*this)[7]=e7; }
<a name="l00360"></a><a class="code" href="classSimTK_1_1Row.html#a8784a09a0ac0bcf402b18f8177035815">00360</a>     <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> E&amp; e0,<span class="keyword">const</span> E&amp; e1,<span class="keyword">const</span> E&amp; e2,<span class="keyword">const</span> E&amp; e3,<span class="keyword">const</span> E&amp; e4,<span class="keyword">const</span> E&amp; e5,<span class="keyword">const</span> E&amp; e6,<span class="keyword">const</span> E&amp; e7,<span class="keyword">const</span> E&amp; e8)
<a name="l00361"></a>00361       { assert(N==9);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
<a name="l00362"></a>00362         (*this)[3]=e3;(*this)[4]=e4;(*this)[5]=e5;(*this)[6]=e6;(*this)[7]=e7;(*this)[8]=e8; }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364     <span class="comment">// Construction from a pointer to anything assumes we&#39;re pointing</span>
<a name="l00365"></a>00365     <span class="comment">// at an element list of the right length.</span>
<a name="l00366"></a><a class="code" href="classSimTK_1_1Row.html#ab0c183a06c6f8c1b0ef5a55833b59f86">00366</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Row.html#acdc3f9d9633c0a5fa282dc208b45e472">Row</a>(<span class="keyword">const</span> EE* p)
<a name="l00367"></a>00367       { assert(p); <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE]=p[i]; }
<a name="l00368"></a><a class="code" href="classSimTK_1_1Row.html#a35c1e661269476038b7f193c74f94b2a">00368</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#aeb77180daa8675e0f1ec5c531685edc3">operator=</a>(<span class="keyword">const</span> EE* p)
<a name="l00369"></a>00369       { assert(p); <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE]=p[i]; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371     <span class="comment">// Conforming assignment ops.</span>
<a name="l00372"></a><a class="code" href="classSimTK_1_1Row.html#a917b253a208941971d4cd418194d48e8">00372</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a917b253a208941971d4cd418194d48e8">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EE,SS&gt;</a>&amp; vv) {
<a name="l00373"></a>00373         <a class="code" href="namespaceSimTK_1_1Impl.html#a0395ac7c179ad303ca72fc7626ff7a3e">Impl::copy</a>(*<span class="keyword">this</span>, vv);
<a name="l00374"></a>00374         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00375"></a>00375     }
<a name="l00376"></a><a class="code" href="classSimTK_1_1Row.html#acaf93ceaa101780ae7113b82957b0400">00376</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#acaf93ceaa101780ae7113b82957b0400">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EE,SS&gt;</a>&amp; r)
<a name="l00377"></a>00377       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] += r[i]; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00378"></a><a class="code" href="classSimTK_1_1Row.html#a7441ae336965e0625fa137df6c0758bc">00378</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#acaf93ceaa101780ae7113b82957b0400">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N,<a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;EE&gt;</a>,SS&gt;&amp; r)
<a name="l00379"></a>00379       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] -= -(r[i]); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00380"></a><a class="code" href="classSimTK_1_1Row.html#a73ef8c76e5c07cecf8a897ca24fe3631">00380</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a73ef8c76e5c07cecf8a897ca24fe3631">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EE,SS&gt;</a>&amp; r)
<a name="l00381"></a>00381       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] -= r[i]; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00382"></a><a class="code" href="classSimTK_1_1Row.html#aa97a59ae6d2a5b89fa2a3349a3c7311a">00382</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a73ef8c76e5c07cecf8a897ca24fe3631">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N,<a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;EE&gt;</a>,SS&gt;&amp; r)
<a name="l00383"></a>00383       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] += -(r[i]); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     <span class="comment">// Conforming binary ops with &#39;this&#39; on left, producing new packed result.</span>
<a name="l00386"></a>00386     <span class="comment">// Cases: r=r+r, r=r-r, s=r*v r=r*m</span>
<a name="l00387"></a>00387 
<a name="l00389"></a>00389     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Add&gt;
<a name="l00390"></a><a class="code" href="classSimTK_1_1Row.html#a79b3184d001d71213cdd4628994c971e">00390</a>     <a class="code" href="classSimTK_1_1Row.html#a79b3184d001d71213cdd4628994c971e" title="Vector addition -- use operator+ instead.">conformingAdd</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EE,SS&gt;</a>&amp; r)<span class="keyword"> const </span>{
<a name="l00391"></a>00391         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Add&gt; result;
<a name="l00392"></a>00392         <a class="code" href="classSimTK_1_1Row.html#a79b3184d001d71213cdd4628994c971e" title="Vector addition -- use operator+ instead.">Impl::conformingAdd</a>(*<span class="keyword">this</span>, r, result);
<a name="l00393"></a>00393         <span class="keywordflow">return</span> result;
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395 
<a name="l00397"></a>00397     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Sub&gt;
<a name="l00398"></a><a class="code" href="classSimTK_1_1Row.html#a33ebd8f02ed811cd5f99207f8f23e5e4">00398</a>     <a class="code" href="classSimTK_1_1Row.html#a33ebd8f02ed811cd5f99207f8f23e5e4" title="Vector subtraction -- use operator- instead.">conformingSubtract</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EE,SS&gt;</a>&amp; r)<span class="keyword"> const </span>{
<a name="l00399"></a>00399         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Sub&gt; result;
<a name="l00400"></a>00400         <a class="code" href="classSimTK_1_1Row.html#a33ebd8f02ed811cd5f99207f8f23e5e4" title="Vector subtraction -- use operator- instead.">Impl::conformingSubtract</a>(*<span class="keyword">this</span>, r, result);
<a name="l00401"></a>00401         <span class="keywordflow">return</span> result;
<a name="l00402"></a>00402     }
<a name="l00403"></a>00403 
<a name="l00405"></a>00405     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Mul
<a name="l00406"></a><a class="code" href="classSimTK_1_1Row.html#a85fbdf4cee4b9da147df20ea15663a6d">00406</a>     <a class="code" href="classSimTK_1_1Row.html#a85fbdf4cee4b9da147df20ea15663a6d" title="Same as dot product (s = row*col) -- use operator* or dot() instead.">conformingMultiply</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec&lt;N,EE,SS&gt;</a>&amp; r)<span class="keyword"> const </span>{
<a name="l00407"></a>00407         <span class="keywordflow">return</span> (*<span class="keyword">this</span>)*r;
<a name="l00408"></a>00408     }
<a name="l00409"></a>00409 
<a name="l00411"></a>00411     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> MatNCol, <span class="keyword">class</span> EE, <span class="keywordtype">int</span> CS, <span class="keywordtype">int</span> RS&gt; 
<a name="l00412"></a>00412     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;MatNCol,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Mul&gt;
<a name="l00413"></a><a class="code" href="classSimTK_1_1Row.html#a2f4ef275de900cb400df3a288df3050a">00413</a>     <a class="code" href="classSimTK_1_1Row.html#a2f4ef275de900cb400df3a288df3050a" title="Row times a conforming matrix, row=row*mat -- use operator* instead.">conformingMultiply</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Mat.html" title="This class represents a small matrix whose size is known at compile time, containing elements of any ...">Mat&lt;N,MatNCol,EE,CS,RS&gt;</a>&amp; m)<span class="keyword"> const </span>{
<a name="l00414"></a>00414         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;MatNCol,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Mul&gt; result;
<a name="l00415"></a>00415         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;N;++j) result[j] = <a class="code" href="classSimTK_1_1Row.html#a85fbdf4cee4b9da147df20ea15663a6d" title="Same as dot product (s = row*col) -- use operator* or dot() instead.">conformingMultiply</a>(m(j));
<a name="l00416"></a>00416         <span class="keywordflow">return</span> result;
<a name="l00417"></a>00417     }
<a name="l00418"></a>00418 
<a name="l00420"></a>00420     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Mul&gt;
<a name="l00421"></a><a class="code" href="classSimTK_1_1Row.html#aea4b9459d8deb1e89808dc62a1172a2c">00421</a>     <a class="code" href="classSimTK_1_1Row.html#aea4b9459d8deb1e89808dc62a1172a2c" title="Elementwise multiply (Matlab .">elementwiseMultiply</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EE,SS&gt;</a>&amp; r)<span class="keyword"> const </span>{
<a name="l00422"></a>00422         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Mul&gt; result;
<a name="l00423"></a>00423         <a class="code" href="classSimTK_1_1Row.html#aea4b9459d8deb1e89808dc62a1172a2c" title="Elementwise multiply (Matlab .">Impl::elementwiseMultiply</a>(*<span class="keyword">this</span>, r, result);
<a name="l00424"></a>00424         <span class="keywordflow">return</span> result;
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426 
<a name="l00428"></a>00428     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE, <span class="keywordtype">int</span> SS&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Dvd&gt;
<a name="l00429"></a><a class="code" href="classSimTK_1_1Row.html#a48f97bbd95bda2281d9c33b11cb3be80">00429</a>     <a class="code" href="classSimTK_1_1Row.html#a48f97bbd95bda2281d9c33b11cb3be80" title="Elementwise divide (Matlab .">elementwiseDivide</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,EE,SS&gt;</a>&amp; r)<span class="keyword"> const </span>{
<a name="l00430"></a>00430         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Dvd&gt; result;
<a name="l00431"></a>00431         <a class="code" href="classSimTK_1_1Row.html#a48f97bbd95bda2281d9c33b11cb3be80" title="Elementwise divide (Matlab .">Impl::elementwiseDivide</a>(*<span class="keyword">this</span>, r, result);
<a name="l00432"></a>00432         <span class="keywordflow">return</span> result;
<a name="l00433"></a>00433     }
<a name="l00434"></a>00434 
<a name="l00435"></a><a class="code" href="classSimTK_1_1Row.html#a359a6be2d5a7d9bd4480694b8472caed">00435</a>     <span class="keyword">const</span> E&amp; <a class="code" href="classSimTK_1_1Row.html#a359a6be2d5a7d9bd4480694b8472caed">operator[]</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{ assert(0 &lt;= i &amp;&amp; i &lt; N); <span class="keywordflow">return</span> d[i*STRIDE]; }
<a name="l00436"></a><a class="code" href="classSimTK_1_1Row.html#add318512a3de5d5638dd33bdc998b273">00436</a>     E&amp;       <a class="code" href="classSimTK_1_1Row.html#add318512a3de5d5638dd33bdc998b273">operator[]</a>(<span class="keywordtype">int</span> i)       { assert(0 &lt;= i &amp;&amp; i &lt; N); <span class="keywordflow">return</span> d[i*STRIDE]; }
<a name="l00437"></a><a class="code" href="classSimTK_1_1Row.html#a0559bf8e033f533adbf1102a6e6028c3">00437</a>     <span class="keyword">const</span> E&amp; <a class="code" href="classSimTK_1_1Row.html#a0559bf8e033f533adbf1102a6e6028c3">operator()</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[i]; }
<a name="l00438"></a><a class="code" href="classSimTK_1_1Row.html#a7431e7d8d261931fe8bf8a4c70ec7491">00438</a>     E&amp;       <a class="code" href="classSimTK_1_1Row.html#a7431e7d8d261931fe8bf8a4c70ec7491">operator()</a>(<span class="keywordtype">int</span> i)       { <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[i]; }
<a name="l00439"></a>00439 
<a name="l00440"></a><a class="code" href="classSimTK_1_1Row.html#aec0962cd4b4f75d27b55742b1da977ec">00440</a>     ScalarNormSq <a class="code" href="classSimTK_1_1Row.html#aec0962cd4b4f75d27b55742b1da977ec">normSqr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a3df9077e61e3d0616f8318119bb95933">scalarNormSqr</a>(); }
<a name="l00441"></a>00441     <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#a8a063f3c7cb38f49db3f593bba18478d">CNT&lt;ScalarNormSq&gt;::TSqrt</a> 
<a name="l00442"></a><a class="code" href="classSimTK_1_1Row.html#aa37edb9dd77ae17972d832344b3e0a84">00442</a>         <a class="code" href="classSimTK_1_1Row.html#aa37edb9dd77ae17972d832344b3e0a84">norm</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a2e45f8907009fd4971edb5a91a30e1e9">CNT&lt;ScalarNormSq&gt;::sqrt</a>(<a class="code" href="classSimTK_1_1Row.html#a3df9077e61e3d0616f8318119bb95933">scalarNormSqr</a>()); }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444     <span class="comment">// If the elements of this Row are scalars, the result is what you get by</span>
<a name="l00445"></a>00445     <span class="comment">// dividing each element by the norm() calculated above. If the elements are</span>
<a name="l00446"></a>00446     <span class="comment">// *not* scalars, then the elements are *separately* normalized. That means</span>
<a name="l00447"></a>00447     <span class="comment">// you will get a different answer from Row&lt;2,Row3&gt;::normalize() than you</span>
<a name="l00448"></a>00448     <span class="comment">// would from a Row&lt;6&gt;::normalize() containing the same scalars.</span>
<a name="l00449"></a>00449     <span class="comment">//</span>
<a name="l00450"></a>00450     <span class="comment">// Normalize returns a row of the same dimension but in new, packed storage</span>
<a name="l00451"></a>00451     <span class="comment">// and with a return type that does not include negator&lt;&gt; even if the original</span>
<a name="l00452"></a>00452     <span class="comment">// Row&lt;&gt; does, because we can eliminate the negation here almost for free.</span>
<a name="l00453"></a>00453     <span class="comment">// But we can&#39;t standardize (change conjugate to complex) for free, so we&#39;ll retain</span>
<a name="l00454"></a>00454     <span class="comment">// conjugates if there are any.</span>
<a name="l00455"></a><a class="code" href="classSimTK_1_1Row.html#a732444b4e5696134b1a97c030c5debd0">00455</a>     TNormalize <a class="code" href="classSimTK_1_1Row.html#a732444b4e5696134b1a97c030c5debd0">normalize</a>()<span class="keyword"> const </span>{
<a name="l00456"></a>00456         <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E&gt;::IsScalar</a>) {
<a name="l00457"></a>00457             <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#adcbaf9bd64efd41d60bfde78de09daa2">castAwayNegatorIfAny</a>() / (<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da55253a2d371aeeb8ca91cd454f274370">SignInterpretation</a>*<a class="code" href="classSimTK_1_1Row.html#aa37edb9dd77ae17972d832344b3e0a84">norm</a>());
<a name="l00458"></a>00458         } <span class="keywordflow">else</span> {
<a name="l00459"></a>00459             TNormalize elementwiseNormalized;
<a name="l00460"></a>00460             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) 
<a name="l00461"></a>00461                 elementwiseNormalized[j] = <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;E&gt;::normalize</a>((*<span class="keyword">this</span>)[j]);
<a name="l00462"></a>00462             <span class="keywordflow">return</span> elementwiseNormalized;
<a name="l00463"></a>00463         }
<a name="l00464"></a>00464     }
<a name="l00465"></a>00465 
<a name="l00466"></a><a class="code" href="classSimTK_1_1Row.html#a2654c0a54a87236a42d087bae0b646e9">00466</a>     TInvert <a class="code" href="classSimTK_1_1Row.html#a2654c0a54a87236a42d087bae0b646e9">invert</a>()<span class="keyword"> const </span>{assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a76892dc0b458fd83c57a4b6dd1d01069">TInvert</a>();} <span class="comment">// TODO default inversion</span>
<a name="l00467"></a>00467 
<a name="l00468"></a><a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">00468</a>     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp;   <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00469"></a><a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">00469</a>     <span class="keyword">const</span> TNeg&amp;  <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#af82a6cc7b60e2ad00d3dc7390f778283">negate</a>(); }
<a name="l00470"></a><a class="code" href="classSimTK_1_1Row.html#a4834a48f8b0dc57d17c2cb6460c53462">00470</a>     TNeg&amp;        <a class="code" href="classSimTK_1_1Row.html#a4834a48f8b0dc57d17c2cb6460c53462">operator-</a>()       { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#ad423dfd4e6cf12e453eaddce5f710878">updNegate</a>(); }
<a name="l00471"></a><a class="code" href="classSimTK_1_1Row.html#a67cfa8bc0f0182218174ed0ec09e57f8">00471</a>     <span class="keyword">const</span> THerm&amp; <a class="code" href="classSimTK_1_1Row.html#a67cfa8bc0f0182218174ed0ec09e57f8">operator~</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#ab81cfcf1d7a2a8450c6d18a655cdf669">transpose</a>(); }
<a name="l00472"></a><a class="code" href="classSimTK_1_1Row.html#a18ae609913aaf87f54250eb4c29be8ac">00472</a>     THerm&amp;       <a class="code" href="classSimTK_1_1Row.html#a18ae609913aaf87f54250eb4c29be8ac">operator~</a>()       { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a96c523142e43808e9a297f1a47f20abf">updTranspose</a>(); }
<a name="l00473"></a>00473 
<a name="l00474"></a><a class="code" href="classSimTK_1_1Row.html#af82a6cc7b60e2ad00d3dc7390f778283">00474</a>     <span class="keyword">const</span> TNeg&amp;  <a class="code" href="classSimTK_1_1Row.html#af82a6cc7b60e2ad00d3dc7390f778283">negate</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>TNeg*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00475"></a><a class="code" href="classSimTK_1_1Row.html#ad423dfd4e6cf12e453eaddce5f710878">00475</a>     TNeg&amp;        <a class="code" href="classSimTK_1_1Row.html#ad423dfd4e6cf12e453eaddce5f710878">updNegate</a>()    { <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span>TNeg*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00476"></a>00476 
<a name="l00477"></a><a class="code" href="classSimTK_1_1Row.html#ab81cfcf1d7a2a8450c6d18a655cdf669">00477</a>     <span class="keyword">const</span> THerm&amp; <a class="code" href="classSimTK_1_1Row.html#ab81cfcf1d7a2a8450c6d18a655cdf669">transpose</a>()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>THerm*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00478"></a><a class="code" href="classSimTK_1_1Row.html#a96c523142e43808e9a297f1a47f20abf">00478</a>     THerm&amp;       <a class="code" href="classSimTK_1_1Row.html#a96c523142e43808e9a297f1a47f20abf">updTranspose</a>()       { <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span>THerm*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00479"></a>00479 
<a name="l00480"></a><a class="code" href="classSimTK_1_1Row.html#ada14b0598165c802e4ff0d6b73725e0e">00480</a>     <span class="keyword">const</span> TPosTrans&amp; <a class="code" href="classSimTK_1_1Row.html#ada14b0598165c802e4ff0d6b73725e0e">positionalTranspose</a>()<span class="keyword"> const</span>
<a name="l00481"></a>00481 <span class="keyword">        </span>{ <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>TPosTrans*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00482"></a><a class="code" href="classSimTK_1_1Row.html#a6b25d3bdbb558c974f4d207fc372745e">00482</a>     TPosTrans&amp;       <a class="code" href="classSimTK_1_1Row.html#a6b25d3bdbb558c974f4d207fc372745e">updPositionalTranspose</a>()
<a name="l00483"></a>00483         { <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span>TPosTrans*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00484"></a>00484 
<a name="l00485"></a><a class="code" href="classSimTK_1_1Row.html#ac228bb4964195e25bb73934de0654d5f">00485</a>     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">TReal</a>&amp; <a class="code" href="classSimTK_1_1Row.html#ac228bb4964195e25bb73934de0654d5f">real</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">TReal</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00486"></a><a class="code" href="classSimTK_1_1Row.html#a43514343948d06b9ff0c43876c3c29d4">00486</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">TReal</a>&amp;       <a class="code" href="classSimTK_1_1Row.html#a43514343948d06b9ff0c43876c3c29d4">real</a>()       { <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span>      <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">TReal</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488     <span class="comment">// Had to contort these routines to get them through VC++ 7.net</span>
<a name="l00489"></a><a class="code" href="classSimTK_1_1Row.html#a07bdc4904d64c799126e10534d306463">00489</a>     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">TImag</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a07bdc4904d64c799126e10534d306463">imag</a>()<span class="keyword">    const </span>{ 
<a name="l00490"></a>00490         <span class="keyword">const</span> <span class="keywordtype">int</span> offs = <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da6c1a3e35ad67d57f2d943dfc335b5028">ImagOffset</a>;
<a name="l00491"></a>00491         <span class="keyword">const</span> EImag* p = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>EImag*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00492"></a>00492         <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">TImag</a>*<span class="keyword">&gt;</span>(p+offs);
<a name="l00493"></a>00493     }
<a name="l00494"></a><a class="code" href="classSimTK_1_1Row.html#a9032bcdc8a9593bb8644fc2e9c880301">00494</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">TImag</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a9032bcdc8a9593bb8644fc2e9c880301">imag</a>() { 
<a name="l00495"></a>00495         <span class="keyword">const</span> <span class="keywordtype">int</span> offs = <a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da6c1a3e35ad67d57f2d943dfc335b5028">ImagOffset</a>;
<a name="l00496"></a>00496         EImag* p = <span class="keyword">reinterpret_cast&lt;</span>EImag*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00497"></a>00497         <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">TImag</a>*<span class="keyword">&gt;</span>(p+offs);
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499 
<a name="l00500"></a><a class="code" href="classSimTK_1_1Row.html#adcbaf9bd64efd41d60bfde78de09daa2">00500</a>     <span class="keyword">const</span> TWithoutNegator&amp; <a class="code" href="classSimTK_1_1Row.html#adcbaf9bd64efd41d60bfde78de09daa2">castAwayNegatorIfAny</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>TWithoutNegator*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);}
<a name="l00501"></a><a class="code" href="classSimTK_1_1Row.html#a4183feaa6c23b9eeb533bb874542a450">00501</a>     TWithoutNegator&amp;       <a class="code" href="classSimTK_1_1Row.html#a4183feaa6c23b9eeb533bb874542a450">updCastAwayNegatorIfAny</a>()    {<span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span>TWithoutNegator*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);}
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 
<a name="l00504"></a>00504     <span class="comment">// These are elementwise binary operators, (this op ee) by default but </span>
<a name="l00505"></a>00505     <span class="comment">// (ee op this) if &#39;FromLeft&#39; appears in the name. The result is a packed </span>
<a name="l00506"></a>00506     <span class="comment">// Row&lt;N&gt; but the element type may change. These are mostly used to </span>
<a name="l00507"></a>00507     <span class="comment">// implement global operators. We call these &quot;scalar&quot; operators but </span>
<a name="l00508"></a>00508     <span class="comment">// actually the &quot;scalar&quot; can be a composite type.</span>
<a name="l00509"></a>00509 
<a name="l00510"></a>00510     <span class="comment">//TODO: consider converting &#39;e&#39; to Standard Numbers as precalculation and </span>
<a name="l00511"></a>00511     <span class="comment">// changing return type appropriately.</span>
<a name="l00512"></a>00512     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Mul&gt;
<a name="l00513"></a><a class="code" href="classSimTK_1_1Row.html#a06c57e3726f1664965eb045dc911c57d">00513</a>     <a class="code" href="classSimTK_1_1Row.html#a06c57e3726f1664965eb045dc911c57d">scalarMultiply</a>(<span class="keyword">const</span> EE&amp; e)<span class="keyword"> const </span>{
<a name="l00514"></a>00514         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Mul&gt; result;
<a name="l00515"></a>00515         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) result[j] = (*<span class="keyword">this</span>)[j] * e;
<a name="l00516"></a>00516         <span class="keywordflow">return</span> result;
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;EE&gt;::template</a> Result&lt;E&gt;::Mul&gt;
<a name="l00519"></a><a class="code" href="classSimTK_1_1Row.html#aee4cd057f74883c3cbafac1a1131fc11">00519</a>     <a class="code" href="classSimTK_1_1Row.html#aee4cd057f74883c3cbafac1a1131fc11">scalarMultiplyFromLeft</a>(<span class="keyword">const</span> EE&amp; e)<span class="keyword"> const </span>{
<a name="l00520"></a>00520         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;EE&gt;::template</a> Result&lt;E&gt;::Mul&gt; result;
<a name="l00521"></a>00521         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) result[j] = e * (*<span class="keyword">this</span>)[j];
<a name="l00522"></a>00522         <span class="keywordflow">return</span> result;
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525     <span class="comment">// TODO: should precalculate and store 1/e, while converting to Standard </span>
<a name="l00526"></a>00526     <span class="comment">// Numbers. Note that return type should change appropriately.</span>
<a name="l00527"></a>00527     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Dvd&gt;
<a name="l00528"></a><a class="code" href="classSimTK_1_1Row.html#ab6a12247ba68c2358fb5ef23d4b0a2a5">00528</a>     <a class="code" href="classSimTK_1_1Row.html#ab6a12247ba68c2358fb5ef23d4b0a2a5">scalarDivide</a>(<span class="keyword">const</span> EE&amp; e)<span class="keyword"> const </span>{
<a name="l00529"></a>00529         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Dvd&gt; result;
<a name="l00530"></a>00530         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) result[j] = (*<span class="keyword">this</span>)[j] / e;
<a name="l00531"></a>00531         <span class="keywordflow">return</span> result;
<a name="l00532"></a>00532     }
<a name="l00533"></a>00533     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;EE&gt;::template</a> Result&lt;E&gt;::Dvd&gt;
<a name="l00534"></a><a class="code" href="classSimTK_1_1Row.html#a09752620b858951202bfb75d3bdc6ad5">00534</a>     <a class="code" href="classSimTK_1_1Row.html#a09752620b858951202bfb75d3bdc6ad5">scalarDivideFromLeft</a>(<span class="keyword">const</span> EE&amp; e)<span class="keyword"> const </span>{
<a name="l00535"></a>00535         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;EE&gt;::template</a> Result&lt;E&gt;::Dvd&gt; result;
<a name="l00536"></a>00536         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) result[j] = e / (*<span class="keyword">this</span>)[j];
<a name="l00537"></a>00537         <span class="keywordflow">return</span> result;
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Add&gt;
<a name="l00541"></a><a class="code" href="classSimTK_1_1Row.html#af0328ff475537e44c72b117803eb5bd5">00541</a>     <a class="code" href="classSimTK_1_1Row.html#af0328ff475537e44c72b117803eb5bd5">scalarAdd</a>(<span class="keyword">const</span> EE&amp; e)<span class="keyword"> const </span>{
<a name="l00542"></a>00542         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Add&gt; result;
<a name="l00543"></a>00543         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) result[j] = (*<span class="keyword">this</span>)[j] + e;
<a name="l00544"></a>00544         <span class="keywordflow">return</span> result;
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546     <span class="comment">// Add is commutative, so no &#39;FromLeft&#39;.</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Sub&gt;
<a name="l00549"></a><a class="code" href="classSimTK_1_1Row.html#af905bb23f1fcb7b5321ea8e0d1e564f8">00549</a>     <a class="code" href="classSimTK_1_1Row.html#af905bb23f1fcb7b5321ea8e0d1e564f8">scalarSubtract</a>(<span class="keyword">const</span> EE&amp; e)<span class="keyword"> const </span>{
<a name="l00550"></a>00550         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;E&gt;::template</a> Result&lt;EE&gt;::Sub&gt; result;
<a name="l00551"></a>00551         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) result[j] = (*<span class="keyword">this</span>)[j] - e;
<a name="l00552"></a>00552         <span class="keywordflow">return</span> result;
<a name="l00553"></a>00553     }
<a name="l00554"></a>00554     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;EE&gt;::template</a> Result&lt;E&gt;::Sub&gt;
<a name="l00555"></a><a class="code" href="classSimTK_1_1Row.html#a96ebf68ce3c49290a718c036a1eaee5b">00555</a>     <a class="code" href="classSimTK_1_1Row.html#a96ebf68ce3c49290a718c036a1eaee5b">scalarSubtractFromLeft</a>(<span class="keyword">const</span> EE&amp; e)<span class="keyword"> const </span>{
<a name="l00556"></a>00556         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N, typename CNT&lt;EE&gt;::template</a> Result&lt;E&gt;::Sub&gt; result;
<a name="l00557"></a>00557         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) result[j] = e - (*<span class="keyword">this</span>)[j];
<a name="l00558"></a>00558         <span class="keywordflow">return</span> result;
<a name="l00559"></a>00559     }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="comment">// Generic assignments for any element type not listed explicitly, including scalars.</span>
<a name="l00562"></a>00562     <span class="comment">// These are done repeatedly for each element and only work if the operation can</span>
<a name="l00563"></a>00563     <span class="comment">// be performed leaving the original element type.</span>
<a name="l00564"></a><a class="code" href="classSimTK_1_1Row.html#ad68f4c2f2c79266dd6607332b7cf7a3d">00564</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#aeb77180daa8675e0f1ec5c531685edc3">operator =</a>(<span class="keyword">const</span> EE&amp; e) {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#ad5d49ebdabe7463dd688b99dd79bc22f">scalarEq</a>(e);}
<a name="l00565"></a><a class="code" href="classSimTK_1_1Row.html#a12ee9b87c94ab674aebbb87f1a292a44">00565</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a12ee9b87c94ab674aebbb87f1a292a44">operator+=</a>(<span class="keyword">const</span> EE&amp; e) {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#aefd64bd552ab93c53f529871d6e3f361">scalarPlusEq</a>(e);}
<a name="l00566"></a><a class="code" href="classSimTK_1_1Row.html#a6cdad643735cb1d42b9b7e81339d6137">00566</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a6cdad643735cb1d42b9b7e81339d6137">operator-=</a>(<span class="keyword">const</span> EE&amp; e) {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a69b0cb66c03a79b9036f4c4e319e7277">scalarMinusEq</a>(e);}
<a name="l00567"></a><a class="code" href="classSimTK_1_1Row.html#ab7c23d14ed348c5b86c48c9f1de2fe0b">00567</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#ab7c23d14ed348c5b86c48c9f1de2fe0b">operator*=</a>(<span class="keyword">const</span> EE&amp; e) {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a43ea1cb855e0956c357dd6161fd271c5">scalarTimesEq</a>(e);}
<a name="l00568"></a><a class="code" href="classSimTK_1_1Row.html#a0ba8fc2a7b3653b4adfe42e24fede3cd">00568</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a0ba8fc2a7b3653b4adfe42e24fede3cd">operator/=</a>(<span class="keyword">const</span> EE&amp; e) {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a202c275b4f9cd73415e2b379a40d4e52">scalarDivideEq</a>(e);}
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     <span class="comment">// Generalized scalar assignment &amp; computed assignment methods. These will work</span>
<a name="l00571"></a>00571     <span class="comment">// for any assignment-compatible element, not just scalars.</span>
<a name="l00572"></a><a class="code" href="classSimTK_1_1Row.html#ad5d49ebdabe7463dd688b99dd79bc22f">00572</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#ad5d49ebdabe7463dd688b99dd79bc22f">scalarEq</a>(<span class="keyword">const</span> EE&amp; ee)
<a name="l00573"></a>00573       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] = ee; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00574"></a><a class="code" href="classSimTK_1_1Row.html#aefd64bd552ab93c53f529871d6e3f361">00574</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#aefd64bd552ab93c53f529871d6e3f361">scalarPlusEq</a>(<span class="keyword">const</span> EE&amp; ee)
<a name="l00575"></a>00575       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] += ee; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00576"></a><a class="code" href="classSimTK_1_1Row.html#a69b0cb66c03a79b9036f4c4e319e7277">00576</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a69b0cb66c03a79b9036f4c4e319e7277">scalarMinusEq</a>(<span class="keyword">const</span> EE&amp; ee)
<a name="l00577"></a>00577       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] -= ee; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00578"></a><a class="code" href="classSimTK_1_1Row.html#a382a55f5caaee8df5d1af27bc3c96335">00578</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a382a55f5caaee8df5d1af27bc3c96335">scalarMinusEqFromLeft</a>(<span class="keyword">const</span> EE&amp; ee)
<a name="l00579"></a>00579       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] = ee - d[i*STRIDE]; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00580"></a><a class="code" href="classSimTK_1_1Row.html#a43ea1cb855e0956c357dd6161fd271c5">00580</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a43ea1cb855e0956c357dd6161fd271c5">scalarTimesEq</a>(<span class="keyword">const</span> EE&amp; ee)
<a name="l00581"></a>00581       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] *= ee; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00582"></a><a class="code" href="classSimTK_1_1Row.html#acc337e72df80eb29312a9692afb0d87b">00582</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#acc337e72df80eb29312a9692afb0d87b">scalarTimesEqFromLeft</a>(<span class="keyword">const</span> EE&amp; ee)
<a name="l00583"></a>00583       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] = ee * d[i*STRIDE]; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00584"></a><a class="code" href="classSimTK_1_1Row.html#a202c275b4f9cd73415e2b379a40d4e52">00584</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a202c275b4f9cd73415e2b379a40d4e52">scalarDivideEq</a>(<span class="keyword">const</span> EE&amp; ee)
<a name="l00585"></a>00585       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] /= ee; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00586"></a><a class="code" href="classSimTK_1_1Row.html#af8b50e6d3ab0c702ca8ce864ec3e8b57">00586</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#af8b50e6d3ab0c702ca8ce864ec3e8b57">scalarDivideEqFromLeft</a>(<span class="keyword">const</span> EE&amp; ee)
<a name="l00587"></a>00587       { <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i) d[i*STRIDE] = ee / d[i*STRIDE]; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     <span class="comment">// Specialize for int to avoid warnings and ambiguities.</span>
<a name="l00591"></a><a class="code" href="classSimTK_1_1Row.html#adbea104d70e957de7b91ae670943d4a0">00591</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#adbea104d70e957de7b91ae670943d4a0">scalarEq</a>(<span class="keywordtype">int</span> ee)       {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#adbea104d70e957de7b91ae670943d4a0">scalarEq</a>(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(ee));}
<a name="l00592"></a><a class="code" href="classSimTK_1_1Row.html#a9984d92bf491d15f2b092307a4a5688b">00592</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a9984d92bf491d15f2b092307a4a5688b">scalarPlusEq</a>(<span class="keywordtype">int</span> ee)   {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a9984d92bf491d15f2b092307a4a5688b">scalarPlusEq</a>(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(ee));}
<a name="l00593"></a><a class="code" href="classSimTK_1_1Row.html#ac0df249c8c32debdf3b62623843c616c">00593</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#ac0df249c8c32debdf3b62623843c616c">scalarMinusEq</a>(<span class="keywordtype">int</span> ee)  {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#ac0df249c8c32debdf3b62623843c616c">scalarMinusEq</a>(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(ee));}
<a name="l00594"></a><a class="code" href="classSimTK_1_1Row.html#a18be0df0506647d9fdf77207bb85d947">00594</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a18be0df0506647d9fdf77207bb85d947">scalarTimesEq</a>(<span class="keywordtype">int</span> ee)  {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a18be0df0506647d9fdf77207bb85d947">scalarTimesEq</a>(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(ee));}
<a name="l00595"></a><a class="code" href="classSimTK_1_1Row.html#afff1a243f855f25814128670e5754eeb">00595</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#afff1a243f855f25814128670e5754eeb">scalarDivideEq</a>(<span class="keywordtype">int</span> ee) {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#afff1a243f855f25814128670e5754eeb">scalarDivideEq</a>(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(ee));}
<a name="l00596"></a><a class="code" href="classSimTK_1_1Row.html#a569a1be7777e582e8e47414553e4c075">00596</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a569a1be7777e582e8e47414553e4c075">scalarMinusEqFromLeft</a>(<span class="keywordtype">int</span> ee)  {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a569a1be7777e582e8e47414553e4c075">scalarMinusEqFromLeft</a>(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(ee));}
<a name="l00597"></a><a class="code" href="classSimTK_1_1Row.html#a02cd347fd1d33e2d9d9eaf74b804c934">00597</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a02cd347fd1d33e2d9d9eaf74b804c934">scalarTimesEqFromLeft</a>(<span class="keywordtype">int</span> ee)  {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a02cd347fd1d33e2d9d9eaf74b804c934">scalarTimesEqFromLeft</a>(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(ee));}
<a name="l00598"></a><a class="code" href="classSimTK_1_1Row.html#a77bae9f197d1814b9dc5267911664a81">00598</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a77bae9f197d1814b9dc5267911664a81">scalarDivideEqFromLeft</a>(<span class="keywordtype">int</span> ee) {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a77bae9f197d1814b9dc5267911664a81">scalarDivideEqFromLeft</a>(<a class="code" href="classSimTK_1_1Row.html#a86b74c6ef7c1672c8c782f2e5646a5b8">Precision</a>(ee));}
<a name="l00599"></a>00599 
<a name="l00602"></a><a class="code" href="classSimTK_1_1Row.html#a2c76e2c75a2d812201c1196aed1b8e3f">00602</a>     <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Row.html#a2c76e2c75a2d812201c1196aed1b8e3f" title="Set every scalar in this Row to NaN; this is the default initial value in Debug builds, but not in Release.">setToNaN</a>() {
<a name="l00603"></a>00603         (*this) = <a class="code" href="classSimTK_1_1Row.html#aeeccc0cd19a42270c07553c5c43d3672" title="Return a Row of the same length and element type as this one but with all elements set to NaN...">CNT&lt;ELT&gt;::getNaN</a>();
<a name="l00604"></a>00604     }
<a name="l00605"></a>00605 
<a name="l00607"></a><a class="code" href="classSimTK_1_1Row.html#ae193c35129f62780db762d8c3dfacd15">00607</a>     <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Row.html#ae193c35129f62780db762d8c3dfacd15" title="Set every scalar in this Row to zero.">setToZero</a>() {
<a name="l00608"></a>00608         (*this) = ELT(0);
<a name="l00609"></a>00609     }
<a name="l00610"></a>00610 
<a name="l00616"></a>00616     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NN&gt;
<a name="l00617"></a><a class="code" href="classSimTK_1_1Row.html#aca23485f22539355841c291af146f294">00617</a>     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;NN,ELT,STRIDE&gt;</a>&amp; <a class="code" href="classSimTK_1_1Row.html#aca23485f22539355841c291af146f294" title="Extract a const reference to a sub-Row with size known at compile time.">getSubRow</a>(<span class="keywordtype">int</span> j)<span class="keyword"> const </span>{
<a name="l00618"></a>00618         assert(0 &lt;= j &amp;&amp; j + NN &lt;= N);
<a name="l00619"></a>00619         <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a8de150627d9e937f2e95193988352b44" title="Recast an ordinary C++ array E[] to a const Row&lt;N,E,S&gt;; assumes compatible length, stride, and packing.">Row&lt;NN,ELT,STRIDE&gt;::getAs</a>(&amp;(*<span class="keyword">this</span>)[j]);
<a name="l00620"></a>00620     }
<a name="l00626"></a>00626     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NN&gt;
<a name="l00627"></a><a class="code" href="classSimTK_1_1Row.html#aa8c75c11abe5cc965884250ad0754ee5">00627</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;NN,ELT,STRIDE&gt;</a>&amp; <a class="code" href="classSimTK_1_1Row.html#aa8c75c11abe5cc965884250ad0754ee5" title="Extract a writable reference to a sub-Row with size known at compile time.">updSubRow</a>(<span class="keywordtype">int</span> j) {
<a name="l00628"></a>00628         assert(0 &lt;= j &amp;&amp; j + NN &lt;= N);
<a name="l00629"></a>00629         <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a39a3bc4071152d0f6ce97414067e2219" title="Recast a writable ordinary C++ array E[] to a writable Row&lt;N,E,S&gt;; assumes compatible length...">Row&lt;NN,ELT,STRIDE&gt;::updAs</a>(&amp;(*<span class="keyword">this</span>)[j]);
<a name="l00630"></a>00630     }
<a name="l00631"></a>00631 
<a name="l00635"></a>00635     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NN&gt;
<a name="l00636"></a><a class="code" href="classSimTK_1_1Row.html#a018c7d4919ebcbce2e25f816922d0e0b">00636</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a018c7d4919ebcbce2e25f816922d0e0b" title="Extract a subvector of type Row from a longer one that has the same element type and stride...">getSubRow</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;NN,ELT,STRIDE&gt;</a>&amp; r, <span class="keywordtype">int</span> j) {
<a name="l00637"></a>00637         assert(0 &lt;= j &amp;&amp; j + N &lt;= NN);
<a name="l00638"></a>00638         <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a8de150627d9e937f2e95193988352b44" title="Recast an ordinary C++ array E[] to a const Row&lt;N,E,S&gt;; assumes compatible length, stride, and packing.">getAs</a>(&amp;r[j]);
<a name="l00639"></a>00639     }
<a name="l00643"></a>00643     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NN&gt;
<a name="l00644"></a><a class="code" href="classSimTK_1_1Row.html#abf8479ccb33bb62ca185bc577ba1852c">00644</a>     <span class="keyword">static</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#abf8479ccb33bb62ca185bc577ba1852c" title="Extract a subvector of type Row from a longer one that has the same element type and stride...">updSubRow</a>(<a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;NN,ELT,STRIDE&gt;</a>&amp; r, <span class="keywordtype">int</span> j) {
<a name="l00645"></a>00645         assert(0 &lt;= j &amp;&amp; j + N &lt;= NN);
<a name="l00646"></a>00646         <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a39a3bc4071152d0f6ce97414067e2219" title="Recast a writable ordinary C++ array E[] to a writable Row&lt;N,E,S&gt;; assumes compatible length...">updAs</a>(&amp;r[j]);
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648 
<a name="l00652"></a><a class="code" href="classSimTK_1_1Row.html#abd3211fd0d508ff9635dc1de40512d8e">00652</a>     <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,ELT,1&gt; <a class="code" href="classSimTK_1_1Row.html#abd3211fd0d508ff9635dc1de40512d8e" title="Return a row one smaller than this one by dropping the element at the indicated position p...">drop1</a>(<span class="keywordtype">int</span> p)<span class="keyword"> const </span>{
<a name="l00653"></a>00653         assert(0 &lt;= p &amp;&amp; p &lt; N);
<a name="l00654"></a>00654         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&lt;N-1,ELT,1&gt; out;
<a name="l00655"></a>00655         <span class="keywordtype">int</span> nxt=0;
<a name="l00656"></a>00656         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;N-1; ++i, ++nxt) {
<a name="l00657"></a>00657             <span class="keywordflow">if</span> (nxt==p) ++nxt;  <span class="comment">// skip the loser</span>
<a name="l00658"></a>00658             out[i] = (*this)[nxt];
<a name="l00659"></a>00659         }
<a name="l00660"></a>00660         <span class="keywordflow">return</span> out;
<a name="l00661"></a>00661     }
<a name="l00662"></a>00662 
<a name="l00666"></a><a class="code" href="classSimTK_1_1Row.html#a589550e2f33f164ebfbd8a7b2ecc9b30">00666</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N+1,ELT,1&gt;</a> <a class="code" href="classSimTK_1_1Row.html#a589550e2f33f164ebfbd8a7b2ecc9b30" title="Return a row one larger than this one by adding an element to the end.">append1</a>(<span class="keyword">const</span> EE&amp; v)<span class="keyword"> const </span>{
<a name="l00667"></a>00667         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N+1,ELT,1&gt;</a> out;
<a name="l00668"></a>00668         <a class="code" href="classSimTK_1_1Row.html#a39a3bc4071152d0f6ce97414067e2219" title="Recast a writable ordinary C++ array E[] to a writable Row&lt;N,E,S&gt;; assumes compatible length...">Row&lt;N,ELT,1&gt;::updAs</a>(&amp;out[0]) = (*this);
<a name="l00669"></a>00669         out[N] = v;
<a name="l00670"></a>00670         <span class="keywordflow">return</span> out;
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 
<a name="l00679"></a><a class="code" href="classSimTK_1_1Row.html#ae62ae1d6f4f2e37e0519b9e9d48f1773">00679</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> EE&gt; <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N+1,ELT,1&gt;</a> <a class="code" href="classSimTK_1_1Row.html#ae62ae1d6f4f2e37e0519b9e9d48f1773" title="Return a row one larger than this one by inserting an element before the indicated one...">insert1</a>(<span class="keywordtype">int</span> p, <span class="keyword">const</span> EE&amp; v)<span class="keyword"> const </span>{
<a name="l00680"></a>00680         assert(0 &lt;= p &amp;&amp; p &lt;= N);
<a name="l00681"></a>00681         <span class="keywordflow">if</span> (p==N) <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a589550e2f33f164ebfbd8a7b2ecc9b30" title="Return a row one larger than this one by adding an element to the end.">append1</a>(v);
<a name="l00682"></a>00682         <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N+1,ELT,1&gt;</a> out;
<a name="l00683"></a>00683         <span class="keywordtype">int</span> nxt=0;
<a name="l00684"></a>00684         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;N; ++i, ++nxt) {
<a name="l00685"></a>00685             <span class="keywordflow">if</span> (i==p) out[nxt++] = v;
<a name="l00686"></a>00686             out[nxt] = (*this)[i];
<a name="l00687"></a>00687         }
<a name="l00688"></a>00688         <span class="keywordflow">return</span> out;
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690 
<a name="l00693"></a><a class="code" href="classSimTK_1_1Row.html#a8de150627d9e937f2e95193988352b44">00693</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp; <a class="code" href="classSimTK_1_1Row.html#a8de150627d9e937f2e95193988352b44" title="Recast an ordinary C++ array E[] to a const Row&lt;N,E,S&gt;; assumes compatible length, stride, and packing.">getAs</a>(<span class="keyword">const</span> ELT* p)  {<span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>*<span class="keyword">&gt;</span>(p);}
<a name="l00696"></a><a class="code" href="classSimTK_1_1Row.html#a39a3bc4071152d0f6ce97414067e2219">00696</a>     <span class="keyword">static</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>&amp;       <a class="code" href="classSimTK_1_1Row.html#a39a3bc4071152d0f6ce97414067e2219" title="Recast a writable ordinary C++ array E[] to a writable Row&lt;N,E,S&gt;; assumes compatible length...">updAs</a>(ELT* p)        {<span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a>*<span class="keyword">&gt;</span>(p);}
<a name="l00697"></a>00697 
<a name="l00701"></a><a class="code" href="classSimTK_1_1Row.html#aeeccc0cd19a42270c07553c5c43d3672">00701</a>     <span class="keyword">static</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,ELT,1&gt;</a> <a class="code" href="classSimTK_1_1Row.html#aeeccc0cd19a42270c07553c5c43d3672" title="Return a Row of the same length and element type as this one but with all elements set to NaN...">getNaN</a>() { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,ELT,1&gt;</a>(<a class="code" href="classSimTK_1_1Row.html#aeeccc0cd19a42270c07553c5c43d3672" title="Return a Row of the same length and element type as this one but with all elements set to NaN...">CNT&lt;ELT&gt;::getNaN</a>()); }
<a name="l00702"></a>00702 
<a name="l00704"></a><a class="code" href="classSimTK_1_1Row.html#a87ab6798ed19901a5a6226475211e236">00704</a>     <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Row.html#a87ab6798ed19901a5a6226475211e236" title="Return true if any element of this Row contains a NaN anywhere.">isNaN</a>()<span class="keyword"> const </span>{
<a name="l00705"></a>00705         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j)
<a name="l00706"></a>00706             <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;ELT&gt;::isNaN</a>((*<span class="keyword">this</span>)[j]))
<a name="l00707"></a>00707                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00708"></a>00708         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00709"></a>00709     }
<a name="l00710"></a>00710 
<a name="l00713"></a><a class="code" href="classSimTK_1_1Row.html#a5edfdc933fdef688b868771838327008">00713</a>     <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Row.html#a5edfdc933fdef688b868771838327008" title="Return true if any element of this Row contains a +Infinity or -Infinity somewhere but no element con...">isInf</a>()<span class="keyword"> const </span>{
<a name="l00714"></a>00714         <span class="keywordtype">bool</span> seenInf = <span class="keyword">false</span>;
<a name="l00715"></a>00715         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j) {
<a name="l00716"></a>00716             <span class="keyword">const</span> ELT&amp; e = (*this)[j];
<a name="l00717"></a>00717             <span class="keywordflow">if</span> (!<a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;ELT&gt;::isFinite</a>(e)) {
<a name="l00718"></a>00718                 <span class="keywordflow">if</span> (!<a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;ELT&gt;::isInf</a>(e)) 
<a name="l00719"></a>00719                     <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// something bad was found</span>
<a name="l00720"></a>00720                 seenInf = <span class="keyword">true</span>; 
<a name="l00721"></a>00721             }
<a name="l00722"></a>00722         }
<a name="l00723"></a>00723         <span class="keywordflow">return</span> seenInf;
<a name="l00724"></a>00724     }
<a name="l00725"></a>00725 
<a name="l00728"></a><a class="code" href="classSimTK_1_1Row.html#a700cab1af300c3a25d2e01be6c16be50">00728</a>     <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Row.html#a700cab1af300c3a25d2e01be6c16be50" title="Return true if no element of this Row contains an Infinity or a NaN anywhere.">isFinite</a>()<span class="keyword"> const </span>{
<a name="l00729"></a>00729         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j)
<a name="l00730"></a>00730             <span class="keywordflow">if</span> (!<a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;ELT&gt;::isFinite</a>((*<span class="keyword">this</span>)[j]))
<a name="l00731"></a>00731                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00732"></a>00732         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734 
<a name="l00737"></a><a class="code" href="classSimTK_1_1Row.html#aa4b4b0e4a4d953ddbe83d252a7764b8b">00737</a>     <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="classSimTK_1_1Row.html#aa4b4b0e4a4d953ddbe83d252a7764b8b" title="For approximate comparisions, the default tolerance to use for a vector is the same as its elements&#39; ...">getDefaultTolerance</a>() {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#aa4b4b0e4a4d953ddbe83d252a7764b8b" title="For approximate comparisions, the default tolerance to use for a vector is the same as its elements&#39; ...">CNT&lt;ELT&gt;::getDefaultTolerance</a>();}
<a name="l00738"></a>00738 
<a name="l00741"></a>00741     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E2, <span class="keywordtype">int</span> CS2&gt;
<a name="l00742"></a><a class="code" href="classSimTK_1_1Row.html#a356ac55d00076f1aa6a6108d999e1f36">00742</a>     <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Row.html#a356ac55d00076f1aa6a6108d999e1f36" title="Test whether this row is numerically equal to some other row with the same shape, using a specified t...">isNumericallyEqual</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,CS2&gt;</a>&amp; r, <span class="keywordtype">double</span> tol)<span class="keyword"> const </span>{
<a name="l00743"></a>00743         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j)
<a name="l00744"></a>00744             <span class="keywordflow">if</span> (!<a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;ELT&gt;::isNumericallyEqual</a>((*<span class="keyword">this</span>)(j), r(j), tol))
<a name="l00745"></a>00745                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00746"></a>00746         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00747"></a>00747     }
<a name="l00748"></a>00748 
<a name="l00752"></a>00752     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E2, <span class="keywordtype">int</span> CS2&gt;
<a name="l00753"></a><a class="code" href="classSimTK_1_1Row.html#aaaa7839abb9034b42154fc7daeef10ef">00753</a>     <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Row.html#aaaa7839abb9034b42154fc7daeef10ef" title="Test whether this row vector is numerically equal to some other row with the same shape...">isNumericallyEqual</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,CS2&gt;</a>&amp; r)<span class="keyword"> const </span>{
<a name="l00754"></a>00754         <span class="keyword">const</span> <span class="keywordtype">double</span> tol = <a class="code" href="namespaceSimTK.html#a5e54f17d86aeb08126d641bea4ba6f86">std::max</a>(<a class="code" href="classSimTK_1_1Row.html#aa4b4b0e4a4d953ddbe83d252a7764b8b" title="For approximate comparisions, the default tolerance to use for a vector is the same as its elements&#39; ...">getDefaultTolerance</a>(),r.<a class="code" href="classSimTK_1_1Row.html#aa4b4b0e4a4d953ddbe83d252a7764b8b" title="For approximate comparisions, the default tolerance to use for a vector is the same as its elements&#39; ...">getDefaultTolerance</a>());
<a name="l00755"></a>00755         <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html#a356ac55d00076f1aa6a6108d999e1f36" title="Test whether this row is numerically equal to some other row with the same shape, using a specified t...">isNumericallyEqual</a>(r, tol);
<a name="l00756"></a>00756     }
<a name="l00757"></a>00757 
<a name="l00762"></a>00762     <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Row.html#a356ac55d00076f1aa6a6108d999e1f36" title="Test whether this row is numerically equal to some other row with the same shape, using a specified t...">isNumericallyEqual</a>
<a name="l00763"></a><a class="code" href="classSimTK_1_1Row.html#abaa3a4a475989f17aa6e3f9f556d8b29">00763</a>        (<span class="keyword">const</span> ELT&amp; e,
<a name="l00764"></a>00764         <span class="keywordtype">double</span>     tol = <a class="code" href="classSimTK_1_1Row.html#aa4b4b0e4a4d953ddbe83d252a7764b8b" title="For approximate comparisions, the default tolerance to use for a vector is the same as its elements&#39; ...">getDefaultTolerance</a>()) <span class="keyword">const</span> 
<a name="l00765"></a>00765     {
<a name="l00766"></a>00766         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;N; ++j)
<a name="l00767"></a>00767             <span class="keywordflow">if</span> (!<a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;ELT&gt;::isNumericallyEqual</a>((*<span class="keyword">this</span>)(j), e, tol))
<a name="l00768"></a>00768                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00769"></a>00769         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00770"></a>00770     }
<a name="l00771"></a>00771 <span class="keyword">private</span>:
<a name="l00772"></a>00772     ELT d[<a class="code" href="classSimTK_1_1Row.html#ade39afd15eedd990b0bb8aef4493a69da3ae362555ddcef1b099b54404cda495f">NActualElements</a>];    <span class="comment">// data</span>
<a name="l00773"></a>00773 };
<a name="l00774"></a>00774 
<a name="l00776"></a>00776 <span class="comment">// Global operators involving two rows.    //</span>
<a name="l00777"></a>00777 <span class="comment">//   v+v, v-v, v==v, v!=v                  //</span>
<a name="l00779"></a>00779 <span class="comment"></span>
<a name="l00780"></a>00780 <span class="comment">// v3 = v1 + v2 where all v&#39;s have the same length N. </span>
<a name="l00781"></a>00781 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keyword">inline</span>
<a name="l00782"></a>00782 <span class="keyword">typename</span> Row&lt;N,E1,S1&gt;::template Result&lt; Row&lt;N,E2,S2&gt; &gt;::Add
<a name="l00783"></a><a class="code" href="namespaceSimTK.html#a3b8d70e3fd4dce576e27b084dadcac75">00783</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r) { 
<a name="l00784"></a>00784     <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;::template</a> Result&lt; Row&lt;N,E2,S2&gt; &gt;
<a name="l00785"></a>00785         ::AddOp::perform(l,r);
<a name="l00786"></a>00786 }
<a name="l00787"></a>00787 
<a name="l00788"></a>00788 <span class="comment">// v3 = v1 - v2, similar to +</span>
<a name="l00789"></a>00789 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keyword">inline</span>
<a name="l00790"></a>00790 <span class="keyword">typename</span> Row&lt;N,E1,S1&gt;::template Result&lt; Row&lt;N,E2,S2&gt; &gt;::Sub
<a name="l00791"></a><a class="code" href="namespaceSimTK.html#a836ea4532666631d900934828257d929">00791</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r) { 
<a name="l00792"></a>00792     <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;::template</a> Result&lt; Row&lt;N,E2,S2&gt; &gt;
<a name="l00793"></a>00793         ::SubOp::perform(l,r);
<a name="l00794"></a>00794 }
<a name="l00795"></a>00795 
<a name="l00797"></a>00797 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00798"></a><a class="code" href="namespaceSimTK.html#ad82902fcb72a6d72cf360fccbc2fa856">00798</a> <a class="code" href="namespaceSimTK.html#ac56336ea74b71f07f371d943bd5cdba0">operator==</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r) { 
<a name="l00799"></a>00799     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) <span class="keywordflow">if</span> (l[i] != r[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00800"></a>00800     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00801"></a>00801 }
<a name="l00803"></a>00803 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00804"></a><a class="code" href="namespaceSimTK.html#a32aa8cbb38233718a76d6c1541fc70df">00804</a> <a class="code" href="namespaceSimTK.html#aac639daeeac2aca1f6b4e6d8da68488d">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r) {<span class="keywordflow">return</span> !(l==r);} 
<a name="l00805"></a>00805 
<a name="l00807"></a>00807 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00808"></a><a class="code" href="namespaceSimTK.html#a96e9ff9eafabbc9dce71d3965fb44a85">00808</a> operator&lt;(const Row&lt;N,E1,S1&gt;&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r) 
<a name="l00809"></a>00809 {   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) if (l[i] &gt;= r[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00810"></a>00810     <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00812"></a>00812 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00813"></a><a class="code" href="namespaceSimTK.html#ad13f9ebbf2b7be19f7e2ab826c1ce758">00813</a> operator&lt;(const Row&lt;N,E1,S1&gt;&amp; v, <span class="keyword">const</span> E2&amp; e) 
<a name="l00814"></a>00814 {   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) if (v[i] &gt;= e) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00815"></a>00815     <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00816"></a>00816 
<a name="l00818"></a>00818 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00819"></a><a class="code" href="namespaceSimTK.html#a5ccd5a2794e529c57597ff59419e3b8d">00819</a> <a class="code" href="namespaceSimTK.html#a5ccd5a2794e529c57597ff59419e3b8d" title="bool = v1[i] &gt; v2[i], for all elements i">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r) 
<a name="l00820"></a>00820 {   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) <span class="keywordflow">if</span> (l[i] &lt;= r[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00821"></a>00821     <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00823"></a>00823 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00824"></a><a class="code" href="namespaceSimTK.html#a150dbf19974be4334beda5574505adb3">00824</a> <a class="code" href="namespaceSimTK.html#a5ccd5a2794e529c57597ff59419e3b8d" title="bool = v1[i] &gt; v2[i], for all elements i">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; v, <span class="keyword">const</span> E2&amp; e) 
<a name="l00825"></a>00825 {   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) <span class="keywordflow">if</span> (v[i] &lt;= e) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00826"></a>00826     <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00827"></a>00827 
<a name="l00830"></a>00830 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00831"></a><a class="code" href="namespaceSimTK.html#a34458ba652227f4e1c1f4d2d4cdfefe4">00831</a> operator&lt;=(const Row&lt;N,E1,S1&gt;&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r) 
<a name="l00832"></a>00832 {   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) if (l[i] &gt; r[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00833"></a>00833     <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00836"></a>00836 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00837"></a><a class="code" href="namespaceSimTK.html#a7742b13e6140d0ceb5fce8cb3ae60208">00837</a> operator&lt;=(const Row&lt;N,E1,S1&gt;&amp; v, <span class="keyword">const</span> E2&amp; e) 
<a name="l00838"></a>00838 {   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) if (v[i] &gt; e) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00839"></a>00839     <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00840"></a>00840 
<a name="l00843"></a>00843 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2, <span class="keywordtype">int</span> S2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00844"></a><a class="code" href="namespaceSimTK.html#aaaa7f3ecb83f7d1b95d91ee8e34d8f9f">00844</a> <a class="code" href="namespaceSimTK.html#aaaa7f3ecb83f7d1b95d91ee8e34d8f9f" title="bool = v1[i] &gt;= v2[i], for all elements i This is not the same as !(v1&lt;v2).">operator&gt;=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E2,S2&gt;</a>&amp; r) 
<a name="l00845"></a>00845 {   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) <span class="keywordflow">if</span> (l[i] &lt; r[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00846"></a>00846     <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00849"></a>00849 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E1, <span class="keywordtype">int</span> S1, <span class="keyword">class</span> E2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l00850"></a><a class="code" href="namespaceSimTK.html#a04199e5b03042b6b332697aa5e3c860c">00850</a> <a class="code" href="namespaceSimTK.html#aaaa7f3ecb83f7d1b95d91ee8e34d8f9f" title="bool = v1[i] &gt;= v2[i], for all elements i This is not the same as !(v1&lt;v2).">operator&gt;=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E1,S1&gt;</a>&amp; v, <span class="keyword">const</span> E2&amp; e) 
<a name="l00851"></a>00851 {   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) <span class="keywordflow">if</span> (v[i] &lt; e) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00852"></a>00852     <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00853"></a>00853 
<a name="l00855"></a>00855 <span class="comment">// Global operators involving a row and a scalar. //</span>
<a name="l00857"></a>00857 <span class="comment"></span>
<a name="l00858"></a>00858 <span class="comment">// I haven&#39;t been able to figure out a nice way to templatize for the</span>
<a name="l00859"></a>00859 <span class="comment">// built-in reals without introducing a lot of unwanted type matches</span>
<a name="l00860"></a>00860 <span class="comment">// as well. So we&#39;ll just grind them out explicitly here.</span>
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="comment">// SCALAR MULTIPLY</span>
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 <span class="comment">// v = v*real, real*v </span>
<a name="l00865"></a>00865 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00866"></a>00866 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;float&gt;::Mul
<a name="l00867"></a><a class="code" href="namespaceSimTK.html#af9b8113dcf8e4756451bc3b0d33c23de">00867</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; r)
<a name="l00868"></a>00868   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;float&gt;::MulOp::perform(l,r); }
<a name="l00869"></a>00869 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00870"></a>00870 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;float&gt;::Mul
<a name="l00871"></a><a class="code" href="namespaceSimTK.html#ad78d87f2237de19d1685e729a98e5ddd">00871</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r*l;}
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00874"></a>00874 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;double&gt;::Mul
<a name="l00875"></a><a class="code" href="namespaceSimTK.html#a80b4184bc7401ce4a5b202740d1bf860">00875</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; r)
<a name="l00876"></a>00876   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;double&gt;::MulOp::perform(l,r); }
<a name="l00877"></a>00877 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00878"></a>00878 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;double&gt;::Mul
<a name="l00879"></a><a class="code" href="namespaceSimTK.html#a2f8339d48b9818d94559c4cbb356c51c">00879</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r*l;}
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00882"></a>00882 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;long double&gt;::Mul
<a name="l00883"></a><a class="code" href="namespaceSimTK.html#a861242e8ca7fcb64c7849bfa46648ec2">00883</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span>&amp; r)
<a name="l00884"></a>00884   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;long double&gt;::MulOp::perform(l,r); }
<a name="l00885"></a>00885 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00886"></a>00886 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;long double&gt;::Mul
<a name="l00887"></a><a class="code" href="namespaceSimTK.html#ad978ff747450f3c0695c6d96023f7d67">00887</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r*l;}
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="comment">// v = v*int, int*v -- just convert int to v&#39;s precision float</span>
<a name="l00890"></a>00890 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00891"></a>00891 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename CNT&lt;E&gt;::Precision&gt;::Mul
<a name="l00892"></a><a class="code" href="namespaceSimTK.html#ad3ed619c454faa4f13e4a135aecffba7">00892</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keywordtype">int</span> r) {<span class="keywordflow">return</span> l * (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>)r;}
<a name="l00893"></a>00893 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00894"></a>00894 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename CNT&lt;E&gt;::Precision&gt;::Mul
<a name="l00895"></a><a class="code" href="namespaceSimTK.html#a02bfbbcc7a312d26763bfc5cbf87d3d0">00895</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keywordtype">int</span> l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r * (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>)l;}
<a name="l00896"></a>00896 
<a name="l00897"></a>00897 <span class="comment">// Complex, conjugate, and negator are all easy to templatize.</span>
<a name="l00898"></a>00898 
<a name="l00899"></a>00899 <span class="comment">// v = v*complex, complex*v</span>
<a name="l00900"></a>00900 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00901"></a>00901 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Mul
<a name="l00902"></a><a class="code" href="namespaceSimTK.html#a754ea9bc297db2fc62e74e29200718b4">00902</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> std::complex&lt;R&gt;&amp; r)
<a name="l00903"></a>00903   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;std::complex&lt;R&gt; &gt;::MulOp::perform(l,r); }
<a name="l00904"></a>00904 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00905"></a>00905 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Mul
<a name="l00906"></a><a class="code" href="namespaceSimTK.html#ade89aff78787f0d51edf4d78ec672716">00906</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> std::complex&lt;R&gt;&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r*l;}
<a name="l00907"></a>00907 
<a name="l00908"></a>00908 <span class="comment">// v = v*conjugate, conjugate*v (convert conjugate-&gt;complex)</span>
<a name="l00909"></a>00909 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00910"></a>00910 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Mul
<a name="l00911"></a><a class="code" href="namespaceSimTK.html#a78562c42712b1c2e942ca3f8c5bd14b0">00911</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1conjugate.html" title="SimTK::conjugate&lt;R&gt; should be instantiated only for float, double, long double.">conjugate&lt;R&gt;</a>&amp; r) {<span class="keywordflow">return</span> l*(std::complex&lt;R&gt;)r;}
<a name="l00912"></a>00912 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00913"></a>00913 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Mul
<a name="l00914"></a><a class="code" href="namespaceSimTK.html#af143a050cd20b48bf6f243ffd194af4d">00914</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1conjugate.html" title="SimTK::conjugate&lt;R&gt; should be instantiated only for float, double, long double.">conjugate&lt;R&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r*(std::complex&lt;R&gt;)l;}
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 <span class="comment">// v = v*negator, negator*v: convert negator to standard number</span>
<a name="l00917"></a>00917 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00918"></a>00918 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename negator&lt;R&gt;::StdNumber&gt;::Mul
<a name="l00919"></a><a class="code" href="namespaceSimTK.html#ad59e0788edb9919e556b5ff217462c5b">00919</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;R&gt;</a>&amp; r) {<span class="keywordflow">return</span> l * (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1negator.html#ae3b11033129d454a94ac9c8665dbd07e">negator&lt;R&gt;::StdNumber</a>)(R)r;}
<a name="l00920"></a>00920 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00921"></a>00921 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename negator&lt;R&gt;::StdNumber&gt;::Mul
<a name="l00922"></a><a class="code" href="namespaceSimTK.html#ae7ac41a3955533c21541dbe9f89e9a52">00922</a> <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;R&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r * (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1negator.html#ae3b11033129d454a94ac9c8665dbd07e">negator&lt;R&gt;::StdNumber</a>)(R)l;}
<a name="l00923"></a>00923 
<a name="l00924"></a>00924 
<a name="l00925"></a>00925 <span class="comment">// SCALAR DIVIDE. This is a scalar operation when the scalar is on the right,</span>
<a name="l00926"></a>00926 <span class="comment">// but when it is on the left it means scalar * pseudoInverse(row), which is </span>
<a name="l00927"></a>00927 <span class="comment">// a vec.</span>
<a name="l00928"></a>00928 
<a name="l00929"></a>00929 <span class="comment">// v = v/real, real/v </span>
<a name="l00930"></a>00930 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00931"></a>00931 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;float&gt;::Dvd
<a name="l00932"></a><a class="code" href="namespaceSimTK.html#a09d7eed2497e53dbc4a52db2d4f8b05c">00932</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; r)
<a name="l00933"></a>00933   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;float&gt;::DvdOp::perform(l,r); }
<a name="l00934"></a>00934 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00935"></a>00935 <span class="keyword">typename</span> CNT&lt;float&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Dvd
<a name="l00936"></a><a class="code" href="namespaceSimTK.html#ae98d2bf5e9c822b28f94a553338e9406">00936</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r)
<a name="l00937"></a>00937   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;float&gt;::template</a> Result&lt;Row&lt;N,E,S&gt; &gt;::DvdOp::perform(l,r); }
<a name="l00938"></a>00938 
<a name="l00939"></a>00939 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00940"></a>00940 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;double&gt;::Dvd
<a name="l00941"></a><a class="code" href="namespaceSimTK.html#a51485f2d86fd12ce01f7993563d82178">00941</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; r)
<a name="l00942"></a>00942   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;double&gt;::DvdOp::perform(l,r); }
<a name="l00943"></a>00943 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00944"></a>00944 <span class="keyword">typename</span> CNT&lt;double&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Dvd
<a name="l00945"></a><a class="code" href="namespaceSimTK.html#a7e781fc2e094093e38956bfccf578c91">00945</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r)
<a name="l00946"></a>00946   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;double&gt;::template</a> Result&lt;Row&lt;N,E,S&gt; &gt;::DvdOp::perform(l,r); }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00949"></a>00949 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;long double&gt;::Dvd
<a name="l00950"></a><a class="code" href="namespaceSimTK.html#a4695993f2589e251cbe4f94343454023">00950</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span>&amp; r)
<a name="l00951"></a>00951   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;long double&gt;::DvdOp::perform(l,r); }
<a name="l00952"></a>00952 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00953"></a>00953 <span class="keyword">typename</span> CNT&lt;long double&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Dvd
<a name="l00954"></a><a class="code" href="namespaceSimTK.html#a3be46003a22e45615bbf3cd99efafda2">00954</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r)
<a name="l00955"></a>00955   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;long double&gt;::template</a> Result&lt;Row&lt;N,E,S&gt; &gt;::DvdOp::perform(l,r); }
<a name="l00956"></a>00956 
<a name="l00957"></a>00957 <span class="comment">// v = v/int, int/v -- just convert int to v&#39;s precision float</span>
<a name="l00958"></a>00958 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00959"></a>00959 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename CNT&lt;E&gt;::Precision&gt;::Dvd
<a name="l00960"></a><a class="code" href="namespaceSimTK.html#a4fe5693451f5a90d285f5db01f948a00">00960</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keywordtype">int</span> r) {<span class="keywordflow">return</span> l / (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>)r;}
<a name="l00961"></a>00961 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l00962"></a>00962 <span class="keyword">typename</span> CNT&lt;typename CNT&lt;E&gt;::Precision&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Dvd
<a name="l00963"></a><a class="code" href="namespaceSimTK.html#aba7198f8ad4be387512286b6f282df96">00963</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keywordtype">int</span> l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>)l / r;}
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 
<a name="l00966"></a>00966 <span class="comment">// Complex, conjugate, and negator are all easy to templatize.</span>
<a name="l00967"></a>00967 
<a name="l00968"></a>00968 <span class="comment">// v = v/complex, complex/v</span>
<a name="l00969"></a>00969 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00970"></a>00970 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Dvd
<a name="l00971"></a><a class="code" href="namespaceSimTK.html#a2c71a64a8e448541e2528436f76a439b">00971</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> std::complex&lt;R&gt;&amp; r)
<a name="l00972"></a>00972   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;std::complex&lt;R&gt; &gt;::DvdOp::perform(l,r); }
<a name="l00973"></a>00973 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00974"></a>00974 <span class="keyword">typename</span> CNT&lt;std::complex&lt;R&gt; &gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Dvd
<a name="l00975"></a><a class="code" href="namespaceSimTK.html#a22ac0531922a53c3cd345e6d247a0eb6">00975</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> std::complex&lt;R&gt;&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r)
<a name="l00976"></a>00976   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;std::complex&lt;R&gt;</a> &gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::DvdOp::perform(l,r); }
<a name="l00977"></a>00977 
<a name="l00978"></a>00978 <span class="comment">// v = v/conjugate, conjugate/v (convert conjugate-&gt;complex)</span>
<a name="l00979"></a>00979 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00980"></a>00980 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Dvd
<a name="l00981"></a><a class="code" href="namespaceSimTK.html#ab8fec1dbf2cc174920ccc250c51d6a46">00981</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1conjugate.html" title="SimTK::conjugate&lt;R&gt; should be instantiated only for float, double, long double.">conjugate&lt;R&gt;</a>&amp; r) {<span class="keywordflow">return</span> l/(std::complex&lt;R&gt;)r;}
<a name="l00982"></a>00982 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00983"></a>00983 <span class="keyword">typename</span> CNT&lt;std::complex&lt;R&gt; &gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Dvd
<a name="l00984"></a><a class="code" href="namespaceSimTK.html#a07b11417259d032dbac219088eaa1d15">00984</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1conjugate.html" title="SimTK::conjugate&lt;R&gt; should be instantiated only for float, double, long double.">conjugate&lt;R&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> (std::complex&lt;R&gt;)l/r;}
<a name="l00985"></a>00985 
<a name="l00986"></a>00986 <span class="comment">// v = v/negator, negator/v: convert negator to number</span>
<a name="l00987"></a>00987 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00988"></a>00988 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename negator&lt;R&gt;::StdNumber&gt;::Dvd
<a name="l00989"></a><a class="code" href="namespaceSimTK.html#aa395297d2e2a02ffbc42ab73695b82fb">00989</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;R&gt;</a>&amp; r) {<span class="keywordflow">return</span> l/(<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1negator.html#ae3b11033129d454a94ac9c8665dbd07e">negator&lt;R&gt;::StdNumber</a>)(R)r;}
<a name="l00990"></a>00990 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l00991"></a>00991 <span class="keyword">typename</span> CNT&lt;R&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Dvd
<a name="l00992"></a><a class="code" href="namespaceSimTK.html#a12b1a77eeb93f6a35d1e4b67c03d6575">00992</a> <a class="code" href="namespaceSimTK.html#a289810e16cb099ab1e48a2ad94882077">operator/</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;R&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1negator.html#ae3b11033129d454a94ac9c8665dbd07e">negator&lt;R&gt;::StdNumber</a>)(R)l/r;}
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 
<a name="l00995"></a>00995 <span class="comment">// Add and subtract are odd as scalar ops. They behave as though the</span>
<a name="l00996"></a>00996 <span class="comment">// scalar stands for a vector each of whose elements is that scalar,</span>
<a name="l00997"></a>00997 <span class="comment">// and then a normal vector add or subtract is done.</span>
<a name="l00998"></a>00998 
<a name="l00999"></a>00999 <span class="comment">// SCALAR ADD</span>
<a name="l01000"></a>01000 
<a name="l01001"></a>01001 <span class="comment">// v = v+real, real+v </span>
<a name="l01002"></a>01002 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01003"></a>01003 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;float&gt;::Add
<a name="l01004"></a><a class="code" href="namespaceSimTK.html#a1dc420e8bfe8627acbc5f78913d5aedb">01004</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; r)
<a name="l01005"></a>01005   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;float&gt;::AddOp::perform(l,r); }
<a name="l01006"></a>01006 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01007"></a>01007 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;float&gt;::Add
<a name="l01008"></a><a class="code" href="namespaceSimTK.html#aec18564fcda86fed618473087c2e92d0">01008</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r+l;}
<a name="l01009"></a>01009 
<a name="l01010"></a>01010 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01011"></a>01011 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;double&gt;::Add
<a name="l01012"></a><a class="code" href="namespaceSimTK.html#a8fbbf7a462d2810846d34777a1788e93">01012</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; r)
<a name="l01013"></a>01013   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;double&gt;::AddOp::perform(l,r); }
<a name="l01014"></a>01014 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01015"></a>01015 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;double&gt;::Add
<a name="l01016"></a><a class="code" href="namespaceSimTK.html#a587ffbc20d7cd589c428e119ff4d9d65">01016</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r+l;}
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01019"></a>01019 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;long double&gt;::Add
<a name="l01020"></a><a class="code" href="namespaceSimTK.html#aa745ac182744fc8607b22acd528d2885">01020</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span>&amp; r)
<a name="l01021"></a>01021   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;long double&gt;::AddOp::perform(l,r); }
<a name="l01022"></a>01022 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01023"></a>01023 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;long double&gt;::Add
<a name="l01024"></a><a class="code" href="namespaceSimTK.html#afcdedd68a3e3417a61251df690823845">01024</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r+l;}
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 <span class="comment">// v = v+int, int+v -- just convert int to v&#39;s precision float</span>
<a name="l01027"></a>01027 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01028"></a>01028 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename CNT&lt;E&gt;::Precision&gt;::Add
<a name="l01029"></a><a class="code" href="namespaceSimTK.html#aa06f7226673d6ce6583d351e4ccda591">01029</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keywordtype">int</span> r) {<span class="keywordflow">return</span> l + (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>)r;}
<a name="l01030"></a>01030 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01031"></a>01031 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename CNT&lt;E&gt;::Precision&gt;::Add
<a name="l01032"></a><a class="code" href="namespaceSimTK.html#adea776d1367a244e0e50717529cbe987">01032</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keywordtype">int</span> l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r + (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>)l;}
<a name="l01033"></a>01033 
<a name="l01034"></a>01034 <span class="comment">// Complex, conjugate, and negator are all easy to templatize.</span>
<a name="l01035"></a>01035 
<a name="l01036"></a>01036 <span class="comment">// v = v+complex, complex+v</span>
<a name="l01037"></a>01037 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01038"></a>01038 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Add
<a name="l01039"></a><a class="code" href="namespaceSimTK.html#a0bc1c0280a0f1868edde61dd86d5b480">01039</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> std::complex&lt;R&gt;&amp; r)
<a name="l01040"></a>01040   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;std::complex&lt;R&gt; &gt;::AddOp::perform(l,r); }
<a name="l01041"></a>01041 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01042"></a>01042 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Add
<a name="l01043"></a><a class="code" href="namespaceSimTK.html#afc5b7ca1f02d05cf55353bcb7e632053">01043</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> std::complex&lt;R&gt;&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r+l;}
<a name="l01044"></a>01044 
<a name="l01045"></a>01045 <span class="comment">// v = v+conjugate, conjugate+v (convert conjugate-&gt;complex)</span>
<a name="l01046"></a>01046 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01047"></a>01047 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Add
<a name="l01048"></a><a class="code" href="namespaceSimTK.html#a0244d71291b85fdea239c7a73586fa88">01048</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1conjugate.html" title="SimTK::conjugate&lt;R&gt; should be instantiated only for float, double, long double.">conjugate&lt;R&gt;</a>&amp; r) {<span class="keywordflow">return</span> l+(std::complex&lt;R&gt;)r;}
<a name="l01049"></a>01049 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01050"></a>01050 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Add
<a name="l01051"></a><a class="code" href="namespaceSimTK.html#aaf9454b3e07a5741a6513fc7e90a8928">01051</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1conjugate.html" title="SimTK::conjugate&lt;R&gt; should be instantiated only for float, double, long double.">conjugate&lt;R&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r+(std::complex&lt;R&gt;)l;}
<a name="l01052"></a>01052 
<a name="l01053"></a>01053 <span class="comment">// v = v+negator, negator+v: convert negator to standard number</span>
<a name="l01054"></a>01054 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01055"></a>01055 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename negator&lt;R&gt;::StdNumber&gt;::Add
<a name="l01056"></a><a class="code" href="namespaceSimTK.html#a92a0c5ceb10f9badda20bc5c82e534ee">01056</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;R&gt;</a>&amp; r) {<span class="keywordflow">return</span> l + (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1negator.html#ae3b11033129d454a94ac9c8665dbd07e">negator&lt;R&gt;::StdNumber</a>)(R)r;}
<a name="l01057"></a>01057 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01058"></a>01058 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename negator&lt;R&gt;::StdNumber&gt;::Add
<a name="l01059"></a><a class="code" href="namespaceSimTK.html#acb1573f7b7143f9b08dd87a27ff83b96">01059</a> <a class="code" href="classSimTK_1_1Row.html#a0be3234b83b6d2ee4ce6d8e7ee638184">operator+</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;R&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> r + (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1negator.html#ae3b11033129d454a94ac9c8665dbd07e">negator&lt;R&gt;::StdNumber</a>)(R)l;}
<a name="l01060"></a>01060 
<a name="l01061"></a>01061 <span class="comment">// SCALAR SUBTRACT -- careful, not commutative.</span>
<a name="l01062"></a>01062 
<a name="l01063"></a>01063 <span class="comment">// v = v-real, real-v </span>
<a name="l01064"></a>01064 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01065"></a>01065 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;float&gt;::Sub
<a name="l01066"></a><a class="code" href="namespaceSimTK.html#ad90376ffb4b2a46e3aaadd859a7aee49">01066</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; r)
<a name="l01067"></a>01067   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;float&gt;::SubOp::perform(l,r); }
<a name="l01068"></a>01068 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01069"></a>01069 <span class="keyword">typename</span> CNT&lt;float&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Sub
<a name="l01070"></a><a class="code" href="namespaceSimTK.html#adb4f16fa447341b48874ea215909a941">01070</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r)
<a name="l01071"></a>01071   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;float&gt;::template</a> Result&lt;Row&lt;N,E,S&gt; &gt;::SubOp::perform(l,r); }
<a name="l01072"></a>01072 
<a name="l01073"></a>01073 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01074"></a>01074 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;double&gt;::Sub
<a name="l01075"></a><a class="code" href="namespaceSimTK.html#a2d2b73fbcd077129eac3e06feaf9160a">01075</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; r)
<a name="l01076"></a>01076   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;double&gt;::SubOp::perform(l,r); }
<a name="l01077"></a>01077 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01078"></a>01078 <span class="keyword">typename</span> CNT&lt;double&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Sub
<a name="l01079"></a><a class="code" href="namespaceSimTK.html#a229f61fc3c3400d76101c398cd94ad82">01079</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r)
<a name="l01080"></a>01080   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;double&gt;::template</a> Result&lt;Row&lt;N,E,S&gt; &gt;::SubOp::perform(l,r); }
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01083"></a>01083 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;long double&gt;::Sub
<a name="l01084"></a><a class="code" href="namespaceSimTK.html#a7f8280a19de650584bed5cd3de9d51f1">01084</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span>&amp; r)
<a name="l01085"></a>01085   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;long double&gt;::SubOp::perform(l,r); }
<a name="l01086"></a>01086 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01087"></a>01087 <span class="keyword">typename</span> CNT&lt;long double&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Sub
<a name="l01088"></a><a class="code" href="namespaceSimTK.html#a573e640f8c0aef233f2f77f87c174e44">01088</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r)
<a name="l01089"></a>01089   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;long double&gt;::template</a> Result&lt;Row&lt;N,E,S&gt; &gt;::SubOp::perform(l,r); }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 <span class="comment">// v = v-int, int-v // just convert int to v&#39;s precision float</span>
<a name="l01092"></a>01092 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01093"></a>01093 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename CNT&lt;E&gt;::Precision&gt;::Sub
<a name="l01094"></a><a class="code" href="namespaceSimTK.html#a1704ad4b6d269a4ccf7cb192998cbd44">01094</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keywordtype">int</span> r) {<span class="keywordflow">return</span> l - (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>)r;}
<a name="l01095"></a>01095 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S&gt; <span class="keyword">inline</span>
<a name="l01096"></a>01096 <span class="keyword">typename</span> CNT&lt;typename CNT&lt;E&gt;::Precision&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Sub
<a name="l01097"></a><a class="code" href="namespaceSimTK.html#a139709818ede6ba0f4c098f7aedfb6ca">01097</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keywordtype">int</span> l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1CNT.html#ae9ac0e4d4ae2c731f84c181fa31be0e9">CNT&lt;E&gt;::Precision</a>)l - r;}
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 <span class="comment">// Complex, conjugate, and negator are all easy to templatize.</span>
<a name="l01101"></a>01101 
<a name="l01102"></a>01102 <span class="comment">// v = v-complex, complex-v</span>
<a name="l01103"></a>01103 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01104"></a>01104 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Sub
<a name="l01105"></a><a class="code" href="namespaceSimTK.html#a38513830400aaa78a63cb3941e52c5b2">01105</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> std::complex&lt;R&gt;&amp; r)
<a name="l01106"></a>01106   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;::template</a> Result&lt;std::complex&lt;R&gt; &gt;::SubOp::perform(l,r); }
<a name="l01107"></a>01107 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01108"></a>01108 <span class="keyword">typename</span> CNT&lt;std::complex&lt;R&gt; &gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Sub
<a name="l01109"></a><a class="code" href="namespaceSimTK.html#acd5a8d5387d2e8aff403734e3f5d0faf">01109</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> std::complex&lt;R&gt;&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r)
<a name="l01110"></a>01110   { <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT&lt;std::complex&lt;R&gt;</a> &gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::SubOp::perform(l,r); }
<a name="l01111"></a>01111 
<a name="l01112"></a>01112 <span class="comment">// v = v-conjugate, conjugate-v (convert conjugate-&gt;complex)</span>
<a name="l01113"></a>01113 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01114"></a>01114 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;std::complex&lt;R&gt; &gt;::Sub
<a name="l01115"></a><a class="code" href="namespaceSimTK.html#ae63c11a343d6632b56bfb4689ba1c71c">01115</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1conjugate.html" title="SimTK::conjugate&lt;R&gt; should be instantiated only for float, double, long double.">conjugate&lt;R&gt;</a>&amp; r) {<span class="keywordflow">return</span> l-(std::complex&lt;R&gt;)r;}
<a name="l01116"></a>01116 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01117"></a>01117 <span class="keyword">typename</span> CNT&lt;std::complex&lt;R&gt; &gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Sub
<a name="l01118"></a><a class="code" href="namespaceSimTK.html#a8e9be51ab3330a8324c00aba96052cbb">01118</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1conjugate.html" title="SimTK::conjugate&lt;R&gt; should be instantiated only for float, double, long double.">conjugate&lt;R&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> (std::complex&lt;R&gt;)l-r;}
<a name="l01119"></a>01119 
<a name="l01120"></a>01120 <span class="comment">// v = v-negator, negator-v: convert negator to standard number</span>
<a name="l01121"></a>01121 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01122"></a>01122 <span class="keyword">typename</span> Row&lt;N,E,S&gt;::template Result&lt;typename negator&lt;R&gt;::StdNumber&gt;::Sub
<a name="l01123"></a><a class="code" href="namespaceSimTK.html#a4ff273f04372cef28aefb3f57d55cede">01123</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;R&gt;</a>&amp; r) {<span class="keywordflow">return</span> l-(<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1negator.html#ae3b11033129d454a94ac9c8665dbd07e">negator&lt;R&gt;::StdNumber</a>)(R)r;}
<a name="l01124"></a>01124 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> R&gt; <span class="keyword">inline</span>
<a name="l01125"></a>01125 <span class="keyword">typename</span> CNT&lt;R&gt;::template Result&lt;Row&lt;N,E,S&gt; &gt;::Sub
<a name="l01126"></a><a class="code" href="namespaceSimTK.html#a7ec098096fe6adcffba09796b04ed259">01126</a> <a class="code" href="classSimTK_1_1Row.html#a3bd4904d31bcc67f177751f24476a897">operator-</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1negator.html" title="negator&lt;N&gt;, where N is a number type (real, complex, conjugate), is represented in memory identically...">negator&lt;R&gt;</a>&amp; l, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; r) {<span class="keywordflow">return</span> (<span class="keyword">typename</span> <a class="code" href="classSimTK_1_1negator.html#ae3b11033129d454a94ac9c8665dbd07e">negator&lt;R&gt;::StdNumber</a>)(R)l-r;}
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 
<a name="l01129"></a>01129 <span class="comment">// Row I/O</span>
<a name="l01130"></a>01130 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> CHAR, <span class="keyword">class</span> TRAITS&gt; <span class="keyword">inline</span>
<a name="l01131"></a>01131 std::basic_ostream&lt;CHAR,TRAITS&gt;&amp;
<a name="l01132"></a><a class="code" href="namespaceSimTK.html#acbf4fb3509a0ed0d0d80829c413ace17">01132</a> operator&lt;&lt;(std::basic_ostream&lt;CHAR,TRAITS&gt;&amp; o, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; v) {
<a name="l01133"></a>01133     o &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; v[0]; <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;N;++i) o&lt;&lt;<span class="charliteral">&#39;,&#39;</span>&lt;&lt;v[i]; o&lt;&lt;<span class="charliteral">&#39;]&#39;</span>; <span class="keywordflow">return</span> o;
<a name="l01134"></a>01134 }
<a name="l01135"></a>01135 
<a name="l01138"></a>01138 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E, <span class="keywordtype">int</span> S, <span class="keyword">class</span> CHAR, <span class="keyword">class</span> TRAITS&gt; <span class="keyword">inline</span>
<a name="l01139"></a>01139 std::basic_istream&lt;CHAR,TRAITS&gt;&amp;
<a name="l01140"></a><a class="code" href="namespaceSimTK.html#a94ac775a450de4c8c2a5f4902bde8697">01140</a> <a class="code" href="namespaceSimTK.html#a32bc3311eb9591b84552fb442a6567c5">operator&gt;&gt;</a>(std::basic_istream&lt;CHAR,TRAITS&gt;&amp; is, <a class="code" href="classSimTK_1_1Row.html" title="Generic Row.">Row&lt;N,E,S&gt;</a>&amp; v) {
<a name="l01141"></a>01141     CHAR openBracket, closeBracket;
<a name="l01142"></a>01142     is &gt;&gt; openBracket; <span class="keywordflow">if</span> (is.fail()) <span class="keywordflow">return</span> is;
<a name="l01143"></a>01143     <span class="keywordflow">if</span> (openBracket==CHAR(<span class="charliteral">&#39;(&#39;</span>))
<a name="l01144"></a>01144         closeBracket = CHAR(<span class="charliteral">&#39;)&#39;</span>);
<a name="l01145"></a>01145     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (openBracket==CHAR(<span class="charliteral">&#39;[&#39;</span>))
<a name="l01146"></a>01146         closeBracket = CHAR(<span class="charliteral">&#39;]&#39;</span>);
<a name="l01147"></a>01147     <span class="keywordflow">else</span> {
<a name="l01148"></a>01148         closeBracket = CHAR(0);
<a name="l01149"></a>01149         is.unget(); <span class="keywordflow">if</span> (is.fail()) <span class="keywordflow">return</span> is;
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; N; ++i) {
<a name="l01153"></a>01153         is &gt;&gt; v[i];
<a name="l01154"></a>01154         <span class="keywordflow">if</span> (is.fail()) <span class="keywordflow">return</span> is;
<a name="l01155"></a>01155         <span class="keywordflow">if</span> (i != N-1) {
<a name="l01156"></a>01156             CHAR c; is &gt;&gt; c; <span class="keywordflow">if</span> (is.fail()) <span class="keywordflow">return</span> is;
<a name="l01157"></a>01157             <span class="keywordflow">if</span> (c != <span class="charliteral">&#39;,&#39;</span>) is.unget();
<a name="l01158"></a>01158             <span class="keywordflow">if</span> (is.fail()) <span class="keywordflow">return</span> is;
<a name="l01159"></a>01159         }
<a name="l01160"></a>01160     }
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="comment">// Get the closing bracket if there was an opening one. If we don&#39;t</span>
<a name="l01163"></a>01163     <span class="comment">// see the expected character we&#39;ll set the fail bit in the istream.</span>
<a name="l01164"></a>01164     <span class="keywordflow">if</span> (closeBracket != CHAR(0)) {
<a name="l01165"></a>01165         CHAR closer; is &gt;&gt; closer; <span class="keywordflow">if</span> (is.fail()) <span class="keywordflow">return</span> is;
<a name="l01166"></a>01166         <span class="keywordflow">if</span> (closer != closeBracket) {
<a name="l01167"></a>01167             is.unget(); <span class="keywordflow">if</span> (is.fail()) <span class="keywordflow">return</span> is;
<a name="l01168"></a>01168             is.setstate( std::ios::failbit );
<a name="l01169"></a>01169         }
<a name="l01170"></a>01170     }
<a name="l01171"></a>01171 
<a name="l01172"></a>01172     <span class="keywordflow">return</span> is;
<a name="l01173"></a>01173 }
<a name="l01174"></a>01174 
<a name="l01175"></a>01175 } <span class="comment">//namespace SimTK</span>
<a name="l01176"></a>01176 
<a name="l01177"></a>01177 
<a name="l01178"></a>01178 <span class="preprocessor">#endif //SimTK_SIMMATRIX_SMALLMATRIX_ROW_H_</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="Row_8h.html">Row.h</a>      </li>

    <li class="footer">Generated on Mon Jul 14 2014 23:25:53 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
