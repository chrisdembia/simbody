<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::Vec&lt; M, ELT, STRIDE &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1Vec.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Vec&lt; M, ELT, STRIDE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::Vec" -->
<p>This is a fixed length column vector designed for no-overhead inline computation.  
 <a href="classSimTK_1_1Vec.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Vec_8h_source.html">Vec.h</a>&gt;</code></p>

<p>Inherited by <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec&lt; Real, 1 &gt;</a>.</p>

<p><a href="classSimTK_1_1Vec-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1Vec_1_1EltResult.html">EltResult</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1Vec_1_1Substitute.html">Substitute</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape-preserving element substitution (always packed).  <a href="structSimTK_1_1Vec_1_1Substitute.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are obscure members of Vec that are used for template metaprogramming and can be ignored by most users.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca4098ba4c994d0a05d79f1f011fe826bb">NRows</a> =  M, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcaacb219bca801fa9b299610f154f34a04">NCols</a> =  1, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca71e046bac8a181561519a6122e2da18d">NPackedElements</a> =  M, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcaa25980e89b5b6f756347facaa55bd6e5">NActualElements</a> =  M * STRIDE, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcaece1f9f77763466fb8f7c196fd2b8f7a">NActualScalars</a> =  CNT&lt;E&gt;::NActualScalars * NActualElements, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca8f18985bf3fa11ed08b6840c04705116">RowSpacing</a> =  STRIDE, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6d4bd0883fc982185b9e36f48ce39e1c">ColSpacing</a> =  NActualElements, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcad531daf9c05933f95244a34b03754cda">ImagOffset</a> =  NTraits&lt;ENumber&gt;::ImagOffset, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a> =  1, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca4f5243de94fcb7adbf667f1a107ea625">ArgDepth</a>, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcade2306ea77a38b5b4eb3c23646f359be">IsScalar</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca2a5ac8bb16b80ee3aab25745909e0de4">IsULessScalar</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca766b45bc4868d8a042efa4533671d18a">IsNumber</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca2816cf70d3e06a09f6c54fc943689d17">IsStdNumber</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca8f0d38ec0caa44f7307829d6ec454170">IsPrecision</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca25bedfb632d2832892205ac5572d38be">SignInterpretation</a> =  CNT&lt;E&gt;::SignInterpretation
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fc">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ELT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type of this Vec.  <a href="#a1c4f863a54b68343ab160d46a4dfa107"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Negated version of this Vec's element type; ENeg==negator&lt; E &gt;.  <a href="#a180db0a856dcd33f438ff607fb2d578e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type, stripped of negator&lt;&gt; if it has one.  <a href="#a1688fa5889391ca2510ec85af32c4d27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type showing just the real part of an element of this Vec if elements are complex; otherwise just the element type.  <a href="#a9fe820179fbd756adb31a21ea1635c1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type showing the imaginary part of an element of this Vec as real, if elements are complex; otherwise a type that can hold a zero of the element type.  <a href="#ac960a48f176aa0870f267e6555489969"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that elements would have if complex, if E is currently real; otherwise just the element type E.  <a href="#aa7122a7babdc45b6559fcfb2bcc5ba3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Hermitian transpose of an element of this Vec.  <a href="#af1a6fe2fbd6109e110319dde19ef8080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aaf724f6707ea5d622a8218c8c7d0a47a">EPosTrans</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a <em>positional</em> transpose of an element of this Vec.  <a href="#aaf724f6707ea5d622a8218c8c7d0a47a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the expression ~E*E (default vector and matrix square; symmetric).  <a href="#a9e03a89cd7d90f90d2b77996912f7cf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the expression E*~E ("row square"; symmetric).  <a href="#aed4f65810f2f99f99286c4de7526944c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type required to hold the result of sqrt(E).  <a href="#ad7edbf8f2b7e6318eb98feadb1498e6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type required to hold the result of abs(E).  <a href="#a9328f6e879f0bce93ae861ed3830adfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of standardize(E) method; a packed type that can hold the value of an element after eliminating negator and conjugate types.  <a href="#a0cc83b9c25967c098119f0e604c15e3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed type that can hold the value returned from invert(E), the inverse type of an element.  <a href="#aeec08218c1b188793e64d47c3d1b8d87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed type that can hold the value returned from normalize(E).  <a href="#a5074ef8ddf4b5863b9c9aa73d08b0b51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#afb0c170f161ab33a760c6abed022c4e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a43fa9b9db155c966ec374279b11f7ec8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a16e9c638c3725abee10ac8c0a0416938"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a2dd99fd4db282175335f6b70a09c42d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#ab6a2b3875ce3ab44712d2b46c7c8c48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#abb9df16575296931169e80790f8180ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a226b3621ca279d62533bf2c2bc1494cf">T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>.  <a href="#a226b3621ca279d62533bf2c2bc1494cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> would have if its elements were interpreted as negated.  <a href="#ad810229be85191609884e56063b788ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <br class="typebreak"/>
<a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> with negator removed from its element type, if the element is negated.  <a href="#a5f18f1a887b7a31eaab12703b2d56eb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a>, STRIDE <br class="typebreak"/>
*<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> cast to show only the real part of its element; this might affect the stride.  <a href="#aebcbc25b0f0f1f9226dfe5796f30d459"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a>, STRIDE <br class="typebreak"/>
*<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> cast to show only the imaginary part of its element; this might affect the stride.  <a href="#acf0a11445fddc280dd6a1b3f9a54d4d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a3ac8c95d23ac09084c957db9e0807af4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> after casting to its Hermitian transpose; that is, the <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> turns into a <a class="el" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a> and each element turns into <em>its</em> Hermitian transpose.  <a href="#a1664440ae833e25958fb6006815b93df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> after casting to its positional transpose; that is, the <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> turns into a <a class="el" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a> but the element type remains unchanged.  <a href="#a21c96e0dda112e02745075e8bb727651"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a306a8e6c01acbd2f6f27769abe6f1fb8">TElement</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>.  <a href="#a306a8e6c01acbd2f6f27769abe6f1fb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adee9814da9f07edf05e10aa8bf5b52a7">TRow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a row of this <a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a> object (for a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>, just its element type).  <a href="#adee9814da9f07edf05e10aa8bf5b52a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3bea93707d0d519f3bc680520ed6dba8">TCol</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a column of this <a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a> object (for a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>, the whole thing).  <a href="#a3bea93707d0d519f3bc680520ed6dba8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a6d723146f29d99138956fe3b0d71ea6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a429ca3d609af5044f8be5243dfba714b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#ad1f95f01fde583b2d46c9ef7a31e582e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#adee68a1b3427cdc2a096be35d8b3f1f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a5f4d20cd03be610a163f04985d74822d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#aba33f5ae46bd5406b8bead75d3225e08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#af941dd81c240827a807b59925f9353ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a2747df15d62910c4e106267ff6a6456c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#acd8d06bc21666d641e6e8fc1d2348474"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#ad2dcbe4f4c13eab6d32664b39c53067e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#aed3382cfdf59b23ac5fe16a359b9800e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#af41c74dcba45cbeccdafdc3c9276048d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#ac5410fb3fc14453b32ced2e8134ad36c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a712141bb4fe924637c14555b1954b66a">scalarNormSqr</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar norm square is sum( conjugate squares of all underlying scalars ), where conjugate square of scalar s is conj(s)*s.  <a href="#a712141bb4fe924637c14555b1954b66a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6a37bb45b9fc50d691005df0824af255">sqrt</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise square root; that is, the return value has the same length as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> but with each element replaced by whatever it thinks its square root is.  <a href="#a6a37bb45b9fc50d691005df0824af255"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aafc94c4eaac8216b124ef659ff1d5487">abs</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise absolute value; that is, the return value has the same dimension as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> but with each element replaced by whatever it thinks its absolute value is.  <a href="#aafc94c4eaac8216b124ef659ff1d5487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af696f3d3ec205726a276a2355104d9c5">standardize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> but with the underlying scalar type converted (if necessary) to one of the C++ standard real or complex floating point types.  <a href="#af696f3d3ec205726a276a2355104d9c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a051dc2d9f18a5b8b192e6e33c2dd49b4">sum</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum just adds up all the elements into a single return element that is the same type as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>'s elements except standardized to use one of the C++ built-in real or complex types as its underlying scalars.  <a href="#a051dc2d9f18a5b8b192e6e33c2dd49b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7d52d8c3207d1fd68197233c4a60029c">Vec</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construction initializes Vec's elements to NaN when debugging but leaves them uninitialized garbage otherwise, so declarations have zero cost in Release builds.  <a href="#a7d52d8c3207d1fd68197233c4a60029c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad34c3d97a17ed494e9f0e5b2829ae419">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination.  <a href="#ad34c3d97a17ed494e9f0e5b2829ae419"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a96ee6e2f4bad2e772e4ad019b28c591a">operator=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination.  <a href="#a96ee6e2f4bad2e772e4ad019b28c591a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad6fd4b510a548add1477a13a1c99cc87">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, SS &gt; &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion from a Vec of the same length and element type but with a different stride.  <a href="#ad6fd4b510a548add1477a13a1c99cc87"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a57a5678f4109bde28c1c7829f030a752">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>, SS &gt; &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion from a Vec of the same length and <em>negated</em> element type (possibly with a different stride).  <a href="#a57a5678f4109bde28c1c7829f030a752"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad9220ca15fa8c7647bb0d5a7aaeb83b5">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> from a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> of the same length, with any stride.  <a href="#ad9220ca15fa8c7647bb0d5a7aaeb83b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abe343569bdc62601e22eddccb9b76fa3">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a single value of this Vec's element type assigns that value to each element.  <a href="#abe343569bdc62601e22eddccb9b76fa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0d54996ceb0ffdaaf35c0b42d13ffb22">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a> &amp;ne)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a single value of this Vec's negated element type assigns that value to each element, requiring floating point negation to be performed once to compute the type-E representation of the type negator&lt;E&gt; value provided.  <a href="#a0d54996ceb0ffdaaf35c0b42d13ffb22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a58a2921791ea75c7022fb593b45c43f7">Vec</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an int value, turn it into a suitable floating point number, convert that to element type E and then feed that to the above single-element constructor.  <a href="#a58a2921791ea75c7022fb593b45c43f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a594d2b0d02e91efc5547af4678d3535c">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a Vec&lt;2,E&gt; from two elements of type E, etc.  <a href="#a594d2b0d02e91efc5547af4678d3535c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6e0a194f6ca013c9026ff72f461bfc46">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a71c9a675a80482caf12e02a34b399bb1">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a774e82ed4bb90e65fee729e2082e413b">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4dcac91cb1609810fac49da700e70e77">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5978f046474cf4481a5f0470f9558a29">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae204f1902d2834ff3f47f3c84db23385">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e7)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad4f80f6ed39b2a75521423d25b23835b">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9c66f56b1930d82c36f90142af7fb536">Vec</a> (const EE *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E.  <a href="#a9c66f56b1930d82c36f90142af7fb536"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1bf45d78264b6e333d79985c371efbf4">operator=</a> (const EE *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E.  <a href="#a1bf45d78264b6e333d79985c371efbf4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9ced2e90bb014a4c09f2e830846b73ac">operator=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;vv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a conforming Vec, of any element type and stride, provided that the element types are assignment-compatible.  <a href="#a9ced2e90bb014a4c09f2e830846b73ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2a8255aebddddbcdb4aaae12736a1b05">operator+=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in a conforming Vec, of any element type and stride, provided that the element types are addition-compatible.  <a href="#a2a8255aebddddbcdb4aaae12736a1b05"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a51cc4c59703b5544ac71bc5e57cc0b19">operator+=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible.  <a href="#a51cc4c59703b5544ac71bc5e57cc0b19"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a46b643762736321072c6bd58ba141841">operator-=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off a conforming Vec, of any element type and stride, provided that the element types are addition-compatible.  <a href="#a46b643762736321072c6bd58ba141841"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aee444801ca472095d6fc0ff1a103718f">operator-=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible.  <a href="#aee444801ca472095d6fc0ff1a103718f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a82a4da394cb53cde9c5a63dc8a098f8d">conformingAdd</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector addition -- use operator+ instead.  <a href="#a82a4da394cb53cde9c5a63dc8a098f8d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a69d1a60f240f485bc1f9c844ec1cd733">conformingSubtract</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector subtraction -- use operator- instead.  <a href="#a69d1a60f240f485bc1f9c844ec1cd733"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Mul &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7a9702efd5be91edf3f06f0680303ec0">conformingMultiply</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as outer product (m = col*row) -- use operator* or <a class="el" href="namespaceSimTK.html#a0fd293cad29bd6fa0405ccffca69c738">outer()</a> instead.  <a href="#a7a9702efd5be91edf3f06f0680303ec0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Mul &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5f554ca51a94f9cfa61a36b495478e5c">elementwiseMultiply</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (Matlab .  <a href="#a5f554ca51a94f9cfa61a36b495478e5c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Dvd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3af4163f4d188bf82242584bf985ccb8">elementwiseDivide</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise divide (Matlab .  <a href="#a3af4163f4d188bf82242584bf985ccb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab1ecf7f59bd4b7c6b9dfd67566b75449">operator[]</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element of this Vec and return a const reference to it.  <a href="#ab1ecf7f59bd4b7c6b9dfd67566b75449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a32bc6a710c601343c9fe30e34c20b7bf">operator()</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const operator[] above.  <a href="#a32bc6a710c601343c9fe30e34c20b7bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae44a011242e15a9188acf63a6625e6cc">operator[]</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element of this Vec and return a writable reference to it.  <a href="#ae44a011242e15a9188acf63a6625e6cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2918c06d3f0b353076c5fa9ce8019509">operator()</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator[] above.  <a href="#a2918c06d3f0b353076c5fa9ce8019509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a95575b22850f63eaa64858660c8c8c64">normSqr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5bcb573b11b780148f1ff3e7f5961997">norm</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abbd852b56584cfeda803eab3a95fb7db">normalize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the elements of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> are scalars, the result is what you get by dividing each element by the <a class="el" href="classSimTK_1_1Vec.html#a5bcb573b11b780148f1ff3e7f5961997">norm()</a> calculated above.  <a href="#abbd852b56584cfeda803eab3a95fb7db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a66cea75e2ed6de1c379a46745849c473">invert</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is not supported for Vec objects.  <a href="#a66cea75e2ed6de1c379a46745849c473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae28bb6b73abb3704de062f751dab4921">operator+</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus does nothing.  <a href="#ae28bb6b73abb3704de062f751dab4921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1d18cd6340b717437a31770499069bfd">operator-</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus recasts this Vec to a type that has the opposite interpretation of the sign but is otherwise identical, so no computation or copying is performed here.  <a href="#a1d18cd6340b717437a31770499069bfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a52644eefd67080b80bba767e5affceb8">operator-</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to negated type and return a writable reference; writing to this will cause the negated result to be placed in the original Vec.  <a href="#a52644eefd67080b80bba767e5affceb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4b82833142e2b30ae998f1ee357245b4">operator~</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Hermitian transpose operator recasts this Vec to a type that specifies the opposite storage order (row vs. column) then returns a reference, so no computation or copying is performed here.  <a href="#a4b82833142e2b30ae998f1ee357245b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a055c47346d5b16b0a7ced839b91a9aa4">operator~</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to Hermitian transposed type and return a writable reference; the effect is that writing to elements of the result affects the transposed element of the original Vec.  <a href="#a055c47346d5b16b0a7ced839b91a9aa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a99e24a8076a1aed2b65595b0b382c71f">negate</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of unary negation; just a recast.  <a href="#a99e24a8076a1aed2b65595b0b382c71f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5108f85c423f5e00e51a198734ed17c3">updNegate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of unary negation; recasts and returns a writable reference.  <a href="#a5108f85c423f5e00e51a198734ed17c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3eb9d7c001c9594fd65c50365dce0d5c">transpose</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of Hermitian transpose; just a recast.  <a href="#a3eb9d7c001c9594fd65c50365dce0d5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3e181c0844930d9dbec8afb613f762d7">updTranspose</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of Hermitian transpose; recasts and returns a writable reference.  <a href="#a3e181c0844930d9dbec8afb613f762d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1e92208963211edbb39751c128310a0e">positionalTranspose</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Positional transpose turns this Vec into a <a class="el" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a> but does not transpose the individual elements.  <a href="#a1e92208963211edbb39751c128310a0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6021a62d22537c7ad406b7a1c1ca0761">updPositionalTranspose</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Positional transpose returning a writable reference.  <a href="#a6021a62d22537c7ad406b7a1c1ca0761"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ac891ea80a0181132c2430a349f461d72">real</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the real portion of this Vec if it has complex elements; otherwise the type doesn't change.  <a href="#ac891ea80a0181132c2430a349f461d72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adc792ec3e435535fc8fe4ad3810d54fe">real</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to show only the real portion of this Vec and return a writable reference.  <a href="#adc792ec3e435535fc8fe4ad3810d54fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aff885dcf7ea01c94d7621be973fd1aa9">imag</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the imaginary portion of this Vec if it has complex elements; otherwise the type doesn't change.  <a href="#aff885dcf7ea01c94d7621be973fd1aa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4b3ecf2380f493c8b48ad6d0d50695f8">imag</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to show only the imaginary portion of this Vec and return a writable reference.  <a href="#a4b3ecf2380f493c8b48ad6d0d50695f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9283ff051541b8f511d748f862f1eb9b">castAwayNegatorIfAny</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to remove negators from this Vec's type if present; this is handy for simplifying operations where we know the sign can be ignored such as squaring.  <a href="#a9283ff051541b8f511d748f862f1eb9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2467300a636639eb7195ca7ea37d5ee8">updCastAwayNegatorIfAny</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to remove negators from this Vec's type if present and return a writable reference.  <a href="#a2467300a636639eb7195ca7ea37d5ee8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Mul &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a37b496ee9a8f41defa3250da5ed0014e">scalarMultiply</a> (const EE &amp;e) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Mul &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a314e384e0d1cc1077562131cb7a773a2">scalarMultiplyFromLeft</a> (const EE &amp;e) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Dvd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a97a9b3263e294d85755e4c777302c2ae">scalarDivide</a> (const EE &amp;e) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Dvd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a34606c49af85f3f3b54341b54815cf25">scalarDivideFromLeft</a> (const EE &amp;e) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a474088f0218a89d4116358da2ced4fcc">scalarAdd</a> (const EE &amp;e) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a69fc2003203268bcd10f9eadf9412695">scalarSubtract</a> (const EE &amp;e) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;<br class="typebreak"/>
::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5ee50b918ae4eefc8c8ac1a177d7f7c9">scalarSubtractFromLeft</a> (const EE &amp;e) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aace53cca908837b6b13de05a6bbda540">operator=</a> (const EE &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6d6459937f78236c913e2ec50d328d8d">operator+=</a> (const EE &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4b247dbd3a71bdcef1a0a4af1cece4c7">operator-=</a> (const EE &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1c865e00508d708562c21012f0cb66e1">operator*=</a> (const EE &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a273abdf63fc3f9e8d720b6b1c9ebd047">operator/=</a> (const EE &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a47cc5ea1fc0e6db75f4fe78c85772179">scalarEq</a> (const EE &amp;ee)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7d9a9f23aeaf38da791ec0173f5b49d8">scalarPlusEq</a> (const EE &amp;ee)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af1ecc870150f4bbaddacf812bf3a55a4">scalarMinusEq</a> (const EE &amp;ee)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a11d049de83f163743bc576395746f0e6">scalarMinusEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af8f25b932993267cacda311724882b90">scalarTimesEq</a> (const EE &amp;ee)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1549f7c02c5f35b6ae02f3a384ba0461">scalarTimesEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5ec0b452d52d289345c333b6b1f61c1b">scalarDivideEq</a> (const EE &amp;ee)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a68d6c34551dd57324842f2e630ac5798">scalarDivideEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a18982d1fac249ed0050b0497fc1b5fff">scalarEq</a> (int ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6e47b406661090c6bbb580bb32f613b6">scalarPlusEq</a> (int ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab402c2238f2821d55a97dcdfb36ad0ba">scalarMinusEq</a> (int ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7bba57628dc553c6155205ba7ebd0330">scalarTimesEq</a> (int ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aeafb7930483190b14571c043ccb33ce0">scalarDivideEq</a> (int ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab07b8dc8c7690f71f6a2a7232c06f8b9">scalarMinusEqFromLeft</a> (int ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a695383084e4311219d9c1d86330bc3fa">scalarTimesEqFromLeft</a> (int ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a45beaad82e2504367de24345f1b7f60c">scalarDivideEqFromLeft</a> (int ee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0b11014a0ad910e4254a26d39f013565">setToNaN</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every scalar in this Vec to NaN; this is the default initial value in Debug builds, but not in Release.  <a href="#a0b11014a0ad910e4254a26d39f013565"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a25018475a82b7f1c61956d824104b300">setToZero</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every scalar in this Vec to zero.  <a href="#a25018475a82b7f1c61956d824104b300"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int MM&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aba184e5623fcecb388ab58eb91232052">getSubVec</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a const reference to a sub-Vec with size known at compile time.  <a href="#aba184e5623fcecb388ab58eb91232052"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int MM&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a085715471acf42722ddd05eb8028e13c">updSubVec</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a writable reference to a sub-Vec with size known at compile time.  <a href="#a085715471acf42722ddd05eb8028e13c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M-1, ELT, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa0b31ae5026f2529651aeaad88d705b1">drop1</a> (int p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one smaller than this one by dropping the element at the indicated position p.  <a href="#aa0b31ae5026f2529651aeaad88d705b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M+1, ELT, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acc5b268f14abe92735185cafadd888dc">append1</a> (const EE &amp;v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one larger than this one by adding an element to the end.  <a href="#acc5b268f14abe92735185cafadd888dc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M+1, ELT, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a19c8f4c92e03d90c4ec80644fb3d7bdc">insert1</a> (int p, const EE &amp;v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one larger than this one by inserting an element <em>before</em> the indicated one.  <a href="#a19c8f4c92e03d90c4ec80644fb3d7bdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aee785192d37052d76ff80d62338a6302">isNaN</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any element of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> contains a NaN anywhere.  <a href="#aee785192d37052d76ff80d62338a6302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa92ef2895e51a3ff4f1a3c264012c4ad">isInf</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any element of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> contains a +Infinity or -Infinity somewhere but no element contains a NaN anywhere.  <a href="#aa92ef2895e51a3ff4f1a3c264012c4ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1a0574822d6633f8b621d9c676a4352a">isFinite</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if no element of this Vec contains an Infinity or a NaN anywhere.  <a href="#a1a0574822d6633f8b621d9c676a4352a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class E2 , int RS2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a862a6d93b3109965ce7104c6beae5de6">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;v, double tol) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this vector is numerically equal to some other vector with the same shape, using a specified tolerance.  <a href="#a862a6d93b3109965ce7104c6beae5de6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class E2 , int RS2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a596116b98d5d15f0112d1e052f09aeab">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this vector is numerically equal to some other vector with the same shape, using a default tolerance which is the looser of the default tolerances of the two objects being compared.  <a href="#a596116b98d5d15f0112d1e052f09aeab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a576e2e126e4f3bb2f59dc91ef1fbcfc4">isNumericallyEqual</a> (const ELT &amp;e, double tol=<a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a>()) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether every element of this vector is numerically equal to the given element, using either a specified tolerance or the vector's default tolerance (which is always the same or looser than the default tolerance for one of its elements).  <a href="#a576e2e126e4f3bb2f59dc91ef1fbcfc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa71ef634c8bcf182405248a215acb789">toString</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> into a string and return it.  <a href="#aa71ef634c8bcf182405248a215acb789"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a907c5d98e3f7b29f858c5f56c6e38738">set</a> (int i, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of operator[] that's scripting friendly to set ith entry.  <a href="#a907c5d98e3f7b29f858c5f56c6e38738"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a8bc57b3dd6983c252b3654a4d6548f05">get</a> (int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of operator[] that's scripting friendly to get const reference to ith entry.  <a href="#a8bc57b3dd6983c252b3654a4d6548f05"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adc9ccbb5060fdbbf1e4446337217b699">size</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> (note that stride does not affect this number.)  <a href="#adc9ccbb5060fdbbf1e4446337217b699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a99f8825fc5c6297c9e0d804f3471d1f1">nrow</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of rows in a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> is the number of elements.  <a href="#a99f8825fc5c6297c9e0d804f3471d1f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a51574e7c675a4662b23b24ba6e430492">ncol</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns in a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> is always 1.  <a href="#a51574e7c675a4662b23b24ba6e430492"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int MM&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a250ac248ba601828531ca324917dc3ef">getSubVec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;v, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a const reference to the selected subsequence.  <a href="#a250ac248ba601828531ca324917dc3ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int MM&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6c3d2b34d4c58321ddd8ebbc997877dc">updSubVec</a> (<a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;v, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a writable reference to the selected subsequence.  <a href="#a6c3d2b34d4c58321ddd8ebbc997877dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abf8283cc8bb6cccd44287e439811198d">getAs</a> (const ELT *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast an ordinary C++ array E[] to a const Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing.  <a href="#abf8283cc8bb6cccd44287e439811198d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#affb89a98c7696e0a5fa04a17924e19f7">updAs</a> (ELT *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a writable ordinary C++ array E[] to a writable Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing.  <a href="#affb89a98c7696e0a5fa04a17924e19f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, ELT, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ade1b06280e2190f1d4317a04355f12ee">getNaN</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Vec of the same length and element type as this one but with all elements set to NaN.  <a href="#ade1b06280e2190f1d4317a04355f12ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For approximate comparisions, the default tolerance to use for a vector is the same as its elements' default tolerance.  <a href="#a781827a50ebc3d83a0736738bc2e2784"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int M, class E , int S&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__writeUnformatted.html#gaea19f36902b9e41b3774e3103718dab5">writeUnformatted</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, S &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for Vec&lt;M,E,S&gt; to delegate to element type E, with spaces separating the elements.  <a href="group__writeUnformatted.html#gaea19f36902b9e41b3774e3103718dab5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int M, class E , int S&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__readFromStream.html#ga75b4dd0ea98de6059b13e98cabbefb82">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, S &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for Vec&lt;M,E,S&gt; to delegate to element type E, with spaces separating the elements.  <a href="group__readFromStream.html#ga75b4dd0ea98de6059b13e98cabbefb82"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;int M, class ELT, int STRIDE&gt;<br/>
class SimTK::Vec&lt; M, ELT, STRIDE &gt;</h3>

<p>This is a fixed length column vector designed for no-overhead inline computation. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">M</td><td>The number of rows in the vector. </td></tr>
    <tr><td class="paramname">ELT</td><td>The element type. Must be a composite numerical type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). The default is ELT=Real. </td></tr>
    <tr><td class="paramname">STRIDE</td><td>The spacing from one element to the next in memory, as an integer number of elements of type ELT. The default is STRIDE=1. </td></tr>
  </table>
  </dd>
</dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a1c4f863a54b68343ab160d46a4dfa107"></a><!-- doxytag: member="SimTK::Vec::E" ref="a1c4f863a54b68343ab160d46a4dfa107" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELT <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Element type of this Vec. </p>

</div>
</div>
<a class="anchor" id="a180db0a856dcd33f438ff607fb2d578e"></a><!-- doxytag: member="SimTK::Vec::ENeg" ref="a180db0a856dcd33f438ff607fb2d578e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negated version of this Vec's element type; ENeg==negator&lt; E &gt;. </p>

</div>
</div>
<a class="anchor" id="a1688fa5889391ca2510ec85af32c4d27"></a><!-- doxytag: member="SimTK::Vec::EWithoutNegator" ref="a1688fa5889391ca2510ec85af32c4d27" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Element type, stripped of negator&lt;&gt; if it has one. </p>

</div>
</div>
<a class="anchor" id="a9fe820179fbd756adb31a21ea1635c1b"></a><!-- doxytag: member="SimTK::Vec::EReal" ref="a9fe820179fbd756adb31a21ea1635c1b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type showing just the real part of an element of this Vec if elements are complex; otherwise just the element type. </p>

</div>
</div>
<a class="anchor" id="ac960a48f176aa0870f267e6555489969"></a><!-- doxytag: member="SimTK::Vec::EImag" ref="ac960a48f176aa0870f267e6555489969" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type showing the imaginary part of an element of this Vec as real, if elements are complex; otherwise a type that can hold a zero of the element type. </p>

</div>
</div>
<a class="anchor" id="aa7122a7babdc45b6559fcfb2bcc5ba3e"></a><!-- doxytag: member="SimTK::Vec::EComplex" ref="aa7122a7babdc45b6559fcfb2bcc5ba3e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type that elements would have if complex, if E is currently real; otherwise just the element type E. </p>

</div>
</div>
<a class="anchor" id="af1a6fe2fbd6109e110319dde19ef8080"></a><!-- doxytag: member="SimTK::Vec::EHerm" ref="af1a6fe2fbd6109e110319dde19ef8080" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the Hermitian transpose of an element of this Vec. </p>

</div>
</div>
<a class="anchor" id="aaf724f6707ea5d622a8218c8c7d0a47a"></a><!-- doxytag: member="SimTK::Vec::EPosTrans" ref="aaf724f6707ea5d622a8218c8c7d0a47a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aaf724f6707ea5d622a8218c8c7d0a47a">EPosTrans</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of a <em>positional</em> transpose of an element of this Vec. </p>

</div>
</div>
<a class="anchor" id="a9e03a89cd7d90f90d2b77996912f7cf3"></a><!-- doxytag: member="SimTK::Vec::ESqHermT" ref="a9e03a89cd7d90f90d2b77996912f7cf3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the expression ~E*E (default vector and matrix square; symmetric). </p>

</div>
</div>
<a class="anchor" id="aed4f65810f2f99f99286c4de7526944c"></a><!-- doxytag: member="SimTK::Vec::ESqTHerm" ref="aed4f65810f2f99f99286c4de7526944c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the expression E*~E ("row square"; symmetric). </p>

</div>
</div>
<a class="anchor" id="ad7edbf8f2b7e6318eb98feadb1498e6e"></a><!-- doxytag: member="SimTK::Vec::ESqrt" ref="ad7edbf8f2b7e6318eb98feadb1498e6e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type required to hold the result of sqrt(E). </p>

</div>
</div>
<a class="anchor" id="a9328f6e879f0bce93ae861ed3830adfd"></a><!-- doxytag: member="SimTK::Vec::EAbs" ref="a9328f6e879f0bce93ae861ed3830adfd" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type required to hold the result of abs(E). </p>

</div>
</div>
<a class="anchor" id="a0cc83b9c25967c098119f0e604c15e3c"></a><!-- doxytag: member="SimTK::Vec::EStandard" ref="a0cc83b9c25967c098119f0e604c15e3c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return type of standardize(E) method; a packed type that can hold the value of an element after eliminating negator and conjugate types. </p>

</div>
</div>
<a class="anchor" id="aeec08218c1b188793e64d47c3d1b8d87"></a><!-- doxytag: member="SimTK::Vec::EInvert" ref="aeec08218c1b188793e64d47c3d1b8d87" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packed type that can hold the value returned from invert(E), the inverse type of an element. </p>

</div>
</div>
<a class="anchor" id="a5074ef8ddf4b5863b9c9aa73d08b0b51"></a><!-- doxytag: member="SimTK::Vec::ENormalize" ref="a5074ef8ddf4b5863b9c9aa73d08b0b51" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packed type that can hold the value returned from normalize(E). </p>

</div>
</div>
<a class="anchor" id="afb0c170f161ab33a760c6abed022c4e5"></a><!-- doxytag: member="SimTK::Vec::EScalar" ref="afb0c170f161ab33a760c6abed022c4e5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a43fa9b9db155c966ec374279b11f7ec8"></a><!-- doxytag: member="SimTK::Vec::EULessScalar" ref="a43fa9b9db155c966ec374279b11f7ec8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a16e9c638c3725abee10ac8c0a0416938"></a><!-- doxytag: member="SimTK::Vec::ENumber" ref="a16e9c638c3725abee10ac8c0a0416938" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a2dd99fd4db282175335f6b70a09c42d3"></a><!-- doxytag: member="SimTK::Vec::EStdNumber" ref="a2dd99fd4db282175335f6b70a09c42d3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="ab6a2b3875ce3ab44712d2b46c7c8c48f"></a><!-- doxytag: member="SimTK::Vec::EPrecision" ref="ab6a2b3875ce3ab44712d2b46c7c8c48f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="abb9df16575296931169e80790f8180ee"></a><!-- doxytag: member="SimTK::Vec::EScalarNormSq" ref="abb9df16575296931169e80790f8180ee" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a226b3621ca279d62533bf2c2bc1494cf"></a><!-- doxytag: member="SimTK::Vec::T" ref="a226b3621ca279d62533bf2c2bc1494cf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a226b3621ca279d62533bf2c2bc1494cf">T</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>. </p>

</div>
</div>
<a class="anchor" id="ad810229be85191609884e56063b788ce"></a><!-- doxytag: member="SimTK::Vec::TNeg" ref="ad810229be85191609884e56063b788ce" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> would have if its elements were interpreted as negated. </p>

</div>
</div>
<a class="anchor" id="a5f18f1a887b7a31eaab12703b2d56eb5"></a><!-- doxytag: member="SimTK::Vec::TWithoutNegator" ref="a5f18f1a887b7a31eaab12703b2d56eb5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> with negator removed from its element type, if the element is negated. </p>

</div>
</div>
<a class="anchor" id="aebcbc25b0f0f1f9226dfe5796f30d459"></a><!-- doxytag: member="SimTK::Vec::TReal" ref="aebcbc25b0f0f1f9226dfe5796f30d459" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a>,STRIDE*<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a>&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> cast to show only the real part of its element; this might affect the stride. </p>

</div>
</div>
<a class="anchor" id="acf0a11445fddc280dd6a1b3f9a54d4d3"></a><!-- doxytag: member="SimTK::Vec::TImag" ref="acf0a11445fddc280dd6a1b3f9a54d4d3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a>,STRIDE*<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a>&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> cast to show only the imaginary part of its element; this might affect the stride. </p>

</div>
</div>
<a class="anchor" id="a3ac8c95d23ac09084c957db9e0807af4"></a><!-- doxytag: member="SimTK::Vec::TComplex" ref="a3ac8c95d23ac09084c957db9e0807af4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a1664440ae833e25958fb6006815b93df"></a><!-- doxytag: member="SimTK::Vec::THerm" ref="a1664440ae833e25958fb6006815b93df" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> after casting to its Hermitian transpose; that is, the <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> turns into a <a class="el" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a> and each element turns into <em>its</em> Hermitian transpose. </p>

</div>
</div>
<a class="anchor" id="a21c96e0dda112e02745075e8bb727651"></a><!-- doxytag: member="SimTK::Vec::TPosTrans" ref="a21c96e0dda112e02745075e8bb727651" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> after casting to its positional transpose; that is, the <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> turns into a <a class="el" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a> but the element type remains unchanged. </p>

</div>
</div>
<a class="anchor" id="a306a8e6c01acbd2f6f27769abe6f1fb8"></a><!-- doxytag: member="SimTK::Vec::TElement" ref="a306a8e6c01acbd2f6f27769abe6f1fb8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a306a8e6c01acbd2f6f27769abe6f1fb8">TElement</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Element type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>. </p>

</div>
</div>
<a class="anchor" id="adee9814da9f07edf05e10aa8bf5b52a7"></a><!-- doxytag: member="SimTK::Vec::TRow" ref="adee9814da9f07edf05e10aa8bf5b52a7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#adee9814da9f07edf05e10aa8bf5b52a7">TRow</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of a row of this <a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a> object (for a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>, just its element type). </p>

</div>
</div>
<a class="anchor" id="a3bea93707d0d519f3bc680520ed6dba8"></a><!-- doxytag: member="SimTK::Vec::TCol" ref="a3bea93707d0d519f3bc680520ed6dba8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3bea93707d0d519f3bc680520ed6dba8">TCol</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of a column of this <a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a> object (for a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>, the whole thing). </p>

</div>
</div>
<a class="anchor" id="a6d723146f29d99138956fe3b0d71ea6f"></a><!-- doxytag: member="SimTK::Vec::TSqrt" ref="a6d723146f29d99138956fe3b0d71ea6f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a429ca3d609af5044f8be5243dfba714b"></a><!-- doxytag: member="SimTK::Vec::TAbs" ref="a429ca3d609af5044f8be5243dfba714b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="ad1f95f01fde583b2d46c9ef7a31e582e"></a><!-- doxytag: member="SimTK::Vec::TStandard" ref="ad1f95f01fde583b2d46c9ef7a31e582e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="adee68a1b3427cdc2a096be35d8b3f1f6"></a><!-- doxytag: member="SimTK::Vec::TInvert" ref="adee68a1b3427cdc2a096be35d8b3f1f6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a5f4d20cd03be610a163f04985d74822d"></a><!-- doxytag: member="SimTK::Vec::TNormalize" ref="a5f4d20cd03be610a163f04985d74822d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="aba33f5ae46bd5406b8bead75d3225e08"></a><!-- doxytag: member="SimTK::Vec::TSqHermT" ref="aba33f5ae46bd5406b8bead75d3225e08" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="af941dd81c240827a807b59925f9353ae"></a><!-- doxytag: member="SimTK::Vec::TSqTHerm" ref="af941dd81c240827a807b59925f9353ae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a>&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a2747df15d62910c4e106267ff6a6456c"></a><!-- doxytag: member="SimTK::Vec::Scalar" ref="a2747df15d62910c4e106267ff6a6456c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="acd8d06bc21666d641e6e8fc1d2348474"></a><!-- doxytag: member="SimTK::Vec::ULessScalar" ref="acd8d06bc21666d641e6e8fc1d2348474" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="ad2dcbe4f4c13eab6d32664b39c53067e"></a><!-- doxytag: member="SimTK::Vec::Number" ref="ad2dcbe4f4c13eab6d32664b39c53067e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="aed3382cfdf59b23ac5fe16a359b9800e"></a><!-- doxytag: member="SimTK::Vec::StdNumber" ref="aed3382cfdf59b23ac5fe16a359b9800e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="af41c74dcba45cbeccdafdc3c9276048d"></a><!-- doxytag: member="SimTK::Vec::Precision" ref="af41c74dcba45cbeccdafdc3c9276048d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="ac5410fb3fc14453b32ced2e8134ad36c"></a><!-- doxytag: member="SimTK::Vec::ScalarNormSq" ref="ac5410fb3fc14453b32ced2e8134ad36c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fc"></a><!-- doxytag: member="SimTK::Vec::@10" ref="ac68d02035e9fb29b2b7c810a8d3554fc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca4098ba4c994d0a05d79f1f011fe826bb"></a><!-- doxytag: member="NRows" ref="ac68d02035e9fb29b2b7c810a8d3554fca4098ba4c994d0a05d79f1f011fe826bb" args="" -->NRows</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcaacb219bca801fa9b299610f154f34a04"></a><!-- doxytag: member="NCols" ref="ac68d02035e9fb29b2b7c810a8d3554fcaacb219bca801fa9b299610f154f34a04" args="" -->NCols</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca71e046bac8a181561519a6122e2da18d"></a><!-- doxytag: member="NPackedElements" ref="ac68d02035e9fb29b2b7c810a8d3554fca71e046bac8a181561519a6122e2da18d" args="" -->NPackedElements</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcaa25980e89b5b6f756347facaa55bd6e5"></a><!-- doxytag: member="NActualElements" ref="ac68d02035e9fb29b2b7c810a8d3554fcaa25980e89b5b6f756347facaa55bd6e5" args="" -->NActualElements</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcaece1f9f77763466fb8f7c196fd2b8f7a"></a><!-- doxytag: member="NActualScalars" ref="ac68d02035e9fb29b2b7c810a8d3554fcaece1f9f77763466fb8f7c196fd2b8f7a" args="" -->NActualScalars</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca8f18985bf3fa11ed08b6840c04705116"></a><!-- doxytag: member="RowSpacing" ref="ac68d02035e9fb29b2b7c810a8d3554fca8f18985bf3fa11ed08b6840c04705116" args="" -->RowSpacing</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca6d4bd0883fc982185b9e36f48ce39e1c"></a><!-- doxytag: member="ColSpacing" ref="ac68d02035e9fb29b2b7c810a8d3554fca6d4bd0883fc982185b9e36f48ce39e1c" args="" -->ColSpacing</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcad531daf9c05933f95244a34b03754cda"></a><!-- doxytag: member="ImagOffset" ref="ac68d02035e9fb29b2b7c810a8d3554fcad531daf9c05933f95244a34b03754cda" args="" -->ImagOffset</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197"></a><!-- doxytag: member="RealStrideFactor" ref="ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197" args="" -->RealStrideFactor</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca4f5243de94fcb7adbf667f1a107ea625"></a><!-- doxytag: member="ArgDepth" ref="ac68d02035e9fb29b2b7c810a8d3554fca4f5243de94fcb7adbf667f1a107ea625" args="" -->ArgDepth</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcade2306ea77a38b5b4eb3c23646f359be"></a><!-- doxytag: member="IsScalar" ref="ac68d02035e9fb29b2b7c810a8d3554fcade2306ea77a38b5b4eb3c23646f359be" args="" -->IsScalar</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca2a5ac8bb16b80ee3aab25745909e0de4"></a><!-- doxytag: member="IsULessScalar" ref="ac68d02035e9fb29b2b7c810a8d3554fca2a5ac8bb16b80ee3aab25745909e0de4" args="" -->IsULessScalar</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca766b45bc4868d8a042efa4533671d18a"></a><!-- doxytag: member="IsNumber" ref="ac68d02035e9fb29b2b7c810a8d3554fca766b45bc4868d8a042efa4533671d18a" args="" -->IsNumber</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca2816cf70d3e06a09f6c54fc943689d17"></a><!-- doxytag: member="IsStdNumber" ref="ac68d02035e9fb29b2b7c810a8d3554fca2816cf70d3e06a09f6c54fc943689d17" args="" -->IsStdNumber</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca8f0d38ec0caa44f7307829d6ec454170"></a><!-- doxytag: member="IsPrecision" ref="ac68d02035e9fb29b2b7c810a8d3554fca8f0d38ec0caa44f7307829d6ec454170" args="" -->IsPrecision</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca25bedfb632d2832892205ac5572d38be"></a><!-- doxytag: member="SignInterpretation" ref="ac68d02035e9fb29b2b7c810a8d3554fca25bedfb632d2832892205ac5572d38be" args="" -->SignInterpretation</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7d52d8c3207d1fd68197233c4a60029c"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a7d52d8c3207d1fd68197233c4a60029c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default construction initializes Vec's elements to NaN when debugging but leaves them uninitialized garbage otherwise, so declarations have zero cost in Release builds. </p>

</div>
</div>
<a class="anchor" id="ad34c3d97a17ed494e9f0e5b2829ae419"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="ad34c3d97a17ed494e9f0e5b2829ae419" args="(const Vec &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, ELT, STRIDE &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination. </p>

</div>
</div>
<a class="anchor" id="ad6fd4b510a548add1477a13a1c99cc87"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="ad6fd4b510a548add1477a13a1c99cc87" args="(const Vec&lt; M, E, SS &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an implicit conversion from a Vec of the same length and element type but with a different stride. </p>

</div>
</div>
<a class="anchor" id="a57a5678f4109bde28c1c7829f030a752"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a57a5678f4109bde28c1c7829f030a752" args="(const Vec&lt; M, ENeg, SS &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an implicit conversion from a Vec of the same length and <em>negated</em> element type (possibly with a different stride). </p>

</div>
</div>
<a class="anchor" id="ad9220ca15fa8c7647bb0d5a7aaeb83b5"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="ad9220ca15fa8c7647bb0d5a7aaeb83b5" args="(const Vec&lt; M, EE, SS &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> from a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> of the same length, with any stride. </p>
<p>Works as long as the element types are assignment compatible. </p>

</div>
</div>
<a class="anchor" id="abe343569bdc62601e22eddccb9b76fa3"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="abe343569bdc62601e22eddccb9b76fa3" args="(const E &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction from a single value of this Vec's element type assigns that value to each element. </p>

</div>
</div>
<a class="anchor" id="a0d54996ceb0ffdaaf35c0b42d13ffb22"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a0d54996ceb0ffdaaf35c0b42d13ffb22" args="(const ENeg &amp;ne)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a> &amp;&#160;</td>
          <td class="paramname"><em>ne</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction from a single value of this Vec's negated element type assigns that value to each element, requiring floating point negation to be performed once to compute the type-E representation of the type negator&lt;E&gt; value provided. </p>

</div>
</div>
<a class="anchor" id="a58a2921791ea75c7022fb593b45c43f7"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a58a2921791ea75c7022fb593b45c43f7" args="(int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an int value, turn it into a suitable floating point number, convert that to element type E and then feed that to the above single-element constructor. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Vec.html#abe343569bdc62601e22eddccb9b76fa3" title="Construction from a single value of this Vec&#39;s element type assigns that value to each element...">Vec::Vec(const E&amp;)</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a594d2b0d02e91efc5547af4678d3535c"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a594d2b0d02e91efc5547af4678d3535c" args="(const E &amp;e0, const E &amp;e1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Vec&lt;2,E&gt; from two elements of type E, etc. </p>

</div>
</div>
<a class="anchor" id="a6e0a194f6ca013c9026ff72f461bfc46"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a6e0a194f6ca013c9026ff72f461bfc46" args="(const E &amp;e0, const E &amp;e1, const E &amp;e2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a71c9a675a80482caf12e02a34b399bb1"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a71c9a675a80482caf12e02a34b399bb1" args="(const E &amp;e0, const E &amp;e1, const E &amp;e2, const E &amp;e3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a774e82ed4bb90e65fee729e2082e413b"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a774e82ed4bb90e65fee729e2082e413b" args="(const E &amp;e0, const E &amp;e1, const E &amp;e2, const E &amp;e3, const E &amp;e4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4dcac91cb1609810fac49da700e70e77"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a4dcac91cb1609810fac49da700e70e77" args="(const E &amp;e0, const E &amp;e1, const E &amp;e2, const E &amp;e3, const E &amp;e4, const E &amp;e5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5978f046474cf4481a5f0470f9558a29"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a5978f046474cf4481a5f0470f9558a29" args="(const E &amp;e0, const E &amp;e1, const E &amp;e2, const E &amp;e3, const E &amp;e4, const E &amp;e5, const E &amp;e6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae204f1902d2834ff3f47f3c84db23385"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="ae204f1902d2834ff3f47f3c84db23385" args="(const E &amp;e0, const E &amp;e1, const E &amp;e2, const E &amp;e3, const E &amp;e4, const E &amp;e5, const E &amp;e6, const E &amp;e7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4f80f6ed39b2a75521423d25b23835b"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="ad4f80f6ed39b2a75521423d25b23835b" args="(const E &amp;e0, const E &amp;e1, const E &amp;e2, const E &amp;e3, const E &amp;e4, const E &amp;e5, const E &amp;e6, const E &amp;e7, const E &amp;e8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c66f56b1930d82c36f90142af7fb536"></a><!-- doxytag: member="SimTK::Vec::Vec" ref="a9c66f56b1930d82c36f90142af7fb536" args="(const EE *p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const EE *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construction from a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E. </p>
<p>The supplied pointer cannot be null. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adc9ccbb5060fdbbf1e4446337217b699"></a><!-- doxytag: member="SimTK::Vec::size" ref="adc9ccbb5060fdbbf1e4446337217b699" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#adc9ccbb5060fdbbf1e4446337217b699">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of elements in this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> (note that stride does not affect this number.) </p>

</div>
</div>
<a class="anchor" id="a99f8825fc5c6297c9e0d804f3471d1f1"></a><!-- doxytag: member="SimTK::Vec::nrow" ref="a99f8825fc5c6297c9e0d804f3471d1f1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a99f8825fc5c6297c9e0d804f3471d1f1">nrow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of rows in a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> is the number of elements. </p>

</div>
</div>
<a class="anchor" id="a51574e7c675a4662b23b24ba6e430492"></a><!-- doxytag: member="SimTK::Vec::ncol" ref="a51574e7c675a4662b23b24ba6e430492" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a51574e7c675a4662b23b24ba6e430492">ncol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of columns in a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> is always 1. </p>

</div>
</div>
<a class="anchor" id="a712141bb4fe924637c14555b1954b66a"></a><!-- doxytag: member="SimTK::Vec::scalarNormSqr" ref="a712141bb4fe924637c14555b1954b66a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a712141bb4fe924637c14555b1954b66a">scalarNormSqr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar norm square is sum( conjugate squares of all underlying scalars ), where conjugate square of scalar s is conj(s)*s. </p>

</div>
</div>
<a class="anchor" id="a6a37bb45b9fc50d691005df0824af255"></a><!-- doxytag: member="SimTK::Vec::sqrt" ref="a6a37bb45b9fc50d691005df0824af255" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6a37bb45b9fc50d691005df0824af255">sqrt</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elementwise square root; that is, the return value has the same length as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> but with each element replaced by whatever it thinks its square root is. </p>
<p>The element type may have changed and the stride of the return <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> is always 1. </p>

</div>
</div>
<a class="anchor" id="aafc94c4eaac8216b124ef659ff1d5487"></a><!-- doxytag: member="SimTK::Vec::abs" ref="aafc94c4eaac8216b124ef659ff1d5487" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aafc94c4eaac8216b124ef659ff1d5487">abs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elementwise absolute value; that is, the return value has the same dimension as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> but with each element replaced by whatever it thinks its absolute value is. </p>
<p>The element type may have changed and the stride of the return <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> is always 1. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1UnitVec.html#a8fcc41c6547ed29ee4cd265c8bcc0074">SimTK::UnitVec&lt; P, S &gt;</a>, and <a class="el" href="classSimTK_1_1UnitVec.html#a8fcc41c6547ed29ee4cd265c8bcc0074">SimTK::UnitVec&lt; Real, 1 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af696f3d3ec205726a276a2355104d9c5"></a><!-- doxytag: member="SimTK::Vec::standardize" ref="af696f3d3ec205726a276a2355104d9c5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af696f3d3ec205726a276a2355104d9c5">standardize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a copy of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> but with the underlying scalar type converted (if necessary) to one of the C++ standard real or complex floating point types. </p>
<p>This may require floating point negations to occur to get read of negator or conjugate types. </p>

</div>
</div>
<a class="anchor" id="a051dc2d9f18a5b8b192e6e33c2dd49b4"></a><!-- doxytag: member="SimTK::Vec::sum" ref="a051dc2d9f18a5b8b192e6e33c2dd49b4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a051dc2d9f18a5b8b192e6e33c2dd49b4">sum</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum just adds up all the elements into a single return element that is the same type as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a>'s elements except standardized to use one of the C++ built-in real or complex types as its underlying scalars. </p>

</div>
</div>
<a class="anchor" id="a96ee6e2f4bad2e772e4ad019b28c591a"></a><!-- doxytag: member="SimTK::Vec::operator=" ref="a96ee6e2f4bad2e772e4ad019b28c591a" args="(const Vec &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, ELT, STRIDE &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination. </p>
<p>OK if source and destination are the same vector; results are unpredictable if they otherwise overlap with elements in common. </p>

</div>
</div>
<a class="anchor" id="a1bf45d78264b6e333d79985c371efbf4"></a><!-- doxytag: member="SimTK::Vec::operator=" ref="a1bf45d78264b6e333d79985c371efbf4" args="(const EE *p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const EE *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment to a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E. </p>
<p>The supplied pointer cannot be null. </p>

</div>
</div>
<a class="anchor" id="a9ced2e90bb014a4c09f2e830846b73ac"></a><!-- doxytag: member="SimTK::Vec::operator=" ref="a9ced2e90bb014a4c09f2e830846b73ac" args="(const Vec&lt; M, EE, SS &gt; &amp;vv)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>vv</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment to a conforming Vec, of any element type and stride, provided that the element types are assignment-compatible. </p>

</div>
</div>
<a class="anchor" id="a2a8255aebddddbcdb4aaae12736a1b05"></a><!-- doxytag: member="SimTK::Vec::operator+=" ref="a2a8255aebddddbcdb4aaae12736a1b05" args="(const Vec&lt; M, EE, SS &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add in a conforming Vec, of any element type and stride, provided that the element types are addition-compatible. </p>

</div>
</div>
<a class="anchor" id="a51cc4c59703b5544ac71bc5e57cc0b19"></a><!-- doxytag: member="SimTK::Vec::operator+=" ref="a51cc4c59703b5544ac71bc5e57cc0b19" args="(const Vec&lt; M, negator&lt; EE &gt;, SS &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add in a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible. </p>
<p>The negation is removed at zero cost by subtracting rather than adding. </p>

</div>
</div>
<a class="anchor" id="a46b643762736321072c6bd58ba141841"></a><!-- doxytag: member="SimTK::Vec::operator&#45;=" ref="a46b643762736321072c6bd58ba141841" args="(const Vec&lt; M, EE, SS &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract off a conforming Vec, of any element type and stride, provided that the element types are addition-compatible. </p>

</div>
</div>
<a class="anchor" id="aee444801ca472095d6fc0ff1a103718f"></a><!-- doxytag: member="SimTK::Vec::operator&#45;=" ref="aee444801ca472095d6fc0ff1a103718f" args="(const Vec&lt; M, negator&lt; EE &gt;, SS &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract off a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible. </p>
<p>The negation is removed at zero cost by adding rather than subtracting. </p>

</div>
</div>
<a class="anchor" id="a82a4da394cb53cde9c5a63dc8a098f8d"></a><!-- doxytag: member="SimTK::Vec::conformingAdd" ref="a82a4da394cb53cde9c5a63dc8a098f8d" args="(const Vec&lt; M, EE, SS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Add&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a82a4da394cb53cde9c5a63dc8a098f8d">conformingAdd</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector addition -- use operator+ instead. </p>

</div>
</div>
<a class="anchor" id="a69d1a60f240f485bc1f9c844ec1cd733"></a><!-- doxytag: member="SimTK::Vec::conformingSubtract" ref="a69d1a60f240f485bc1f9c844ec1cd733" args="(const Vec&lt; M, EE, SS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Sub&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a69d1a60f240f485bc1f9c844ec1cd733">conformingSubtract</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector subtraction -- use operator- instead. </p>

</div>
</div>
<a class="anchor" id="a7a9702efd5be91edf3f06f0680303ec0"></a><!-- doxytag: member="SimTK::Vec::conformingMultiply" ref="a7a9702efd5be91edf3f06f0680303ec0" args="(const Row&lt; M, EE, SS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;M,M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Mul&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a7a9702efd5be91edf3f06f0680303ec0">conformingMultiply</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as outer product (m = col*row) -- use operator* or <a class="el" href="namespaceSimTK.html#a0fd293cad29bd6fa0405ccffca69c738">outer()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a5f554ca51a94f9cfa61a36b495478e5c"></a><!-- doxytag: member="SimTK::Vec::elementwiseMultiply" ref="a5f554ca51a94f9cfa61a36b495478e5c" args="(const Vec&lt; M, EE, SS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Mul&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f554ca51a94f9cfa61a36b495478e5c">elementwiseMultiply</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elementwise multiply (Matlab . </p>
<p>* operator). </p>

</div>
</div>
<a class="anchor" id="a3af4163f4d188bf82242584bf985ccb8"></a><!-- doxytag: member="SimTK::Vec::elementwiseDivide" ref="a3af4163f4d188bf82242584bf985ccb8" args="(const Vec&lt; M, EE, SS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Dvd&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3af4163f4d188bf82242584bf985ccb8">elementwiseDivide</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elementwise divide (Matlab . </p>
<p>/ operator). </p>

</div>
</div>
<a class="anchor" id="ab1ecf7f59bd4b7c6b9dfd67566b75449"></a><!-- doxytag: member="SimTK::Vec::operator[]" ref="ab1ecf7f59bd4b7c6b9dfd67566b75449" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select an element of this Vec and return a const reference to it. </p>
<p>This is range-checked in Debug builds but has zero overhead in Release builds. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1UnitVec.html#aead23834dad959044a95f503ce91857f">SimTK::UnitVec&lt; P, S &gt;</a>, and <a class="el" href="classSimTK_1_1UnitVec.html#aead23834dad959044a95f503ce91857f">SimTK::UnitVec&lt; Real, 1 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a32bc6a710c601343c9fe30e34c20b7bf"></a><!-- doxytag: member="SimTK::Vec::operator()" ref="a32bc6a710c601343c9fe30e34c20b7bf" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as const operator[] above. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1UnitVec.html#ab5fe83afff02a450c8a2139962787229">SimTK::UnitVec&lt; P, S &gt;</a>, and <a class="el" href="classSimTK_1_1UnitVec.html#ab5fe83afff02a450c8a2139962787229">SimTK::UnitVec&lt; Real, 1 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae44a011242e15a9188acf63a6625e6cc"></a><!-- doxytag: member="SimTK::Vec::operator[]" ref="ae44a011242e15a9188acf63a6625e6cc" args="(int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select an element of this Vec and return a writable reference to it. </p>
<p>This is range-checked in Debug builds but has zero overhead in Release builds. </p>

</div>
</div>
<a class="anchor" id="a2918c06d3f0b353076c5fa9ce8019509"></a><!-- doxytag: member="SimTK::Vec::operator()" ref="a2918c06d3f0b353076c5fa9ce8019509" args="(int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as non-const operator[] above. </p>

</div>
</div>
<a class="anchor" id="a95575b22850f63eaa64858660c8c8c64"></a><!-- doxytag: member="SimTK::Vec::normSqr" ref="a95575b22850f63eaa64858660c8c8c64" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a95575b22850f63eaa64858660c8c8c64">normSqr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bcb573b11b780148f1ff3e7f5961997"></a><!-- doxytag: member="SimTK::Vec::norm" ref="a5bcb573b11b780148f1ff3e7f5961997" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5bcb573b11b780148f1ff3e7f5961997">norm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abbd852b56584cfeda803eab3a95fb7db"></a><!-- doxytag: member="SimTK::Vec::normalize" ref="abbd852b56584cfeda803eab3a95fb7db" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#abbd852b56584cfeda803eab3a95fb7db">normalize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the elements of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> are scalars, the result is what you get by dividing each element by the <a class="el" href="classSimTK_1_1Vec.html#a5bcb573b11b780148f1ff3e7f5961997">norm()</a> calculated above. </p>
<p>If the elements are <em>not</em> scalars, then the elements are *separately* normalized. That means you will get a different answer from <a class="el" href="classSimTK_1_1Vec.html#abbd852b56584cfeda803eab3a95fb7db" title="If the elements of this Vec are scalars, the result is what you get by dividing each element by the n...">Vec&lt;2,Vec3&gt;::normalize()</a> than you would from a <a class="el" href="classSimTK_1_1Vec.html#abbd852b56584cfeda803eab3a95fb7db" title="If the elements of this Vec are scalars, the result is what you get by dividing each element by the n...">Vec&lt;6&gt;::normalize()</a> containing the same scalars.</p>
<p>Normalize returns a vector of the same dimension but in new, packed storage and with a return type that does not include negator&lt;&gt; even if the original Vec&lt;&gt; does, because we can eliminate the negation here almost for free. But we can't standardize (change conjugate to complex) for free, so we'll retain conjugates if there are any. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1Quaternion__.html#a3be8ddedc702dbb7f31e5fd49ed510d7">SimTK::Quaternion_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a66cea75e2ed6de1c379a46745849c473"></a><!-- doxytag: member="SimTK::Vec::invert" ref="a66cea75e2ed6de1c379a46745849c473" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a66cea75e2ed6de1c379a46745849c473">invert</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is not supported for Vec objects. </p>

</div>
</div>
<a class="anchor" id="ae28bb6b73abb3704de062f751dab4921"></a><!-- doxytag: member="SimTK::Vec::operator+" ref="ae28bb6b73abb3704de062f751dab4921" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unary plus does nothing. </p>

</div>
</div>
<a class="anchor" id="a1d18cd6340b717437a31770499069bfd"></a><!-- doxytag: member="SimTK::Vec::operator&#45;" ref="a1d18cd6340b717437a31770499069bfd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unary minus recasts this Vec to a type that has the opposite interpretation of the sign but is otherwise identical, so no computation or copying is performed here. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1UnitVec.html#abb186725a570af8edaf7e86529e900a0">SimTK::UnitVec&lt; P, S &gt;</a>, and <a class="el" href="classSimTK_1_1UnitVec.html#abb186725a570af8edaf7e86529e900a0">SimTK::UnitVec&lt; Real, 1 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a52644eefd67080b80bba767e5affceb8"></a><!-- doxytag: member="SimTK::Vec::operator&#45;" ref="a52644eefd67080b80bba767e5affceb8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast to negated type and return a writable reference; writing to this will cause the negated result to be placed in the original Vec. </p>

</div>
</div>
<a class="anchor" id="a4b82833142e2b30ae998f1ee357245b4"></a><!-- doxytag: member="SimTK::Vec::operator~" ref="a4b82833142e2b30ae998f1ee357245b4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a4b82833142e2b30ae998f1ee357245b4">operator~</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Hermitian transpose operator recasts this Vec to a type that specifies the opposite storage order (row vs. column) then returns a reference, so no computation or copying is performed here. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1UnitVec.html#ad22b166a41988289bc647e3015cc4703">SimTK::UnitVec&lt; P, S &gt;</a>, and <a class="el" href="classSimTK_1_1UnitVec.html#ad22b166a41988289bc647e3015cc4703">SimTK::UnitVec&lt; Real, 1 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a055c47346d5b16b0a7ced839b91a9aa4"></a><!-- doxytag: member="SimTK::Vec::operator~" ref="a055c47346d5b16b0a7ced839b91a9aa4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a4b82833142e2b30ae998f1ee357245b4">operator~</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast to Hermitian transposed type and return a writable reference; the effect is that writing to elements of the result affects the transposed element of the original Vec. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1UnitVec.html#a652eee30279596142606524844c66791">SimTK::UnitVec&lt; P, S &gt;</a>, and <a class="el" href="classSimTK_1_1UnitVec.html#a652eee30279596142606524844c66791">SimTK::UnitVec&lt; Real, 1 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a99e24a8076a1aed2b65595b0b382c71f"></a><!-- doxytag: member="SimTK::Vec::negate" ref="a99e24a8076a1aed2b65595b0b382c71f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a99e24a8076a1aed2b65595b0b382c71f">negate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-operator version of unary negation; just a recast. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1UnitVec.html#a8130a59a0dfb2dd589bdf44cf28f39bc">SimTK::UnitVec&lt; P, S &gt;</a>, and <a class="el" href="classSimTK_1_1UnitVec.html#a8130a59a0dfb2dd589bdf44cf28f39bc">SimTK::UnitVec&lt; Real, 1 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5108f85c423f5e00e51a198734ed17c3"></a><!-- doxytag: member="SimTK::Vec::updNegate" ref="a5108f85c423f5e00e51a198734ed17c3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5108f85c423f5e00e51a198734ed17c3">updNegate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-operator version of unary negation; recasts and returns a writable reference. </p>

</div>
</div>
<a class="anchor" id="a3eb9d7c001c9594fd65c50365dce0d5c"></a><!-- doxytag: member="SimTK::Vec::transpose" ref="a3eb9d7c001c9594fd65c50365dce0d5c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3eb9d7c001c9594fd65c50365dce0d5c">transpose</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-operator version of Hermitian transpose; just a recast. </p>

</div>
</div>
<a class="anchor" id="a3e181c0844930d9dbec8afb613f762d7"></a><!-- doxytag: member="SimTK::Vec::updTranspose" ref="a3e181c0844930d9dbec8afb613f762d7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3e181c0844930d9dbec8afb613f762d7">updTranspose</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-operator version of Hermitian transpose; recasts and returns a writable reference. </p>

</div>
</div>
<a class="anchor" id="a1e92208963211edbb39751c128310a0e"></a><!-- doxytag: member="SimTK::Vec::positionalTranspose" ref="a1e92208963211edbb39751c128310a0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1e92208963211edbb39751c128310a0e">positionalTranspose</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positional transpose turns this Vec into a <a class="el" href="classSimTK_1_1Row.html" title="Generic Row.">Row</a> but does not transpose the individual elements. </p>
<p>That is, a <a class="el" href="classSimTK_1_1Vec.html">Vec&lt;2,Vec3&gt;</a> becomes a Row&lt;2,Vec3&gt;, rather than a Row&lt;2,Row3&gt; as would happen with ordinary <a class="el" href="classSimTK_1_1Vec.html#a3eb9d7c001c9594fd65c50365dce0d5c" title="Non-operator version of Hermitian transpose; just a recast.">transpose()</a>. This is just a recast; no copying or computation is performed here. </p>

</div>
</div>
<a class="anchor" id="a6021a62d22537c7ad406b7a1c1ca0761"></a><!-- doxytag: member="SimTK::Vec::updPositionalTranspose" ref="a6021a62d22537c7ad406b7a1c1ca0761" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6021a62d22537c7ad406b7a1c1ca0761">updPositionalTranspose</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positional transpose returning a writable reference. </p>

</div>
</div>
<a class="anchor" id="ac891ea80a0181132c2430a349f461d72"></a><!-- doxytag: member="SimTK::Vec::real" ref="ac891ea80a0181132c2430a349f461d72" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac891ea80a0181132c2430a349f461d72">real</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the real portion of this Vec if it has complex elements; otherwise the type doesn't change. </p>
<p>This is just a recast; no copying or computation is done here. The result may have a different stride than the original since the imaginary parts must be skipped. </p>

</div>
</div>
<a class="anchor" id="adc792ec3e435535fc8fe4ad3810d54fe"></a><!-- doxytag: member="SimTK::Vec::real" ref="adc792ec3e435535fc8fe4ad3810d54fe" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac891ea80a0181132c2430a349f461d72">real</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast to show only the real portion of this Vec and return a writable reference. </p>

</div>
</div>
<a class="anchor" id="aff885dcf7ea01c94d7621be973fd1aa9"></a><!-- doxytag: member="SimTK::Vec::imag" ref="aff885dcf7ea01c94d7621be973fd1aa9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aff885dcf7ea01c94d7621be973fd1aa9">imag</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the imaginary portion of this Vec if it has complex elements; otherwise the type doesn't change. </p>
<p>This is just a recast; no copying or computation is done here. The result may have a different stride than the original since the real parts must be skipped. </p>

</div>
</div>
<a class="anchor" id="a4b3ecf2380f493c8b48ad6d0d50695f8"></a><!-- doxytag: member="SimTK::Vec::imag" ref="a4b3ecf2380f493c8b48ad6d0d50695f8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aff885dcf7ea01c94d7621be973fd1aa9">imag</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast to show only the imaginary portion of this Vec and return a writable reference. </p>

</div>
</div>
<a class="anchor" id="a9283ff051541b8f511d748f862f1eb9b"></a><!-- doxytag: member="SimTK::Vec::castAwayNegatorIfAny" ref="a9283ff051541b8f511d748f862f1eb9b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a9283ff051541b8f511d748f862f1eb9b">castAwayNegatorIfAny</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast to remove negators from this Vec's type if present; this is handy for simplifying operations where we know the sign can be ignored such as squaring. </p>

</div>
</div>
<a class="anchor" id="a2467300a636639eb7195ca7ea37d5ee8"></a><!-- doxytag: member="SimTK::Vec::updCastAwayNegatorIfAny" ref="a2467300a636639eb7195ca7ea37d5ee8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a2467300a636639eb7195ca7ea37d5ee8">updCastAwayNegatorIfAny</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast to remove negators from this Vec's type if present and return a writable reference. </p>

</div>
</div>
<a class="anchor" id="a37b496ee9a8f41defa3250da5ed0014e"></a><!-- doxytag: member="SimTK::Vec::scalarMultiply" ref="a37b496ee9a8f41defa3250da5ed0014e" args="(const EE &amp;e) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Mul&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a37b496ee9a8f41defa3250da5ed0014e">scalarMultiply</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a314e384e0d1cc1077562131cb7a773a2"></a><!-- doxytag: member="SimTK::Vec::scalarMultiplyFromLeft" ref="a314e384e0d1cc1077562131cb7a773a2" args="(const EE &amp;e) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;EE&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::Mul&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a314e384e0d1cc1077562131cb7a773a2">scalarMultiplyFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a97a9b3263e294d85755e4c777302c2ae"></a><!-- doxytag: member="SimTK::Vec::scalarDivide" ref="a97a9b3263e294d85755e4c777302c2ae" args="(const EE &amp;e) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Dvd&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a97a9b3263e294d85755e4c777302c2ae">scalarDivide</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a34606c49af85f3f3b54341b54815cf25"></a><!-- doxytag: member="SimTK::Vec::scalarDivideFromLeft" ref="a34606c49af85f3f3b54341b54815cf25" args="(const EE &amp;e) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;EE&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::Dvd&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a34606c49af85f3f3b54341b54815cf25">scalarDivideFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a474088f0218a89d4116358da2ced4fcc"></a><!-- doxytag: member="SimTK::Vec::scalarAdd" ref="a474088f0218a89d4116358da2ced4fcc" args="(const EE &amp;e) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Add&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a474088f0218a89d4116358da2ced4fcc">scalarAdd</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69fc2003203268bcd10f9eadf9412695"></a><!-- doxytag: member="SimTK::Vec::scalarSubtract" ref="a69fc2003203268bcd10f9eadf9412695" args="(const EE &amp;e) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Sub&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a69fc2003203268bcd10f9eadf9412695">scalarSubtract</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ee50b918ae4eefc8c8ac1a177d7f7c9"></a><!-- doxytag: member="SimTK::Vec::scalarSubtractFromLeft" ref="a5ee50b918ae4eefc8c8ac1a177d7f7c9" args="(const EE &amp;e) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;EE&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::Sub&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5ee50b918ae4eefc8c8ac1a177d7f7c9">scalarSubtractFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aace53cca908837b6b13de05a6bbda540"></a><!-- doxytag: member="SimTK::Vec::operator=" ref="aace53cca908837b6b13de05a6bbda540" args="(const EE &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d6459937f78236c913e2ec50d328d8d"></a><!-- doxytag: member="SimTK::Vec::operator+=" ref="a6d6459937f78236c913e2ec50d328d8d" args="(const EE &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b247dbd3a71bdcef1a0a4af1cece4c7"></a><!-- doxytag: member="SimTK::Vec::operator&#45;=" ref="a4b247dbd3a71bdcef1a0a4af1cece4c7" args="(const EE &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c865e00508d708562c21012f0cb66e1"></a><!-- doxytag: member="SimTK::Vec::operator*=" ref="a1c865e00508d708562c21012f0cb66e1" args="(const EE &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a273abdf63fc3f9e8d720b6b1c9ebd047"></a><!-- doxytag: member="SimTK::Vec::operator/=" ref="a273abdf63fc3f9e8d720b6b1c9ebd047" args="(const EE &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a47cc5ea1fc0e6db75f4fe78c85772179"></a><!-- doxytag: member="SimTK::Vec::scalarEq" ref="a47cc5ea1fc0e6db75f4fe78c85772179" args="(const EE &amp;ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a47cc5ea1fc0e6db75f4fe78c85772179">scalarEq</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d9a9f23aeaf38da791ec0173f5b49d8"></a><!-- doxytag: member="SimTK::Vec::scalarPlusEq" ref="a7d9a9f23aeaf38da791ec0173f5b49d8" args="(const EE &amp;ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a7d9a9f23aeaf38da791ec0173f5b49d8">scalarPlusEq</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af1ecc870150f4bbaddacf812bf3a55a4"></a><!-- doxytag: member="SimTK::Vec::scalarMinusEq" ref="af1ecc870150f4bbaddacf812bf3a55a4" args="(const EE &amp;ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af1ecc870150f4bbaddacf812bf3a55a4">scalarMinusEq</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a11d049de83f163743bc576395746f0e6"></a><!-- doxytag: member="SimTK::Vec::scalarMinusEqFromLeft" ref="a11d049de83f163743bc576395746f0e6" args="(const EE &amp;ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a11d049de83f163743bc576395746f0e6">scalarMinusEqFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af8f25b932993267cacda311724882b90"></a><!-- doxytag: member="SimTK::Vec::scalarTimesEq" ref="af8f25b932993267cacda311724882b90" args="(const EE &amp;ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af8f25b932993267cacda311724882b90">scalarTimesEq</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1549f7c02c5f35b6ae02f3a384ba0461"></a><!-- doxytag: member="SimTK::Vec::scalarTimesEqFromLeft" ref="a1549f7c02c5f35b6ae02f3a384ba0461" args="(const EE &amp;ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1549f7c02c5f35b6ae02f3a384ba0461">scalarTimesEqFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ec0b452d52d289345c333b6b1f61c1b"></a><!-- doxytag: member="SimTK::Vec::scalarDivideEq" ref="a5ec0b452d52d289345c333b6b1f61c1b" args="(const EE &amp;ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5ec0b452d52d289345c333b6b1f61c1b">scalarDivideEq</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68d6c34551dd57324842f2e630ac5798"></a><!-- doxytag: member="SimTK::Vec::scalarDivideEqFromLeft" ref="a68d6c34551dd57324842f2e630ac5798" args="(const EE &amp;ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a68d6c34551dd57324842f2e630ac5798">scalarDivideEqFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18982d1fac249ed0050b0497fc1b5fff"></a><!-- doxytag: member="SimTK::Vec::scalarEq" ref="a18982d1fac249ed0050b0497fc1b5fff" args="(int ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a47cc5ea1fc0e6db75f4fe78c85772179">scalarEq</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e47b406661090c6bbb580bb32f613b6"></a><!-- doxytag: member="SimTK::Vec::scalarPlusEq" ref="a6e47b406661090c6bbb580bb32f613b6" args="(int ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a7d9a9f23aeaf38da791ec0173f5b49d8">scalarPlusEq</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab402c2238f2821d55a97dcdfb36ad0ba"></a><!-- doxytag: member="SimTK::Vec::scalarMinusEq" ref="ab402c2238f2821d55a97dcdfb36ad0ba" args="(int ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af1ecc870150f4bbaddacf812bf3a55a4">scalarMinusEq</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7bba57628dc553c6155205ba7ebd0330"></a><!-- doxytag: member="SimTK::Vec::scalarTimesEq" ref="a7bba57628dc553c6155205ba7ebd0330" args="(int ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af8f25b932993267cacda311724882b90">scalarTimesEq</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeafb7930483190b14571c043ccb33ce0"></a><!-- doxytag: member="SimTK::Vec::scalarDivideEq" ref="aeafb7930483190b14571c043ccb33ce0" args="(int ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5ec0b452d52d289345c333b6b1f61c1b">scalarDivideEq</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab07b8dc8c7690f71f6a2a7232c06f8b9"></a><!-- doxytag: member="SimTK::Vec::scalarMinusEqFromLeft" ref="ab07b8dc8c7690f71f6a2a7232c06f8b9" args="(int ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a11d049de83f163743bc576395746f0e6">scalarMinusEqFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a695383084e4311219d9c1d86330bc3fa"></a><!-- doxytag: member="SimTK::Vec::scalarTimesEqFromLeft" ref="a695383084e4311219d9c1d86330bc3fa" args="(int ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1549f7c02c5f35b6ae02f3a384ba0461">scalarTimesEqFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a45beaad82e2504367de24345f1b7f60c"></a><!-- doxytag: member="SimTK::Vec::scalarDivideEqFromLeft" ref="a45beaad82e2504367de24345f1b7f60c" args="(int ee)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a68d6c34551dd57324842f2e630ac5798">scalarDivideEqFromLeft</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b11014a0ad910e4254a26d39f013565"></a><!-- doxytag: member="SimTK::Vec::setToNaN" ref="a0b11014a0ad910e4254a26d39f013565" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a0b11014a0ad910e4254a26d39f013565">setToNaN</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set every scalar in this Vec to NaN; this is the default initial value in Debug builds, but not in Release. </p>

</div>
</div>
<a class="anchor" id="a25018475a82b7f1c61956d824104b300"></a><!-- doxytag: member="SimTK::Vec::setToZero" ref="a25018475a82b7f1c61956d824104b300" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a25018475a82b7f1c61956d824104b300">setToZero</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set every scalar in this Vec to zero. </p>

</div>
</div>
<a class="anchor" id="aba184e5623fcecb388ab58eb91232052"></a><!-- doxytag: member="SimTK::Vec::getSubVec" ref="aba184e5623fcecb388ab58eb91232052" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int MM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;MM,ELT,STRIDE&gt;&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aba184e5623fcecb388ab58eb91232052">getSubVec</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a const reference to a sub-Vec with size known at compile time. </p>
<p>This must be called with an explicit template argument for the size, for example, getSubVec&lt;3&gt;(i). This is only a recast; no copying or computation is performed. The size and index are range checked in Debug builds but not in Release builds. </p>

</div>
</div>
<a class="anchor" id="a085715471acf42722ddd05eb8028e13c"></a><!-- doxytag: member="SimTK::Vec::updSubVec" ref="a085715471acf42722ddd05eb8028e13c" args="(int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int MM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;MM,ELT,STRIDE&gt;&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a085715471acf42722ddd05eb8028e13c">updSubVec</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a writable reference to a sub-Vec with size known at compile time. </p>
<p>This must be called with an explicit template argument for the size, for example, updSubVec&lt;3&gt;(i). This is only a recast; no copying or computation is performed. The size and index are range checked in Debug builds but not in Release builds. </p>

</div>
</div>
<a class="anchor" id="a250ac248ba601828531ca324917dc3ef"></a><!-- doxytag: member="SimTK::Vec::getSubVec" ref="a250ac248ba601828531ca324917dc3ef" args="(const Vec&lt; MM, ELT, STRIDE &gt; &amp;v, int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int MM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aba184e5623fcecb388ab58eb91232052">getSubVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a const reference to the selected subsequence. </p>

</div>
</div>
<a class="anchor" id="a6c3d2b34d4c58321ddd8ebbc997877dc"></a><!-- doxytag: member="SimTK::Vec::updSubVec" ref="a6c3d2b34d4c58321ddd8ebbc997877dc" args="(Vec&lt; MM, ELT, STRIDE &gt; &amp;v, int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int MM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a085715471acf42722ddd05eb8028e13c">updSubVec</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a writable reference to the selected subsequence. </p>

</div>
</div>
<a class="anchor" id="aa0b31ae5026f2529651aeaad88d705b1"></a><!-- doxytag: member="SimTK::Vec::drop1" ref="aa0b31ae5026f2529651aeaad88d705b1" args="(int p) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M-1,ELT,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aa0b31ae5026f2529651aeaad88d705b1">drop1</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a vector one smaller than this one by dropping the element at the indicated position p. </p>
<p>The result is a packed copy with the same element type as this one. </p>

</div>
</div>
<a class="anchor" id="acc5b268f14abe92735185cafadd888dc"></a><!-- doxytag: member="SimTK::Vec::append1" ref="acc5b268f14abe92735185cafadd888dc" args="(const EE &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M+1,ELT,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#acc5b268f14abe92735185cafadd888dc">append1</a> </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a vector one larger than this one by adding an element to the end. </p>
<p>The result is a packed copy with the same element type as this one. Works for any assignment compatible element. </p>

</div>
</div>
<a class="anchor" id="a19c8f4c92e03d90c4ec80644fb3d7bdc"></a><!-- doxytag: member="SimTK::Vec::insert1" ref="a19c8f4c92e03d90c4ec80644fb3d7bdc" args="(int p, const EE &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M+1,ELT,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a19c8f4c92e03d90c4ec80644fb3d7bdc">insert1</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a vector one larger than this one by inserting an element <em>before</em> the indicated one. </p>
<p>The result is a packed copy with the same element type as this one. Works for any assignment compatible element. The index can be one greater than normally allowed in which case the element is appended (but use <a class="el" href="classSimTK_1_1Vec.html#acc5b268f14abe92735185cafadd888dc" title="Return a vector one larger than this one by adding an element to the end.">append1()</a> if you know you're appending). </p>

</div>
</div>
<a class="anchor" id="abf8283cc8bb6cccd44287e439811198d"></a><!-- doxytag: member="SimTK::Vec::getAs" ref="abf8283cc8bb6cccd44287e439811198d" args="(const ELT *p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#abf8283cc8bb6cccd44287e439811198d">getAs</a> </td>
          <td>(</td>
          <td class="paramtype">const ELT *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast an ordinary C++ array E[] to a const Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing. </p>

<p>Reimplemented in <a class="el" href="classSimTK_1_1UnitVec.html#a6ccf84f7c5c7cdd2c968750e047a0c6e">SimTK::UnitVec&lt; P, S &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="affb89a98c7696e0a5fa04a17924e19f7"></a><!-- doxytag: member="SimTK::Vec::updAs" ref="affb89a98c7696e0a5fa04a17924e19f7" args="(ELT *p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#affb89a98c7696e0a5fa04a17924e19f7">updAs</a> </td>
          <td>(</td>
          <td class="paramtype">ELT *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast a writable ordinary C++ array E[] to a writable Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing. </p>

</div>
</div>
<a class="anchor" id="ade1b06280e2190f1d4317a04355f12ee"></a><!-- doxytag: member="SimTK::Vec::getNaN" ref="ade1b06280e2190f1d4317a04355f12ee" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,ELT,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ade1b06280e2190f1d4317a04355f12ee">getNaN</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a Vec of the same length and element type as this one but with all elements set to NaN. </p>
<p>The result is packed (stride==1) regardless of the stride of this Vec. </p>

</div>
</div>
<a class="anchor" id="aee785192d37052d76ff80d62338a6302"></a><!-- doxytag: member="SimTK::Vec::isNaN" ref="aee785192d37052d76ff80d62338a6302" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aee785192d37052d76ff80d62338a6302">isNaN</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if any element of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> contains a NaN anywhere. </p>

</div>
</div>
<a class="anchor" id="aa92ef2895e51a3ff4f1a3c264012c4ad"></a><!-- doxytag: member="SimTK::Vec::isInf" ref="aa92ef2895e51a3ff4f1a3c264012c4ad" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aa92ef2895e51a3ff4f1a3c264012c4ad">isInf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if any element of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> contains a +Infinity or -Infinity somewhere but no element contains a NaN anywhere. </p>

</div>
</div>
<a class="anchor" id="a1a0574822d6633f8b621d9c676a4352a"></a><!-- doxytag: member="SimTK::Vec::isFinite" ref="a1a0574822d6633f8b621d9c676a4352a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1a0574822d6633f8b621d9c676a4352a">isFinite</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if no element of this Vec contains an Infinity or a NaN anywhere. </p>

</div>
</div>
<a class="anchor" id="a781827a50ebc3d83a0736738bc2e2784"></a><!-- doxytag: member="SimTK::Vec::getDefaultTolerance" ref="a781827a50ebc3d83a0736738bc2e2784" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For approximate comparisions, the default tolerance to use for a vector is the same as its elements' default tolerance. </p>

</div>
</div>
<a class="anchor" id="a862a6d93b3109965ce7104c6beae5de6"></a><!-- doxytag: member="SimTK::Vec::isNumericallyEqual" ref="a862a6d93b3109965ce7104c6beae5de6" args="(const Vec&lt; M, E2, RS2 &gt; &amp;v, double tol) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class E2 , int RS2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a862a6d93b3109965ce7104c6beae5de6">isNumericallyEqual</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether this vector is numerically equal to some other vector with the same shape, using a specified tolerance. </p>

</div>
</div>
<a class="anchor" id="a596116b98d5d15f0112d1e052f09aeab"></a><!-- doxytag: member="SimTK::Vec::isNumericallyEqual" ref="a596116b98d5d15f0112d1e052f09aeab" args="(const Vec&lt; M, E2, RS2 &gt; &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class E2 , int RS2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a862a6d93b3109965ce7104c6beae5de6">isNumericallyEqual</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether this vector is numerically equal to some other vector with the same shape, using a default tolerance which is the looser of the default tolerances of the two objects being compared. </p>

</div>
</div>
<a class="anchor" id="a576e2e126e4f3bb2f59dc91ef1fbcfc4"></a><!-- doxytag: member="SimTK::Vec::isNumericallyEqual" ref="a576e2e126e4f3bb2f59dc91ef1fbcfc4" args="(const ELT &amp;e, double tol=getDefaultTolerance()) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a862a6d93b3109965ce7104c6beae5de6">isNumericallyEqual</a> </td>
          <td>(</td>
          <td class="paramtype">const ELT &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether every element of this vector is numerically equal to the given element, using either a specified tolerance or the vector's default tolerance (which is always the same or looser than the default tolerance for one of its elements). </p>

</div>
</div>
<a class="anchor" id="aa71ef634c8bcf182405248a215acb789"></a><!-- doxytag: member="SimTK::Vec::toString" ref="aa71ef634c8bcf182405248a215acb789" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aa71ef634c8bcf182405248a215acb789">toString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed length column vector designed for no-overhead inline computation.">Vec</a> into a string and return it. </p>
<p>Please refer to operator&lt;&lt; for details. </p>

</div>
</div>
<a class="anchor" id="a907c5d98e3f7b29f858c5f56c6e38738"></a><!-- doxytag: member="SimTK::Vec::set" ref="a907c5d98e3f7b29f858c5f56c6e38738" args="(int i, const E &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a907c5d98e3f7b29f858c5f56c6e38738">set</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variant of operator[] that's scripting friendly to set ith entry. </p>

</div>
</div>
<a class="anchor" id="a8bc57b3dd6983c252b3654a4d6548f05"></a><!-- doxytag: member="SimTK::Vec::get" ref="a8bc57b3dd6983c252b3654a4d6548f05" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a8bc57b3dd6983c252b3654a4d6548f05">get</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variant of operator[] that's scripting friendly to get const reference to ith entry. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Vec_8h_source.html">Vec.h</a></li>
<li><a class="el" href="Serialize_8h_source.html">Serialize.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>      </li>

    <li class="footer">Generated on Wed Oct 9 2013 08:39:03 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
