<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::Xml::Element Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1Xml_1_1Element.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Xml::Element Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::Xml::Element" --><!-- doxytag: inherits="SimTK::Xml::Node" -->
<p>An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of child nodes.  
 <a href="classSimTK_1_1Xml_1_1Element.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Xml_8h_source.html">Xml.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Xml::Element:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Xml_1_1Element.png" usemap="#SimTK::Xml::Element_map" alt=""/>
  <map id="SimTK::Xml::Element_map" name="SimTK::Xml::Element_map">
<area href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree." alt="SimTK::Xml::Node" shape="rect" coords="0,0,124,24"/>
</map>
 </div></div>

<p><a href="classSimTK_1_1Xml_1_1Element-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>As discussed elsewhere, elements come in two varieties: value elements and compound elements.</p>
<p>New value elements can be created easily since they are essentially just a name,value pair. Compound elements require a series of method calls to create the <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> node and then add child nodes to it. In either case you may want to add attributes also. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ace92fc2051430e6dc12eec23135bc409">Element</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle; this is suitable only for holding references to other Elements.  <a href="#ace92fc2051430e6dc12eec23135bc409"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab436c4a5dd786608a8083cae30a93388">Element</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tagWord, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a value element that uses the given tag word but is not yet part of any XML document, and optionally give it an inital value.  <a href="#ab436c4a5dd786608a8083cae30a93388"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aeeea0c8fd0fe18efb95f2907ac055451">Element</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tagWord, const T &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new value element and set its initial value to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists).  <a href="#aeeea0c8fd0fe18efb95f2907ac055451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaa31891cf84e151e7657630ef628fcd4">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaa31891cf84e151e7657630ef628fcd4" title="The clone() method makes a deep copy of this Element and its children and returns a new orphan Elemen...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> with the same contents; ordinary assignment and copy construction are shallow.  <a href="#aaa31891cf84e151e7657630ef628fcd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6bffec933fcbf26da23323fe35eaf448">getElementTag</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element tag word.  <a href="#a6bffec933fcbf26da23323fe35eaf448"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6b5bf3c6e351f7dd9afa52fcff07af52">setElementTag</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the tag word that is used to bracket this element.  <a href="#a6b5bf3c6e351f7dd9afa52fcff07af52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a4e79c09e3f397a48c65f40f86d113664">insertNodeBefore</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;pos, <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just before the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>).  <a href="#a4e79c09e3f397a48c65f40f86d113664"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9bdc6b7182e6308f1bd9e08c830566b9">insertNodeAfter</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;pos, <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just after the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>).  <a href="#a9bdc6b7182e6308f1bd9e08c830566b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ac3822acf6439f7b502ef0d6778ede972">eraseNode</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;deleteThis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the indicated node, which must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>.  <a href="#ac3822acf6439f7b502ef0d6778ede972"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#afd5b6dd8506bfb5221631df7dad4de4d">removeNode</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;removeThis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the indicated node from this element without erasing it, returning it as an orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>.  <a href="#afd5b6dd8506bfb5221631df7dad4de4d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Value elements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>As described elsewhere, value elements are those that have no child elements and only a single <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> node, whose contents can be considered as the element's value.</p>
<p>Methods in this section allow you to work conveniently with value elements, getting direct access to the value string or interpreting it as some other type. You can easily modify the value by obtaining a writable refence to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> object that holds it. We provide methods for working with this element's value (if it is a value element) and with an element's children's values (if this element is compound). </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66">isValueElement</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this element qualifies as a "value element", defined as an element containing zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> nodes and no child elements.  <a href="#aae65d97f9b00e4418d5602e77bb5fb66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce">getValue</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of this value element.  <a href="#ab42eeb91fc1f6d3ad570d0db925870ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d">updValue</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a writable reference to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> containing the value of this value element.  <a href="#a6fbe1243e8e2e83ceb3925659181065d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238">setValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the text value of this value element.  <a href="#a87d99f6f31da37e122ee14dcb7281238"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4">setValueAs</a> (const T &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of this value element to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists).  <a href="#a03fd52a31abb8f1626d7902c747b02d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec">getValueAs</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming this is a "value element", convert its text value to the type of the template argument T.  <a href="#a3250133e91118e41e46f925f05556cec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a665fafcd7535ac1db55c9ed81caea4c3">getValueAs</a> (T &amp;out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate form of <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs()</a> that avoids unnecessary copying and heap allocation for reading in large container objects.  <a href="#a665fafcd7535ac1db55c9ed81caea4c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af527410d9e2b0483da3b7384d8c497ec">getRequiredElementValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of a child value element that <em>must</em> be present in this element.  <a href="#af527410d9e2b0483da3b7384d8c497ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaeeab5895d7485590ab1fec6177c7a91">getOptionalElementValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;def=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of a child value element that <em>may</em> be present in this element, otherwise return a default string.  <a href="#aaeeab5895d7485590ab1fec6177c7a91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#acd51b037e620848e76d1591cdb26a457">getRequiredElementValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of a required child value element to the type of the template argument T.  <a href="#acd51b037e620848e76d1591cdb26a457"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a2bf04099eb57a7ce81de228ba6b2c034">getOptionalElementValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag, const T &amp;def) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of an optional child value element, if present, to the type of the template argument T.  <a href="#a2bf04099eb57a7ce81de228ba6b2c034"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Attributes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can add, modify, and remove element attributes with the methods in this section.</p>
<p>You can work directly with individual attributes by name, or you can iterate through the list of attributes. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab6545733fba05a6349cee654d8d2167b">hasAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this element has an attribute of this name.  <a href="#ab6545733fba05a6349cee654d8d2167b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a8c04ffb38dc3e908fd559c7c542ad559">setAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an attribute of this element, creating a new one if this is a new attribute name otherwise modifying an existing one.  <a href="#a8c04ffb38dc3e908fd559c7c542ad559"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03e4d7a877ad3a514412e78e3efc6ce7">eraseAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an attribute of this element if it exists, otherwise do nothing.  <a href="#a03e4d7a877ad3a514412e78e3efc6ce7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a65d6cb52b56efd3d9a1202ac827e1812">getRequiredAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an attribute as a string and throw an error if that attribute is not present.  <a href="#a65d6cb52b56efd3d9a1202ac827e1812"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a12c6820ae4a6507752eefd1ea960fd46">getRequiredAttributeValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of a required attribute to the type of the template argument T.  <a href="#a12c6820ae4a6507752eefd1ea960fd46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae54dacef8bea4acac95a89ce5aefb44d">getOptionalAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;def=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an attribute as a string if the attribute is present in this element, otherwise return a supplied default value.  <a href="#ae54dacef8bea4acac95a89ce5aefb44d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a24d8bc6dc30f3d97af5a393a7b057b83">getOptionalAttributeValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const T &amp;def) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the value of an optional attribute, if present, from a string to the type of the template argument T.  <a href="#a24d8bc6dc30f3d97af5a393a7b057b83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad904c330f4cec26a4e5793bed0441445">getRequiredAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element; an error will be thrown if no such attribute is present.  <a href="#ad904c330f4cec26a4e5793bed0441445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aacd827d22b75b6202b7461b2ab90ddeb">getOptionalAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element specified by name, or an empty handle if no such attribute is present.  <a href="#aacd827d22b75b6202b7461b2ab90ddeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a34d797fd21a8b3d851616dc8d00241a6">getAllAttributes</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handles referencing all the attributes of this element.  <a href="#a34d797fd21a8b3d851616dc8d00241a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a2e80bd8d9c3421ba9d1113579f9acf47">attribute_begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through all the attributes of this element.  <a href="#a2e80bd8d9c3421ba9d1113579f9acf47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c">attribute_end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c" title="This attribute_end() iterator indicates the end of a sequence of attributes.">attribute_end()</a> iterator indicates the end of a sequence of attributes.  <a href="#ab4ba2c678473eaab3218db79e67e671c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Compound elements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Many elements contain child nodes, including other elements.</p>
<p>When there is just a single child <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> node and no child elements, we call the element a "value element" and it is easiest to work with using the methods in the "Value elements" section. When there are child elements and/or multiple <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> nodes, the element is called a "compound element" and you need a way to iterate and recurse through its contents. The methods in this section support looking through all contained nodes, nodes of specified types, element nodes, or element nodes with a specified tags. You can obtain handles to child Nodes or Elements and then iterate through those recursively. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af295f46c76adc5bbdfac98b6f1a80b82">hasElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this element has a child element with this tag.  <a href="#af295f46c76adc5bbdfac98b6f1a80b82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1495f916a3d8924d4ead80592c2034ce">hasNode</a> (<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See if this element has any child nodes, or any child nodes of the type(s) allowed by the NodeType filter if one is supplied.  <a href="#a1495f916a3d8924d4ead80592c2034ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1ee99cd86e3e413234c7b4bf9e2d5bf6">getRequiredElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a child element that <em>must</em> be present in this element.  <a href="#a1ee99cd86e3e413234c7b4bf9e2d5bf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3772785ece91bcccba9da75e89eecbdd">getOptionalElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a child element that <em>may</em> be present in this element; otherwise return an invalid <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle.  <a href="#a3772785ece91bcccba9da75e89eecbdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af9c43f8749c9def7a0b65136e8fc1329">getAllElements</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handles referencing all the immediate child elements contained in this element, or all the child elements of a particular type (that is, with a given tag word).  <a href="#af9c43f8749c9def7a0b65136e8fc1329"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a60f0a78da097f84bf67bef22bb5b5372">getAllNodes</a> (<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> handles referencing all the immediate child nodes contained in this element, or all the child nodes of a particular type or types.  <a href="#a60f0a78da097f84bf67bef22bb5b5372"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a8f9e8c86fb08bd3c0ffd397e0186acb0">element_begin</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through the immediate child elements of this element, or the child elements that have the indicated tag if one is supplied.  <a href="#a8f9e8c86fb08bd3c0ffd397e0186acb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2">element_end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a> iterator indicates the end of any sequence of elements regardless of the tag restriction on the iterator being used.  <a href="#a7c1f3e8fced7b1bb5b081b9cb5af9fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9d3c5ff58a4653ffac14b19447f8c718">node_begin</a> (<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through the immediate child nodes of this element, or the child nodes of the type(s) allowed by the NodeType filter if one is supplied.  <a href="#a9d3c5ff58a4653ffac14b19447f8c718"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790">node_end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a> iterator indicates the end of any sequence of nodes regardless of the NodeType restriction on the iterator being used.  <a href="#aad74f7074ef8b528f9e9ac5fed950790"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion to Element from Node</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If you have a handle to a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>, such as would be returned by a <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>, you can check whether that <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> is an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and if so cast it to one.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521">isA</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing.">Test</a> whether a given <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> is an element node.  <a href="#a569474bd297296231c6078cc050a8521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a869b394c523a22dc160a5990850457e3">getAs</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> to a const <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> is not actually an element node.  <a href="#a869b394c523a22dc160a5990850457e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad15f74e7946e1abb0026eff29803cbd2">getAs</a> (<a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a writable <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> to a writable <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> is not actually an element node.  <a href="#ad15f74e7946e1abb0026eff29803cbd2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aee787d4b6e5639c308b632173814ece7">Xml::Node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad4ee202f3a1549ce45c613ddce919565">Xml::element_iterator</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of child nodes. </p>
<p>The tag word, which begins with an underscore or a letter, can serve as either the type or the name of the element depending on context. The nodes can be comments, unknowns, text, and child elements (recursively). It is common for "leaf" elements (elements with no child elements) to be supplied simply for their values, for example mass might be provided via an element "&lt;mass&gt; 29.3 &lt;/mass&gt;". We call such elements "value
elements" since they have a uniquely identifiable value similar to that of attributes. Value elements have no more than one text node. They may have attributes, and may also have comment and unknown nodes but they cannot have any child elements. This class provides a special set of methods for dealing with value nodes very conveniently; they will fail if you attempt to use them on an element that is not a value element. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ace92fc2051430e6dc12eec23135bc409"></a><!-- doxytag: member="SimTK::Xml::Element::Element" ref="ace92fc2051430e6dc12eec23135bc409" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ace92fc2051430e6dc12eec23135bc409">SimTK::Xml::Element::Element</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle; this is suitable only for holding references to other Elements. </p>

</div>
</div>
<a class="anchor" id="ab436c4a5dd786608a8083cae30a93388"></a><!-- doxytag: member="SimTK::Xml::Element::Element" ref="ab436c4a5dd786608a8083cae30a93388" args="(const String &amp;tagWord, const String &amp;value=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ace92fc2051430e6dc12eec23135bc409">SimTK::Xml::Element::Element</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tagWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a value element that uses the given tag word but is not yet part of any XML document, and optionally give it an inital value. </p>
<p>Note that although you provide the initial value as a string, you can access it as any type T to which that string can be converted, using the <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs&lt;T&gt;()</a> templatized method.</p>
<p>If no initial value is provided, then the element will be empty so would print as "&lt;tagWord /&gt;". If you provide a value (say "contents") here or add one later, it will print as "&lt;tagWord&gt;contents&lt;/tagWord&gt;". In general you can add child elements and other node types with subsequent method calls; that would change this element from a value element to a compound element. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce" title="Get the text value of this value element.">getValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d" title="Obtain a writable reference to the String containing the value of this value element.">updValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238" title="Set the text value of this value element.">setValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeeea0c8fd0fe18efb95f2907ac055451"></a><!-- doxytag: member="SimTK::Xml::Element::Element" ref="aeeea0c8fd0fe18efb95f2907ac055451" args="(const String &amp;tagWord, const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ace92fc2051430e6dc12eec23135bc409">SimTK::Xml::Element::Element</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tagWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new value element and set its initial value to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs&lt;T&gt;()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4" title="Set the value of this value element to the text equivalent of any type T for which a conversion const...">setValueAs&lt;T&gt;()</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aaa31891cf84e151e7657630ef628fcd4"></a><!-- doxytag: member="SimTK::Xml::Element::clone" ref="aaa31891cf84e151e7657630ef628fcd4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaa31891cf84e151e7657630ef628fcd4">SimTK::Xml::Element::clone</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaa31891cf84e151e7657630ef628fcd4" title="The clone() method makes a deep copy of this Element and its children and returns a new orphan Elemen...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> with the same contents; ordinary assignment and copy construction are shallow. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a1bc94baed587a767bc743a6922a1caa4">SimTK::Xml::Node</a>.</p>

</div>
</div>
<a class="anchor" id="a6bffec933fcbf26da23323fe35eaf448"></a><!-- doxytag: member="SimTK::Xml::Element::getElementTag" ref="a6bffec933fcbf26da23323fe35eaf448" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6bffec933fcbf26da23323fe35eaf448">SimTK::Xml::Element::getElementTag</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the element tag word. </p>
<p>This may represent the name or type of the element depending on context. </p>

</div>
</div>
<a class="anchor" id="a6b5bf3c6e351f7dd9afa52fcff07af52"></a><!-- doxytag: member="SimTK::Xml::Element::setElementTag" ref="a6b5bf3c6e351f7dd9afa52fcff07af52" args="(const String &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6b5bf3c6e351f7dd9afa52fcff07af52">SimTK::Xml::Element::setElementTag</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the tag word that is used to bracket this element. </p>

</div>
</div>
<a class="anchor" id="a4e79c09e3f397a48c65f40f86d113664"></a><!-- doxytag: member="SimTK::Xml::Element::insertNodeBefore" ref="a4e79c09e3f397a48c65f40f86d113664" args="(const node_iterator &amp;pos, Node node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a4e79c09e3f397a48c65f40f86d113664">SimTK::Xml::Element::insertNodeBefore</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just before the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>). </p>
<p>The iterator must refer to a node that is a child of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>. This <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> takes over ownership of the node which must not already have a parent. </p>

</div>
</div>
<a class="anchor" id="a9bdc6b7182e6308f1bd9e08c830566b9"></a><!-- doxytag: member="SimTK::Xml::Element::insertNodeAfter" ref="a9bdc6b7182e6308f1bd9e08c830566b9" args="(const node_iterator &amp;pos, Node node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9bdc6b7182e6308f1bd9e08c830566b9">SimTK::Xml::Element::insertNodeAfter</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just after the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>). </p>
<p>The iterator must refer to a node that is a child of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>. This <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> takes over ownership of the node which must not already have a parent. </p>

</div>
</div>
<a class="anchor" id="ac3822acf6439f7b502ef0d6778ede972"></a><!-- doxytag: member="SimTK::Xml::Element::eraseNode" ref="ac3822acf6439f7b502ef0d6778ede972" args="(const node_iterator &amp;deleteThis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ac3822acf6439f7b502ef0d6778ede972">SimTK::Xml::Element::eraseNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>deleteThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the indicated node, which must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. </p>
<p>The node will be removed from this element and deleted. The iterator is invalid after this call; be sure not to use it again. Also, there must not be any handles referencing the now-deleted node. </p>

</div>
</div>
<a class="anchor" id="afd5b6dd8506bfb5221631df7dad4de4d"></a><!-- doxytag: member="SimTK::Xml::Element::removeNode" ref="afd5b6dd8506bfb5221631df7dad4de4d" args="(const node_iterator &amp;removeThis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#afd5b6dd8506bfb5221631df7dad4de4d">SimTK::Xml::Element::removeNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>removeThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the indicated node from this element without erasing it, returning it as an orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>. </p>
<p>The node must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. The node will be removed from this element and returned as an orphan. The iterator is invalid after this call; be sure not to use it again. </p>

</div>
</div>
<a class="anchor" id="aae65d97f9b00e4418d5602e77bb5fb66"></a><!-- doxytag: member="SimTK::Xml::Element::isValueElement" ref="aae65d97f9b00e4418d5602e77bb5fb66" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66">SimTK::Xml::Element::isValueElement</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether this element qualifies as a "value element", defined as an element containing zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> nodes and no child elements. </p>
<p>You can treat a value element as you would an attribute -- it can be viewed as having a single value, which is just the value of its lone <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> node (or a null string if it doesn't have any text). </p>

</div>
</div>
<a class="anchor" id="ab42eeb91fc1f6d3ad570d0db925870ce"></a><!-- doxytag: member="SimTK::Xml::Element::getValue" ref="ab42eeb91fc1f6d3ad570d0db925870ce" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce">SimTK::Xml::Element::getValue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the text value of this value element. </p>
<p>An error will be thrown if this is not a "value element". See the comments for this class for the definition of a "value element". </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This does not return the same text as the base class method <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0091f53a29b7082e51f8682ab8e36643" title="Return a text value associated with this Node (not including its child nodes if any); the behavior de...">Node::getNodeText()</a> does in the case of an element node; that returns the element tag word not its contents. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238" title="Set the text value of this value element.">setValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d" title="Obtain a writable reference to the String containing the value of this value element.">updValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6fbe1243e8e2e83ceb3925659181065d"></a><!-- doxytag: member="SimTK::Xml::Element::updValue" ref="a6fbe1243e8e2e83ceb3925659181065d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a>&amp; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d">SimTK::Xml::Element::updValue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a writable reference to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> containing the value of this value element. </p>
<p>An error will be thrown if this is not a value element. If the element was initially empty and didn't contain a <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> node, one will be added to it here with a null-string value so that we can return a reference to it. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce" title="Get the text value of this value element.">getValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a87d99f6f31da37e122ee14dcb7281238"></a><!-- doxytag: member="SimTK::Xml::Element::setValue" ref="a87d99f6f31da37e122ee14dcb7281238" args="(const String &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238">SimTK::Xml::Element::setValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the text value of this value element. </p>
<p>An error will be thrown if this is not a value element. If the element was initially empty and didn't contain a <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> node, one will be added to it here so that we have a place to hold the <em>value</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4" title="Set the value of this value element to the text equivalent of any type T for which a conversion const...">setValueAs&lt;T&gt;()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a03fd52a31abb8f1626d7902c747b02d4"></a><!-- doxytag: member="SimTK::Xml::Element::setValueAs" ref="a03fd52a31abb8f1626d7902c747b02d4" args="(const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4">SimTK::Xml::Element::setValueAs</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the value of this value element to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists). </p>

</div>
</div>
<a class="anchor" id="a3250133e91118e41e46f925f05556cec"></a><!-- doxytag: member="SimTK::Xml::Element::getValueAs" ref="a3250133e91118e41e46f925f05556cec" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec">SimTK::Xml::Element::getValueAs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assuming this is a "value element", convert its text value to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a665fafcd7535ac1db55c9ed81caea4c3"></a><!-- doxytag: member="SimTK::Xml::Element::getValueAs" ref="a665fafcd7535ac1db55c9ed81caea4c3" args="(T &amp;out) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec">SimTK::Xml::Element::getValueAs</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate form of <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs()</a> that avoids unnecessary copying and heap allocation for reading in large container objects. </p>

</div>
</div>
<a class="anchor" id="af527410d9e2b0483da3b7384d8c497ec"></a><!-- doxytag: member="SimTK::Xml::Element::getRequiredElementValue" ref="af527410d9e2b0483da3b7384d8c497ec" args="(const String &amp;tag) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#af527410d9e2b0483da3b7384d8c497ec">SimTK::Xml::Element::getRequiredElementValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the text value of a child value element that <em>must</em> be present in this element. </p>
<p>The child is identified by its tag; if there is more than one this refers to the first one. Then the element is expected to contain either zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> nodes; if none we'll return a null string, otherwise the value of the <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> node. Thus an element like "&lt;tag&gt;stuff&lt;/tag&gt;" will have the value "stuff". An error will be thrown if either the element is not found or it is not a "value element". </p>

</div>
</div>
<a class="anchor" id="aaeeab5895d7485590ab1fec6177c7a91"></a><!-- doxytag: member="SimTK::Xml::Element::getOptionalElementValue" ref="aaeeab5895d7485590ab1fec6177c7a91" args="(const String &amp;tag, const String &amp;def=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaeeab5895d7485590ab1fec6177c7a91">SimTK::Xml::Element::getOptionalElementValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the text value of a child value element that <em>may</em> be present in this element, otherwise return a default string. </p>
<p>If the child element is found, it must be a "value element" as defined above. </p>

</div>
</div>
<a class="anchor" id="acd51b037e620848e76d1591cdb26a457"></a><!-- doxytag: member="SimTK::Xml::Element::getRequiredElementValueAs" ref="acd51b037e620848e76d1591cdb26a457" args="(const String &amp;tag) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classSimTK_1_1Xml_1_1Element.html#acd51b037e620848e76d1591cdb26a457">SimTK::Xml::Element::getRequiredElementValueAs</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the text value of a required child value element to the type of the template argument T. </p>
<p>It is an error if the element is present but is not a value element, or if the text cannot be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag of the required child text element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the text element, converted to an object of type T. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bf04099eb57a7ce81de228ba6b2c034"></a><!-- doxytag: member="SimTK::Xml::Element::getOptionalElementValueAs" ref="a2bf04099eb57a7ce81de228ba6b2c034" args="(const String &amp;tag, const T &amp;def) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a2bf04099eb57a7ce81de228ba6b2c034">SimTK::Xml::Element::getOptionalElementValueAs</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the text value of an optional child value element, if present, to the type of the template argument T. </p>
<p>It is an error if the child element is present but is not a value element, or if the text cannot be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) If the child element is not present, then return a supplied default value of type T. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream with operator "&gt;&gt;". </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag of the optional child element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The value of type T to return if child element is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of element <em>tag</em> if it is present, otherwise a copy of the supplied default value <em>def</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6545733fba05a6349cee654d8d2167b"></a><!-- doxytag: member="SimTK::Xml::Element::hasAttribute" ref="ab6545733fba05a6349cee654d8d2167b" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab6545733fba05a6349cee654d8d2167b">SimTK::Xml::Element::hasAttribute</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this element has an attribute of this name. </p>

</div>
</div>
<a class="anchor" id="a8c04ffb38dc3e908fd559c7c542ad559"></a><!-- doxytag: member="SimTK::Xml::Element::setAttributeValue" ref="a8c04ffb38dc3e908fd559c7c542ad559" args="(const String &amp;name, const String &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a8c04ffb38dc3e908fd559c7c542ad559">SimTK::Xml::Element::setAttributeValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the value of an attribute of this element, creating a new one if this is a new attribute name otherwise modifying an existing one. </p>

</div>
</div>
<a class="anchor" id="a03e4d7a877ad3a514412e78e3efc6ce7"></a><!-- doxytag: member="SimTK::Xml::Element::eraseAttribute" ref="a03e4d7a877ad3a514412e78e3efc6ce7" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03e4d7a877ad3a514412e78e3efc6ce7">SimTK::Xml::Element::eraseAttribute</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase an attribute of this element if it exists, otherwise do nothing. </p>
<p>If you need to know if the attribute exists, use <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab6545733fba05a6349cee654d8d2167b" title="Return true if this element has an attribute of this name.">hasAttribute()</a>. There is no removeAttribute() that orphans an existing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>, but you can easily recreate one with the same name and value. </p>

</div>
</div>
<a class="anchor" id="a65d6cb52b56efd3d9a1202ac827e1812"></a><!-- doxytag: member="SimTK::Xml::Element::getRequiredAttributeValue" ref="a65d6cb52b56efd3d9a1202ac827e1812" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a65d6cb52b56efd3d9a1202ac827e1812">SimTK::Xml::Element::getRequiredAttributeValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of an attribute as a string and throw an error if that attribute is not present. </p>

</div>
</div>
<a class="anchor" id="a12c6820ae4a6507752eefd1ea960fd46"></a><!-- doxytag: member="SimTK::Xml::Element::getRequiredAttributeValueAs" ref="a12c6820ae4a6507752eefd1ea960fd46" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a12c6820ae4a6507752eefd1ea960fd46">SimTK::Xml::Element::getRequiredAttributeValueAs</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the text value of a required attribute to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vec3.) </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae54dacef8bea4acac95a89ce5aefb44d"></a><!-- doxytag: member="SimTK::Xml::Element::getOptionalAttributeValue" ref="ae54dacef8bea4acac95a89ce5aefb44d" args="(const String &amp;name, const String &amp;def=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae54dacef8bea4acac95a89ce5aefb44d">SimTK::Xml::Element::getOptionalAttributeValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of an attribute as a string if the attribute is present in this element, otherwise return a supplied default value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the optional attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The string to return if the attribute is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of attribute <em>name</em> if it is present, otherwise a copy of the supplied default string <em>def</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a24d8bc6dc30f3d97af5a393a7b057b83"></a><!-- doxytag: member="SimTK::Xml::Element::getOptionalAttributeValueAs" ref="a24d8bc6dc30f3d97af5a393a7b057b83" args="(const String &amp;name, const T &amp;def) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a24d8bc6dc30f3d97af5a393a7b057b83">SimTK::Xml::Element::getOptionalAttributeValueAs</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the value of an optional attribute, if present, from a string to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vec3.) If the attribute is not present, then return a supplied default value of type T. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream with operator "&gt;&gt;". </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the optional attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The value of type T to return if the attribute is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of attribute <em>name</em> if it is present, otherwise a copy of the supplied default value <em>def</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad904c330f4cec26a4e5793bed0441445"></a><!-- doxytag: member="SimTK::Xml::Element::getRequiredAttribute" ref="ad904c330f4cec26a4e5793bed0441445" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad904c330f4cec26a4e5793bed0441445">SimTK::Xml::Element::getRequiredAttribute</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element; an error will be thrown if no such attribute is present. </p>

</div>
</div>
<a class="anchor" id="aacd827d22b75b6202b7461b2ab90ddeb"></a><!-- doxytag: member="SimTK::Xml::Element::getOptionalAttribute" ref="aacd827d22b75b6202b7461b2ab90ddeb" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aacd827d22b75b6202b7461b2ab90ddeb">SimTK::Xml::Element::getOptionalAttribute</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element specified by name, or an empty handle if no such attribute is present. </p>

</div>
</div>
<a class="anchor" id="a34d797fd21a8b3d851616dc8d00241a6"></a><!-- doxytag: member="SimTK::Xml::Element::getAllAttributes" ref="a34d797fd21a8b3d851616dc8d00241a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&gt; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a34d797fd21a8b3d851616dc8d00241a6">SimTK::Xml::Element::getAllAttributes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handles referencing all the attributes of this element. </p>
<p>Attributes are returned in the order that they appear in the element tag. <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> names within a tag are unique; if the source document had repeated attribute names only the last one to appear is retained and that's the only one we'll find here. This is just a shortcut for </p>
<div class="fragment"><pre class="fragment">    Array_&lt;Attribute&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a2e80bd8d9c3421ba9d1113579f9acf47" title="For iterating through all the attributes of this element.">attribute_begin</a>(), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c" title="This attribute_end() iterator indicates the end of a sequence of attributes.">attribute_end</a>());
</pre></div> 
</div>
</div>
<a class="anchor" id="a2e80bd8d9c3421ba9d1113579f9acf47"></a><!-- doxytag: member="SimTK::Xml::Element::attribute_begin" ref="a2e80bd8d9c3421ba9d1113579f9acf47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a2e80bd8d9c3421ba9d1113579f9acf47">SimTK::Xml::Element::attribute_begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For iterating through all the attributes of this element. </p>
<p>If there are no attributes then the returned <a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c" title="This attribute_end() iterator indicates the end of a sequence of attributes.">attribute_end()</a>. </p>

</div>
</div>
<a class="anchor" id="ab4ba2c678473eaab3218db79e67e671c"></a><!-- doxytag: member="SimTK::Xml::Element::attribute_end" ref="ab4ba2c678473eaab3218db79e67e671c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c">SimTK::Xml::Element::attribute_end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c" title="This attribute_end() iterator indicates the end of a sequence of attributes.">attribute_end()</a> iterator indicates the end of a sequence of attributes. </p>

</div>
</div>
<a class="anchor" id="af295f46c76adc5bbdfac98b6f1a80b82"></a><!-- doxytag: member="SimTK::Xml::Element::hasElement" ref="af295f46c76adc5bbdfac98b6f1a80b82" args="(const String &amp;tag) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Xml_1_1Element.html#af295f46c76adc5bbdfac98b6f1a80b82">SimTK::Xml::Element::hasElement</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if this element has a child element with this tag. </p>

</div>
</div>
<a class="anchor" id="a1495f916a3d8924d4ead80592c2034ce"></a><!-- doxytag: member="SimTK::Xml::Element::hasNode" ref="a1495f916a3d8924d4ead80592c2034ce" args="(NodeType allowed=AnyNodes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1495f916a3d8924d4ead80592c2034ce">SimTK::Xml::Element::hasNode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See if this element has any child nodes, or any child nodes of the type(s) allowed by the NodeType filter if one is supplied. </p>

</div>
</div>
<a class="anchor" id="a1ee99cd86e3e413234c7b4bf9e2d5bf6"></a><!-- doxytag: member="SimTK::Xml::Element::getRequiredElement" ref="a1ee99cd86e3e413234c7b4bf9e2d5bf6" args="(const String &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1ee99cd86e3e413234c7b4bf9e2d5bf6">SimTK::Xml::Element::getRequiredElement</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference to a child element that <em>must</em> be present in this element. </p>
<p>The child is identified by its tag; if there is more than one only the first one is returned. If you want to see all children with this tag, use <a class="el" href="classSimTK_1_1Xml_1_1Element.html#af9c43f8749c9def7a0b65136e8fc1329" title="Return an array containing Element handles referencing all the immediate child elements contained in ...">getAllElements()</a> or use an <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>. </p>

</div>
</div>
<a class="anchor" id="a3772785ece91bcccba9da75e89eecbdd"></a><!-- doxytag: member="SimTK::Xml::Element::getOptionalElement" ref="a3772785ece91bcccba9da75e89eecbdd" args="(const String &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3772785ece91bcccba9da75e89eecbdd">SimTK::Xml::Element::getOptionalElement</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference to a child element that <em>may</em> be present in this element; otherwise return an invalid <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle. </p>
<p><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing.">Test</a> using the <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a8a08c6ea7d9b3362a5b2af3b7012d09a" title="Return true if this Node handle is referencing some node, false if the Node handle is empty...">isValid()</a> method. </p>

</div>
</div>
<a class="anchor" id="af9c43f8749c9def7a0b65136e8fc1329"></a><!-- doxytag: member="SimTK::Xml::Element::getAllElements" ref="af9c43f8749c9def7a0b65136e8fc1329" args="(const String &amp;tag=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&gt; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#af9c43f8749c9def7a0b65136e8fc1329">SimTK::Xml::Element::getAllElements</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handles referencing all the immediate child elements contained in this element, or all the child elements of a particular type (that is, with a given tag word). </p>
<p>Elements are returned in the order they are seen in the document. This is just a shortcut for </p>
<div class="fragment"><pre class="fragment">    Array_&lt;Element&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a8f9e8c86fb08bd3c0ffd397e0186acb0" title="For iterating through the immediate child elements of this element, or the child elements that have t...">element_begin</a>(tag), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end</a>());
</pre></div> 
</div>
</div>
<a class="anchor" id="a60f0a78da097f84bf67bef22bb5b5372"></a><!-- doxytag: member="SimTK::Xml::Element::getAllNodes" ref="a60f0a78da097f84bf67bef22bb5b5372" args="(NodeType allowed=AnyNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&gt; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a60f0a78da097f84bf67bef22bb5b5372">SimTK::Xml::Element::getAllNodes</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> handles referencing all the immediate child nodes contained in this element, or all the child nodes of a particular type or types. </p>
<p>Nodes are returned in the order they are seen in the document. This is just a shortcut for </p>
<div class="fragment"><pre class="fragment">    Array_&lt;Node&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a9d3c5ff58a4653ffac14b19447f8c718" title="For iterating through the immediate child nodes of this element, or the child nodes of the type(s) al...">node_begin</a>(allowed), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end</a>());
</pre></div> 
</div>
</div>
<a class="anchor" id="a8f9e8c86fb08bd3c0ffd397e0186acb0"></a><!-- doxytag: member="SimTK::Xml::Element::element_begin" ref="a8f9e8c86fb08bd3c0ffd397e0186acb0" args="(const String &amp;tag=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a8f9e8c86fb08bd3c0ffd397e0186acb0">SimTK::Xml::Element::element_begin</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For iterating through the immediate child elements of this element, or the child elements that have the indicated tag if one is supplied. </p>
<p>If there are no children with the <em>allowed</em> tag then the returned <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a>. </p>

</div>
</div>
<a class="anchor" id="a7c1f3e8fced7b1bb5b081b9cb5af9fa2"></a><!-- doxytag: member="SimTK::Xml::Element::element_end" ref="a7c1f3e8fced7b1bb5b081b9cb5af9fa2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2">SimTK::Xml::Element::element_end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a> iterator indicates the end of any sequence of elements regardless of the tag restriction on the iterator being used. </p>

</div>
</div>
<a class="anchor" id="a9d3c5ff58a4653ffac14b19447f8c718"></a><!-- doxytag: member="SimTK::Xml::Element::node_begin" ref="a9d3c5ff58a4653ffac14b19447f8c718" args="(NodeType allowed=AnyNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9d3c5ff58a4653ffac14b19447f8c718">SimTK::Xml::Element::node_begin</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For iterating through the immediate child nodes of this element, or the child nodes of the type(s) allowed by the NodeType filter if one is supplied. </p>
<p>If there are no children of the <em>allowed</em> types then the returned <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. </p>

</div>
</div>
<a class="anchor" id="aad74f7074ef8b528f9e9ac5fed950790"></a><!-- doxytag: member="SimTK::Xml::Element::node_end" ref="aad74f7074ef8b528f9e9ac5fed950790" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790">SimTK::Xml::Element::node_end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a> iterator indicates the end of any sequence of nodes regardless of the NodeType restriction on the iterator being used. </p>

</div>
</div>
<a class="anchor" id="a569474bd297296231c6078cc050a8521"></a><!-- doxytag: member="SimTK::Xml::Element::isA" ref="a569474bd297296231c6078cc050a8521" args="(const Node &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521">SimTK::Xml::Element::isA</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing.">Test</a> whether a given <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> is an element node. </p>

</div>
</div>
<a class="anchor" id="a869b394c523a22dc160a5990850457e3"></a><!-- doxytag: member="SimTK::Xml::Element::getAs" ref="a869b394c523a22dc160a5990850457e3" args="(const Node &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&amp; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a869b394c523a22dc160a5990850457e3">SimTK::Xml::Element::getAs</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> to a const <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> is not actually an element node. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521" title="Test whether a given Node is an element node.">isA()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad15f74e7946e1abb0026eff29803cbd2"></a><!-- doxytag: member="SimTK::Xml::Element::getAs" ref="ad15f74e7946e1abb0026eff29803cbd2" args="(Node &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&amp; <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a869b394c523a22dc160a5990850457e3">SimTK::Xml::Element::getAs</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast a writable <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> to a writable <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> is not actually an element node. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521" title="Test whether a given Node is an element node.">isA()</a> </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aee787d4b6e5639c308b632173814ece7"></a><!-- doxytag: member="SimTK::Xml::Element::Xml::Node" ref="aee787d4b6e5639c308b632173814ece7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Xml::Node</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4ee202f3a1549ce45c613ddce919565"></a><!-- doxytag: member="SimTK::Xml::Element::Xml::element_iterator" ref="ad4ee202f3a1549ce45c613ddce919565" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">Xml::element_iterator</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Xml_8h_source.html">Xml.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Xml.html">Xml</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>      </li>

    <li class="footer">Generated on Mon Jul 14 2014 23:26:08 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
