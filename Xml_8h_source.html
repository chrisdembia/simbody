<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: Xml.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('Xml_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Xml.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="Xml_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef SimTK_SimTKCOMMON_XML_H_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define SimTK_SimTKCOMMON_XML_H_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* -------------------------------------------------------------------------- *</span>
<a name="l00005"></a>00005 <span class="comment"> *                       Simbody(tm): SimTKcommon                             *</span>
<a name="l00006"></a>00006 <span class="comment"> * -------------------------------------------------------------------------- *</span>
<a name="l00007"></a>00007 <span class="comment"> * This is part of the SimTK biosimulation toolkit originating from           *</span>
<a name="l00008"></a>00008 <span class="comment"> * Simbios, the NIH National Center for Physics-Based Simulation of           *</span>
<a name="l00009"></a>00009 <span class="comment"> * Biological Structures at Stanford, funded under the NIH Roadmap for        *</span>
<a name="l00010"></a>00010 <span class="comment"> * Medical Research, grant U54 GM072970. See https://simtk.org/home/simbody.  *</span>
<a name="l00011"></a>00011 <span class="comment"> *                                                                            *</span>
<a name="l00012"></a>00012 <span class="comment"> * Portions copyright (c) 2010-12 Stanford University and the Authors.        *</span>
<a name="l00013"></a>00013 <span class="comment"> * Authors: Michael Sherman                                                   *</span>
<a name="l00014"></a>00014 <span class="comment"> * Contributors: Peter Eastman                                                *</span>
<a name="l00015"></a>00015 <span class="comment"> *                                                                            *</span>
<a name="l00016"></a>00016 <span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may    *</span>
<a name="l00017"></a>00017 <span class="comment"> * not use this file except in compliance with the License. You may obtain a  *</span>
<a name="l00018"></a>00018 <span class="comment"> * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *</span>
<a name="l00019"></a>00019 <span class="comment"> *                                                                            *</span>
<a name="l00020"></a>00020 <span class="comment"> * Unless required by applicable law or agreed to in writing, software        *</span>
<a name="l00021"></a>00021 <span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,          *</span>
<a name="l00022"></a>00022 <span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *</span>
<a name="l00023"></a>00023 <span class="comment"> * See the License for the specific language governing permissions and        *</span>
<a name="l00024"></a>00024 <span class="comment"> * limitations under the License.                                             *</span>
<a name="l00025"></a>00025 <span class="comment"> * -------------------------------------------------------------------------- */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html" title="Mandatory first inclusion for any Simbody source or header file.">SimTKcommon/internal/common.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="Array_8h.html" title="This file defines the Array_&lt;T,X&gt; class and related support classes including base classes ArrayViewC...">SimTKcommon/internal/Array.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="String_8h.html">SimTKcommon/internal/String.h</a>&quot;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="keyword">namespace </span>SimTK {
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">// These are declared but never defined; all TinyXML code is hidden.</span>
<a name="l00037"></a>00037 <span class="keyword">class </span>TiXmlNode; 
<a name="l00038"></a>00038 <span class="keyword">class </span>TiXmlElement; 
<a name="l00039"></a>00039 <span class="keyword">class </span>TiXmlAttribute;
<a name="l00040"></a>00040 <span class="keyword">class </span>TiXmlText;
<a name="l00041"></a>00041 <span class="keyword">class </span>TiXmlComment;
<a name="l00042"></a>00042 <span class="keyword">class </span>TiXmlUnknown;
<a name="l00043"></a>00043     
<a name="l00266"></a>00266 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00267"></a>00267 <span class="comment">//                                   XML</span>
<a name="l00268"></a>00268 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00269"></a><a class="code" href="classSimTK_1_1Xml.html">00269</a> <span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a> {
<a name="l00270"></a>00270 <span class="keyword">public</span>:
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="comment">// These local classes are used to describe the contents of an XML document.</span>
<a name="l00273"></a>00273 <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>;
<a name="l00274"></a>00274 <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>;         <span class="comment">// This is the abstract handle type for any node.</span>
<a name="l00275"></a>00275 <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text.">Comment</a>;      <span class="comment">// These are the concrete node types.</span>
<a name="l00276"></a>00276 <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Unknown</a>;      <span class="comment">//                  &quot;</span>
<a name="l00277"></a>00277 <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a>;         <span class="comment">//                  &quot;</span>
<a name="l00278"></a><a class="code" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">00278</a> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>;      <span class="comment">//                  &quot;</span>
<a name="l00279"></a>00279 
<a name="l00283"></a>00283 <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a> <a class="code" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Document</a>;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="comment">// This provides iteration over all the attributes found in a given element.</span>
<a name="l00286"></a>00286 <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="comment">// This provides iteration over all the nodes, or nodes of a certain type,</span>
<a name="l00289"></a>00289 <span class="comment">// at either the Xml document level or over the child nodes of an element.</span>
<a name="l00290"></a>00290 <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="comment">// This provides iteration over all the element nodes that are children</span>
<a name="l00293"></a>00293 <span class="comment">// of a given element, or over the subset of those child elements that has</span>
<a name="l00294"></a>00294 <span class="comment">// a particular tag word.</span>
<a name="l00295"></a>00295 <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>;
<a name="l00296"></a>00296 
<a name="l00302"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">00302</a> <span class="keyword">enum</span> <a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a> {
<a name="l00303"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca1ac71fe4a533a82860b70f93cb690a73">00303</a>     NoNode      = 0x00, 
<a name="l00304"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca9e989384ca13f6904a03508b95daca5e">00304</a>     ElementNode = 0x01, 
<a name="l00305"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bcafa3611893e7ad0de926231eca098bba1">00305</a>     TextNode    = 0x02, 
<a name="l00306"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bcac9c4cd9ab6736ab5bf6f18b751109727">00306</a>     CommentNode = 0x04, 
<a name="l00307"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bcac9b7672fa07db7c0f3890080f6ff8832">00307</a>     UnknownNode = 0x08, 
<a name="l00308"></a>00308 
<a name="l00309"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca9cd1e2482a4f2d4c2cb78a8ae0a93cca">00309</a>     NoJunkNodes = ElementNode|TextNode,    
<a name="l00310"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3745575a8cd6e85844d07f37be7e17e6">00310</a>     JunkNodes   = CommentNode|UnknownNode, 
<a name="l00311"></a><a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">00311</a>     AnyNodes    = NoJunkNodes|JunkNodes    
<a name="l00312"></a>00312 };
<a name="l00313"></a>00313 
<a name="l00315"></a>00315 <span class="keyword">static</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> getNodeTypeAsString(NodeType type);
<a name="l00316"></a>00316 
<a name="l00320"></a>00320 
<a name="l00330"></a>00330 <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>();
<a name="l00331"></a>00331 
<a name="l00338"></a>00338 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; pathname);
<a name="l00339"></a>00339 
<a name="l00342"></a>00342 <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml::Document</a>&amp; source);
<a name="l00343"></a>00343 
<a name="l00347"></a>00347 <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml::Document</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml::Document</a>&amp; souce);
<a name="l00348"></a>00348 
<a name="l00350"></a>00350 ~<a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>();
<a name="l00351"></a>00351 
<a name="l00353"></a>00353 <span class="keywordtype">void</span> clear();
<a name="l00363"></a>00363 <span class="keywordtype">void</span> readFromFile(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; pathname);
<a name="l00368"></a>00368 <span class="keywordtype">void</span> writeToFile(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; pathname) <span class="keyword">const</span>;
<a name="l00372"></a>00372 <span class="keywordtype">void</span> readFromString(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; xmlDocument);
<a name="l00376"></a>00376 <span class="keywordtype">void</span> readFromString(<span class="keyword">const</span> <span class="keywordtype">char</span>* xmlDocument);
<a name="l00382"></a>00382 <span class="keywordtype">void</span> writeToString(<a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; xmlDocument, <span class="keywordtype">bool</span> compact = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00387"></a>00387 <span class="keywordtype">void</span> setIndentString(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; indent);
<a name="l00390"></a>00390 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getIndentString() <span class="keyword">const</span>;
<a name="l00391"></a>00391 
<a name="l00395"></a>00395 <span class="keyword">static</span> <span class="keywordtype">void</span> setXmlCondenseWhiteSpace(<span class="keywordtype">bool</span> shouldCondense);
<a name="l00398"></a>00398 <span class="keyword">static</span> <span class="keywordtype">bool</span> isXmlWhiteSpaceCondensed();
<a name="l00410"></a>00410 
<a name="l00422"></a>00422 Element getRootElement();
<a name="l00423"></a>00423 
<a name="l00426"></a>00426 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getRootTag() <span class="keyword">const</span>;
<a name="l00429"></a>00429 <span class="keywordtype">void</span> setRootTag(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag);
<a name="l00430"></a>00430 
<a name="l00438"></a>00438 <span class="keywordtype">void</span> insertTopLevelNodeAfter (<span class="keyword">const</span> node_iterator&amp; afterThis, 
<a name="l00439"></a>00439                               Node                 insertThis);
<a name="l00442"></a>00442 <span class="keywordtype">void</span> insertTopLevelNodeBefore(<span class="keyword">const</span> node_iterator&amp; beforeThis, 
<a name="l00443"></a>00443                               Node                 insertThis);
<a name="l00449"></a>00449 <span class="keywordtype">void</span> eraseTopLevelNode(<span class="keyword">const</span> node_iterator&amp; deleteThis);
<a name="l00456"></a>00456 Node removeTopLevelNode(<span class="keyword">const</span> node_iterator&amp; removeThis);
<a name="l00472"></a>00472 node_iterator       node_begin(NodeType allowed=AnyNodes);
<a name="l00473"></a>00473 
<a name="l00476"></a>00476 node_iterator       node_end() <span class="keyword">const</span>;
<a name="l00499"></a>00499 <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> getXmlVersion() <span class="keyword">const</span>;
<a name="l00502"></a>00502 <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> getXmlEncoding() <span class="keyword">const</span>;
<a name="l00508"></a>00508 <span class="keywordtype">bool</span> getXmlIsStandalone() <span class="keyword">const</span>;
<a name="l00509"></a>00509 
<a name="l00512"></a>00512 <span class="keywordtype">void</span> setXmlVersion(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; version);
<a name="l00515"></a>00515 <span class="keywordtype">void</span> setXmlEncoding(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; encoding);
<a name="l00520"></a>00520 <span class="keywordtype">void</span> setXmlIsStandalone(<span class="keywordtype">bool</span> isStandalone);
<a name="l00523"></a>00523 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00524"></a>00524                                   <span class="keyword">private</span>:
<a name="l00525"></a><a class="code" href="classSimTK_1_1Xml.html#a6db9d28bd448a131448276ee03de1e6d">00525</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 <span class="keyword">class </span>Impl; <span class="comment">// a private, local class Xml::Impl</span>
<a name="l00528"></a>00528 <span class="keyword">const</span> Impl&amp; getImpl()<span class="keyword"> const </span>{assert(impl); <span class="keywordflow">return</span> *impl;}
<a name="l00529"></a>00529 Impl&amp;       updImpl()       {assert(impl); <span class="keywordflow">return</span> *impl;}
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 Xml&amp; unconst()<span class="keyword"> const </span>{<span class="keywordflow">return</span> *<span class="keyword">const_cast&lt;</span>Xml*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);}
<a name="l00532"></a>00532 
<a name="l00533"></a>00533 Impl*       impl; <span class="comment">// This is the lone data member.</span>
<a name="l00534"></a>00534 };
<a name="l00535"></a>00535 
<a name="l00540"></a>00540 <span class="comment">// Do this inline so we don&#39;t have to pass the ostream through the API.</span>
<a name="l00541"></a><a class="code" href="classSimTK_1_1Xml.html#adeed202918b23025e38c1219d176d312">00541</a> <span class="keyword">inline</span> std::ostream&amp; <a class="code" href="classSimTK_1_1Xml.html#adeed202918b23025e38c1219d176d312" title="Output a &quot;pretty printed&quot; textual representation of the given Xml::Document to an std::ostream...">operator&lt;&lt;</a>(std::ostream&amp; o, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml::Document</a>&amp; doc) {
<a name="l00542"></a>00542     <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> output;
<a name="l00543"></a>00543     doc.<a class="code" href="classSimTK_1_1Xml.html#a9f93ae9b285db17fb8cfdc04d24fc6de" title="Write the contents of this in-memory Xml::Document to the supplied string.">writeToString</a>(output);
<a name="l00544"></a>00544     <span class="keywordflow">return</span> o &lt;&lt; output;
<a name="l00545"></a>00545 }
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00550"></a>00550 <span class="comment">//                              XML ATTRIBUTE</span>
<a name="l00551"></a>00551 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00557"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html">00557</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> {
<a name="l00558"></a>00558 <span class="keyword">public</span>:
<a name="l00560"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#acd8addd441555c07c120a5c2666f5722">00560</a> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#acd8addd441555c07c120a5c2666f5722" title="Default constructor creates a null Attribute handle.">Attribute</a>() : tiAttr(0) {}
<a name="l00563"></a>00563 <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; value);
<a name="l00567"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a3dea08ac4f49108371e14fb013094bb2">00567</a> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a3dea08ac4f49108371e14fb013094bb2" title="Copy constructor is shallow; that is, this handle will refer to the same attribute as the source...">Attribute</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; src) : tiAttr(src.tiAttr) {} 
<a name="l00572"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a797c63934d68c2e6238867fc64d29072">00572</a> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; src) 
<a name="l00573"></a>00573 {   <span class="keywordflow">if</span> (&amp;src!=<span class="keyword">this</span>) {clear(); tiAttr=src.tiAttr;} <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00577"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a1cd37a5e2f9b864a4f9bc37918859693">00577</a> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a1cd37a5e2f9b864a4f9bc37918859693" title="The Attribute handle destructor does not recover heap space so if you create orphan attributes and th...">~Attribute</a>() {clear();}
<a name="l00579"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a73dd96ffa2cbe7b3fc45b94598f26b4a">00579</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a73dd96ffa2cbe7b3fc45b94598f26b4a" title="Is this handle currently holding an attribute?">isValid</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> tiAttr!=0;}
<a name="l00584"></a>00584 <span class="keywordtype">bool</span> isOrphan() <span class="keyword">const</span>;
<a name="l00586"></a>00586 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getName() <span class="keyword">const</span>;
<a name="l00589"></a>00589 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getValue() <span class="keyword">const</span>;
<a name="l00592"></a>00592 <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; setName(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name);
<a name="l00596"></a>00596 <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; setValue(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; value);
<a name="l00597"></a>00597 
<a name="l00601"></a>00601 <span class="keywordtype">void</span> clear();
<a name="l00605"></a>00605 <span class="keywordtype">void</span> clearOrphan();
<a name="l00606"></a>00606 
<a name="l00611"></a>00611 <span class="keywordtype">void</span> writeToString(<a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; out) <span class="keyword">const</span>;
<a name="l00612"></a>00612 
<a name="l00616"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#ab5857d5f5638b8a19a72be0de0797c45">00616</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#ab5857d5f5638b8a19a72be0de0797c45" title="Comparison operators return true if the same attribute is being referenced or both handles are empty...">operator==</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; attr)<span class="keyword"> const </span>{<span class="keywordflow">return</span> tiAttr==attr.tiAttr;}
<a name="l00617"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a3e5f18329eb8eb83bc2788e5fa7ec8eb">00617</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a3e5f18329eb8eb83bc2788e5fa7ec8eb">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; attr)<span class="keyword"> const </span>{<span class="keywordflow">return</span> tiAttr!=attr.tiAttr;}
<a name="l00618"></a>00618 
<a name="l00619"></a>00619 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00620"></a>00620                                   <span class="keyword">private</span>:
<a name="l00621"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a4b98898efaa4929d401e6e609337f2c7">00621</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">Xml::attribute_iterator</a>;
<a name="l00622"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#ad573bea5abccc16b7d355fda4a8a6ff4">00622</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>(TiXmlAttribute* attr) {tiAttr=attr;}
<a name="l00625"></a>00625 <span class="keyword">const</span> TiXmlAttribute&amp; getTiAttr()<span class="keyword"> const </span>{assert(tiAttr);<span class="keywordflow">return</span> *tiAttr;}
<a name="l00626"></a>00626 TiXmlAttribute&amp;       updTiAttr()       {assert(tiAttr);<span class="keywordflow">return</span> *tiAttr;}
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="comment">// Careful; this does not clear the handle before replacing the pointer</span>
<a name="l00629"></a>00629 <span class="comment">// so should not be used if this could be the owner handle of an attribute</span>
<a name="l00630"></a>00630 <span class="comment">// that hasn&#39;t ever been added to a document. It is intended for use by</span>
<a name="l00631"></a>00631 <span class="comment">// iterators, whose contained Attributes can never be owners.</span>
<a name="l00632"></a>00632 <span class="keywordtype">void</span>                  setTiAttrPtr(TiXmlAttribute* attr) {tiAttr=attr;}
<a name="l00633"></a>00633 <span class="keyword">const</span> TiXmlAttribute* getTiAttrPtr()<span class="keyword"> const </span>{<span class="keywordflow">return</span> tiAttr;}
<a name="l00634"></a>00634 TiXmlAttribute*       updTiAttrPtr()       {<span class="keywordflow">return</span> tiAttr;}
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 Attribute&amp; unconst()<span class="keyword"> const </span>{<span class="keywordflow">return</span> *<span class="keyword">const_cast&lt;</span>Attribute*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);}
<a name="l00637"></a>00637 
<a name="l00638"></a>00638 TiXmlAttribute* tiAttr; <span class="comment">// this is the lone data member</span>
<a name="l00639"></a>00639 };
<a name="l00640"></a>00640 
<a name="l00645"></a>00645 <span class="comment">// Do this inline so we don&#39;t have to pass the ostream through the API.</span>
<a name="l00646"></a><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a76e029e3f690acfad1564e4572d2973c">00646</a> <span class="keyword">inline</span> std::ostream&amp; <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a76e029e3f690acfad1564e4572d2973c" title="Output a textual representation of the given Attribute to an std::ostream.">operator&lt;&lt;</a>(std::ostream&amp; o, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Xml::Attribute</a>&amp; attr) {
<a name="l00647"></a>00647     <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> output;
<a name="l00648"></a>00648     attr.<a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#aed91033040c160f0b2e9ac20129ba768" title="Serialize this attribute to the given String.">writeToString</a>(output);
<a name="l00649"></a>00649     <span class="keywordflow">return</span> o &lt;&lt; output;
<a name="l00650"></a>00650 }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 
<a name="l00654"></a>00654 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00655"></a>00655 <span class="comment">//                          XML ATTRIBUTE ITERATOR</span>
<a name="l00656"></a>00656 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00659"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html">00659</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a> 
<a name="l00660"></a>00660 :   <span class="keyword">public</span> std::iterator&lt;std::bidirectional_iterator_tag, Xml::Attribute&gt; {
<a name="l00661"></a>00661 <span class="keyword">public</span>:
<a name="l00664"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#a7255b51294d41c3b958ff507d6042703">00664</a> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#a7255b51294d41c3b958ff507d6042703" title="Default constructor creates an iterator that compares equal to attribute_end().">attribute_iterator</a>() {}
<a name="l00667"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#a3ff1170e557c0dab6a6de44c56443a31">00667</a> <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#a3ff1170e557c0dab6a6de44c56443a31" title="Construct this iterator to point to the same attribute as does the supplied Attribute handle (or attr...">attribute_iterator</a>(<a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; attr) : attr(attr) {}
<a name="l00670"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#af2dd1fbc4694460ef449ca959633fe2a">00670</a> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>&amp; src) 
<a name="l00671"></a>00671 :   attr(src-&gt;updTiAttrPtr()) {}
<a name="l00673"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#a4dc8dc347169a1f1e85da2e3c51d2387">00673</a> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#a4dc8dc347169a1f1e85da2e3c51d2387" title="An iterator destructor never deletes the object to which it refers.">~attribute_iterator</a>() {attr.setTiAttrPtr(0);}
<a name="l00676"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#aa9307c97c0a827ea68ac87797fa61d5d">00676</a> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>&amp; src) 
<a name="l00677"></a>00677 {   attr.setTiAttrPtr(src-&gt;updTiAttrPtr()); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00681"></a>00681 <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>&amp; operator++();   <span class="comment">// prefix</span>
<a name="l00685"></a>00685 <span class="comment"></span><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a> operator++(<span class="keywordtype">int</span>); <span class="comment">// postfix</span>
<a name="l00689"></a>00689 <span class="comment"></span><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>&amp; operator--();   <span class="comment">// prefix</span>
<a name="l00693"></a>00693 <span class="comment"></span><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a> operator--(<span class="keywordtype">int</span>); <span class="comment">// postfix</span>
<a name="l00694"></a>00694 
<a name="l00695"></a>00695 <span class="comment">// It&#39;s the iterator that&#39;s const in these next two methods; it still points</span>
<a name="l00696"></a>00696 <span class="comment">// to a non-const object just like a char* const p.</span>
<a name="l00697"></a>00697 
<a name="l00700"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#abcfd47c630319e15ad978c8c5403f9a9">00700</a> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp; <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#abcfd47c630319e15ad978c8c5403f9a9" title="Return a writable reference to the Attribute referenced by this iterator; the handle will be invalid ...">operator*</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>&amp;<span class="keyword">&gt;</span>(attr);}
<a name="l00704"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#a2bffad8d95ef3b019b8df1374e7c25b8">00704</a> <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>* <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#a2bffad8d95ef3b019b8df1374e7c25b8" title="Return a writable pointer to the Attribute referenced by this iterator; the pointer will never be nul...">operator-&gt;</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>*<span class="keyword">&gt;</span>(&amp;attr);}
<a name="l00709"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#ae9bf2efb2691a95eb909ddbf303dd59c">00709</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceSimTK.html#ac56336ea74b71f07f371d943bd5cdba0">operator==</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>&amp; other)<span class="keyword"> const </span>
<a name="l00710"></a>00710 <span class="keyword"></span>{   <span class="keywordflow">return</span> other.attr==attr; }
<a name="l00712"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#ab9eda6becaabc6919ecbc208e4fc5120">00712</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceSimTK.html#aac639daeeac2aca1f6b4e6d8da68488d">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>&amp; other)<span class="keyword"> const </span>
<a name="l00713"></a>00713 <span class="keyword"></span>{   <span class="keywordflow">return</span> other.attr!=attr; }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00716"></a>00716                                   <span class="keyword">private</span>:
<a name="l00717"></a><a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html#ad573bea5abccc16b7d355fda4a8a6ff4">00717</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>;
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a>(TiXmlAttribute* ap) : attr(ap) {}
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>       attr;   <span class="comment">// the lone data member</span>
<a name="l00722"></a>00722 };
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00727"></a>00727 <span class="comment">//                               XML NODE</span>
<a name="l00728"></a>00728 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00752"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html">00752</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> {
<a name="l00753"></a>00753 <span class="keyword">public</span>:
<a name="l00754"></a>00754 
<a name="l00759"></a>00759 
<a name="l00762"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a6086556201f425213e56d7d35d5a770f">00762</a> <a class="code" href="classSimTK_1_1Xml_1_1Node.html#a6086556201f425213e56d7d35d5a770f" title="Create an empty Node handle that can be used to hold a reference to any kind of Node.">Node</a>() : tiNode(0) {}
<a name="l00766"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a37a4a32f7bcd56d7e045def2c0721504">00766</a> <a class="code" href="classSimTK_1_1Xml_1_1Node.html#a37a4a32f7bcd56d7e045def2c0721504" title="Copy constructor is shallow; that is, this handle will refer to the same node as the source...">Node</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; src) : tiNode(src.tiNode) {} 
<a name="l00771"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#ac73ad2654deb98cc0d755cedef628102">00771</a> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; src) 
<a name="l00772"></a>00772 {   <span class="keywordflow">if</span> (&amp;src!=<span class="keyword">this</span>) {clear(); tiNode=src.tiNode;} <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00776"></a>00776 <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> clone() <span class="keyword">const</span>;
<a name="l00780"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#ae54089650958823d1a7d070cf27c1741">00780</a> <a class="code" href="classSimTK_1_1Xml_1_1Node.html#ae54089650958823d1a7d070cf27c1741" title="The Node handle destructor does not recover heap space so if you create orphan nodes and then don&#39;t p...">~Node</a>() {clear();}
<a name="l00784"></a>00784 <span class="keywordtype">void</span> clear();
<a name="l00788"></a>00788 <span class="keywordtype">void</span> clearOrphan();
<a name="l00796"></a>00796 
<a name="l00799"></a>00799 <a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a> getNodeType() <span class="keyword">const</span>;
<a name="l00800"></a>00800 
<a name="l00802"></a>00802 <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> getNodeTypeAsString() <span class="keyword">const</span>;
<a name="l00803"></a>00803 
<a name="l00806"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a8a08c6ea7d9b3362a5b2af3b7012d09a">00806</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html#a8a08c6ea7d9b3362a5b2af3b7012d09a" title="Return true if this Node handle is referencing some node, false if the Node handle is empty...">isValid</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> tiNode != 0;}
<a name="l00807"></a>00807 
<a name="l00811"></a>00811 <span class="keywordtype">bool</span> isTopLevelNode() <span class="keyword">const</span>;
<a name="l00812"></a>00812 
<a name="l00817"></a>00817 <span class="keywordtype">bool</span> isOrphan() <span class="keyword">const</span>;
<a name="l00818"></a>00818 
<a name="l00822"></a>00822 <span class="keywordtype">bool</span> hasParentElement() <span class="keyword">const</span>;
<a name="l00823"></a>00823 
<a name="l00826"></a>00826 <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> getParentElement();
<a name="l00834"></a>00834 
<a name="l00845"></a>00845 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getNodeText() <span class="keyword">const</span>;
<a name="l00846"></a>00846 
<a name="l00853"></a>00853 <span class="keywordtype">void</span> writeToString(<a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; out, <span class="keywordtype">bool</span> compact=<span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00859"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a9523850db5f393008f00c3900fa753b8">00859</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html#a9523850db5f393008f00c3900fa753b8" title="Comparing Nodes for equality means asking if the two Node handles are referring to exactly the same o...">operator==</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; other)<span class="keyword"> const </span>{<span class="keywordflow">return</span> other.tiNode==tiNode;}
<a name="l00861"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a50231fc82d308d4827cbb13f882747ee">00861</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html#a50231fc82d308d4827cbb13f882747ee" title="Inequality test using same criteria as operator==().">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; other)<span class="keyword"> const </span>{<span class="keywordflow">return</span> other.tiNode!=tiNode;}
<a name="l00862"></a>00862 
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00865"></a>00865                                  <span class="keyword">protected</span>: <span class="comment">// don&#39;t let Doxygen see these</span>
<a name="l00867"></a>00867 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>(TiXmlNode* tiNode) : tiNode(tiNode) {}
<a name="l00868"></a>00868 
<a name="l00869"></a>00869 <span class="keyword">const</span> TiXmlNode&amp; getTiNode()<span class="keyword"> const </span>{assert(tiNode);<span class="keywordflow">return</span> *tiNode;}
<a name="l00870"></a>00870 TiXmlNode&amp;       updTiNode()       {assert(tiNode);<span class="keywordflow">return</span> *tiNode;}
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 <span class="comment">// Careful: these &quot;Ptr&quot; methods provide raw access to the contained </span>
<a name="l00873"></a>00873 <span class="comment">// pointer without any cleanup or error checking. In particular, </span>
<a name="l00874"></a>00874 <span class="comment">// setTiNodePtr() does not attempt to delete the current contents.</span>
<a name="l00875"></a>00875 <span class="keywordtype">void</span> setTiNodePtr(TiXmlNode* node) {tiNode=node;}
<a name="l00876"></a>00876 <span class="keyword">const</span> TiXmlNode* getTiNodePtr()<span class="keyword"> const </span>{<span class="keywordflow">return</span> tiNode;}
<a name="l00877"></a>00877 TiXmlNode*       updTiNodePtr()       {<span class="keywordflow">return</span> tiNode;}
<a name="l00880"></a>00880 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00881"></a>00881                                   <span class="keyword">private</span>:
<a name="l00882"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a6da91779d499b1ad3035fe196aecd99a">00882</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>;
<a name="l00883"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a93e46e94e7cf9a3d870ce5f7444f2899">00883</a> <span class="keyword">friend</span> <span class="keyword">class </span>Xml::Impl;
<a name="l00884"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a66b9de807f55aaefbf3329e1da7874ed">00884</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">Xml::node_iterator</a>;
<a name="l00885"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#afc68234fdd04ea25b3b4906c59460129">00885</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text.">Xml::Comment</a>;
<a name="l00886"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#ac058de0e0e9bc866bc00bb8e4fcb40d8">00886</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Xml::Unknown</a>;
<a name="l00887"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a37512fe7e1bedb57d57ff5799cce6e59">00887</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Xml::Text</a>;
<a name="l00888"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#ad573bea5abccc16b7d355fda4a8a6ff4">00888</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>;
<a name="l00889"></a>00889 
<a name="l00890"></a>00890 <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; unconst()<span class="keyword"> const </span>{<span class="keywordflow">return</span> *<span class="keyword">const_cast&lt;</span><a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);}
<a name="l00891"></a>00891 
<a name="l00892"></a>00892 TiXmlNode*      tiNode; <span class="comment">// the lone data member</span>
<a name="l00893"></a>00893 };
<a name="l00894"></a>00894 
<a name="l00900"></a>00900 <span class="comment">// Do this inline so we don&#39;t have to pass the ostream through the API.</span>
<a name="l00901"></a><a class="code" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce">00901</a> <span class="keyword">inline</span> std::ostream&amp; <a class="code" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;</a>(std::ostream&amp; o, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Xml::Node</a>&amp; xmlNode) {
<a name="l00902"></a>00902     <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> output;
<a name="l00903"></a>00903     xmlNode.<a class="code" href="classSimTK_1_1Xml_1_1Node.html#a577c79035793ee0090d3826623535706" title="Serialize this node (and everything it contains) to the given String.">writeToString</a>(output);
<a name="l00904"></a>00904     <span class="keywordflow">return</span> o &lt;&lt; output;
<a name="l00905"></a>00905 }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 
<a name="l00908"></a>00908 
<a name="l00909"></a>00909 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00910"></a>00910 <span class="comment">//                          XML NODE ITERATOR</span>
<a name="l00911"></a>00911 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00915"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html">00915</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> 
<a name="l00916"></a>00916 :   <span class="keyword">public</span> std::iterator&lt;std::bidirectional_iterator_tag, Xml::Node&gt; {
<a name="l00917"></a>00917 <span class="keyword">public</span>:
<a name="l00918"></a>00918 
<a name="l00919"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#ab2a9a6c65745b4566c135d1798d5952e">00919</a> <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>(<a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a> allowed=AnyNodes) 
<a name="l00920"></a>00920 :   allowed(allowed) {}
<a name="l00921"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a32b1c149a0150bec8b3f9776a31dbc68">00921</a> <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>(<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node, <a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a> allowed=AnyNodes) 
<a name="l00922"></a>00922 :   node(node), allowed(allowed) {}
<a name="l00923"></a>00923 
<a name="l00926"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a4876bd55430dd51448c65c99866f4c93">00926</a> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; src) 
<a name="l00927"></a>00927 :   node(*src), allowed(src.allowed) {}
<a name="l00929"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#acd37fea199a374c999599dbb1b0ea311">00929</a> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#acd37fea199a374c999599dbb1b0ea311" title="An iterator destructor never deletes the object to which it refers.">~node_iterator</a>() {node.setTiNodePtr(0);}
<a name="l00932"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a1e07738d69309c7c2f3bf1fe2bb503c4">00932</a> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; src) 
<a name="l00933"></a>00933 {   node = *src; allowed = src.allowed; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; operator++();   <span class="comment">// prefix</span>
<a name="l00936"></a>00936 <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> operator++(<span class="keywordtype">int</span>); <span class="comment">// postfix</span>
<a name="l00937"></a>00937 <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; operator--();   <span class="comment">// prefix</span>
<a name="l00938"></a>00938 <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> operator--(<span class="keywordtype">int</span>); <span class="comment">// postfix</span>
<a name="l00939"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a8dac34c8aa8dc5478aef0778dda6d1d3">00939</a> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a8dac34c8aa8dc5478aef0778dda6d1d3">operator*</a>() {<span class="keywordflow">return</span> node;}
<a name="l00940"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a594295636946c6d34f226572fc9bd923">00940</a> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>* <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a594295636946c6d34f226572fc9bd923">operator-&gt;</a>() {<span class="keywordflow">return</span> &amp;node;}
<a name="l00941"></a>00941 <span class="comment">// It&#39;s the iterator that&#39;s const; it still points to a non-const object</span>
<a name="l00942"></a>00942 <span class="comment">// just like a char* const p.</span>
<a name="l00943"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#af5f05b4eaea6b00885dd6d4d6c1c528a">00943</a> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#af5f05b4eaea6b00885dd6d4d6c1c528a">operator*</a>()<span class="keyword">  const </span>{<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp;<span class="keyword">&gt;</span>(node);}
<a name="l00944"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#af319b1939fa20ab20f30aefd5d228087">00944</a> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>* <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#af319b1939fa20ab20f30aefd5d228087">operator-&gt;</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>*<span class="keyword">&gt;</span>(&amp;node);}
<a name="l00945"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#af36062e5a7c3e096fd803235769e4f69">00945</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#af36062e5a7c3e096fd803235769e4f69">operator==</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; other)<span class="keyword"> const </span>{<span class="keywordflow">return</span> other.node==node;}
<a name="l00946"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#add8371f6a0e5bd8f565eab6f8bd52875">00946</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#add8371f6a0e5bd8f565eab6f8bd52875">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; other)<span class="keyword"> const </span>{<span class="keywordflow">return</span> other.node!=node;}
<a name="l00947"></a>00947 
<a name="l00948"></a>00948 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00949"></a>00949                                  <span class="keyword">protected</span>:
<a name="l00950"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a8cf7ec78fecc72f85f89e281615fe86e">00950</a> <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>(TiXmlNode* tiNode, <a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a> allowed=AnyNodes) 
<a name="l00951"></a>00951 :   node(tiNode), allowed(allowed) {}
<a name="l00952"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a12355cc7cd03135e4678d30f1cd75a9c">00952</a> <span class="keywordtype">void</span> reassign(TiXmlNode* tiNode)
<a name="l00953"></a>00953 {   node.setTiNodePtr(tiNode); }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00956"></a>00956                                   <span class="keyword">private</span>:
<a name="l00957"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a6da91779d499b1ad3035fe196aecd99a">00957</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>;
<a name="l00958"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#aee787d4b6e5639c308b632173814ece7">00958</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Xml::Node</a>;
<a name="l00959"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#ad573bea5abccc16b7d355fda4a8a6ff4">00959</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>;
<a name="l00960"></a><a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#ad4ee202f3a1549ce45c613ddce919565">00960</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">Xml::element_iterator</a>;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>            node;       <span class="comment">// data members</span>
<a name="l00963"></a>00963 <a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a>        allowed;
<a name="l00964"></a>00964 };
<a name="l00965"></a>00965 
<a name="l00966"></a>00966 
<a name="l00967"></a>00967 
<a name="l00968"></a>00968 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00969"></a>00969 <span class="comment">//                          XML ELEMENT ITERATOR</span>
<a name="l00970"></a>00970 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00975"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html">00975</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>
<a name="l00976"></a>00976 :   <span class="keyword">public</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> {
<a name="l00977"></a>00977 <span class="keyword">public</span>:
<a name="l00978"></a>00978 
<a name="l00981"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#aff45a7e3df5957a36ed9044679b62158">00981</a> <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag=<span class="stringliteral">&quot;&quot;</span>) 
<a name="l00982"></a>00982 :   <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>(ElementNode), tag(tag) {}
<a name="l00985"></a>00985 <span class="keyword">inline</span> <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>(<a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>&amp; elt, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag=<span class="stringliteral">&quot;&quot;</span>); <span class="comment">// below</span>
<a name="l00986"></a>00986 
<a name="l00989"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#ad3f5eaa555b8dee104ffb0bdc543bbe9">00989</a> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>&amp; src) 
<a name="l00990"></a>00990 :   <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>(src), tag(src.tag) {}
<a name="l00991"></a>00991 
<a name="l00994"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#a778c1cf39fe2771886cfe20203989769">00994</a> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>&amp; src) 
<a name="l00995"></a>00995 {   upcast()=src; tag = src.tag; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>&amp; operator++();   <span class="comment">// prefix</span>
<a name="l00998"></a>00998 <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a> operator++(<span class="keywordtype">int</span>); <span class="comment">// postfix</span>
<a name="l00999"></a>00999 <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>&amp; operator--();   <span class="comment">// prefix</span>
<a name="l01000"></a>01000 <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a> operator--(<span class="keywordtype">int</span>); <span class="comment">// postfix</span>
<a name="l01001"></a>01001 <span class="keyword">inline</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>&amp; <a class="code" href="namespaceSimTK.html#abeff0b397e256732a5de56eb20999afd">operator*</a>() <span class="keyword">const</span>; <span class="comment">// below</span>
<a name="l01002"></a>01002 <span class="keyword">inline</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>* operator-&gt;() <span class="keyword">const</span>; <span class="comment">// below</span>
<a name="l01003"></a>01003 
<a name="l01004"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#a546432bc9d8848c0563c3dd1cc145296">01004</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceSimTK.html#ac56336ea74b71f07f371d943bd5cdba0">operator==</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>&amp; other)<span class="keyword"> const </span>
<a name="l01005"></a>01005 <span class="keyword"></span>{   <span class="keywordflow">return</span> other.upcast()==upcast();}
<a name="l01006"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#a48d046df23674ddf9e14df8a515c9dd3">01006</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceSimTK.html#aac639daeeac2aca1f6b4e6d8da68488d">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>&amp; other)<span class="keyword"> const </span>
<a name="l01007"></a>01007 <span class="keyword"></span>{   <span class="keywordflow">return</span> other.upcast()!=upcast();}
<a name="l01008"></a>01008 
<a name="l01009"></a>01009 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01010"></a>01010                                    <span class="keyword">private</span>:
<a name="l01011"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#a6da91779d499b1ad3035fe196aecd99a">01011</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>;
<a name="l01012"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#ad573bea5abccc16b7d355fda4a8a6ff4">01012</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>;
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>(TiXmlElement* tiElt, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag=<span class="stringliteral">&quot;&quot;</span>) 
<a name="l01015"></a>01015 :   <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>((TiXmlNode*)tiElt, ElementNode), tag(tag) {}
<a name="l01016"></a>01016 <span class="keywordtype">void</span> reassign(TiXmlElement* tiElt)
<a name="l01017"></a>01017 {   upcast().<a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html#a12355cc7cd03135e4678d30f1cd75a9c">reassign</a>((TiXmlNode*)tiElt); }
<a name="l01018"></a>01018 
<a name="l01019"></a>01019 <span class="keyword">const</span> node_iterator&amp; upcast()<span class="keyword"> const </span>
<a name="l01020"></a>01020 <span class="keyword"></span>{   <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>node_iterator*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l01021"></a>01021 node_iterator&amp; upcast() 
<a name="l01022"></a>01022 {   <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span>node_iterator*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 String          tag;    <span class="comment">// lone data member</span>
<a name="l01025"></a>01025 };
<a name="l01026"></a>01026 
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 
<a name="l01030"></a>01030 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01031"></a>01031 <span class="comment">//                               XML ELEMENT</span>
<a name="l01032"></a>01032 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01046"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html">01046</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> : <span class="keyword">public</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> {
<a name="l01047"></a>01047 <span class="keyword">public</span>:
<a name="l01048"></a>01048 
<a name="l01056"></a>01056 
<a name="l01059"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#ace92fc2051430e6dc12eec23135bc409">01059</a> <a class="code" href="classSimTK_1_1Xml_1_1Element.html#ace92fc2051430e6dc12eec23135bc409" title="Create an empty Element handle; this is suitable only for holding references to other Elements...">Element</a>() : <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>() {}
<a name="l01060"></a>01060 
<a name="l01073"></a>01073 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tagWord, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; value=<span class="stringliteral">&quot;&quot;</span>);
<a name="l01074"></a>01074 
<a name="l01080"></a>01080 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01081"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#aeeea0c8fd0fe18efb95f2907ac055451">01081</a> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tagWord, <span class="keyword">const</span> T&amp; value)
<a name="l01082"></a>01082 {   <span class="keyword">new</span>(<span class="keyword">this</span>) <a class="code" href="classSimTK_1_1Xml_1_1Element.html#aeeea0c8fd0fe18efb95f2907ac055451" title="Create a new value element and set its initial value to the text equivalent of any type T for which a...">Element</a>(tagWord, <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>(value)); }
<a name="l01083"></a>01083 
<a name="l01087"></a>01087 <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> clone() <span class="keyword">const</span>;
<a name="l01088"></a>01088 
<a name="l01091"></a>01091 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getElementTag() <span class="keyword">const</span>;
<a name="l01093"></a>01093 <span class="keywordtype">void</span> setElementTag(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag);
<a name="l01094"></a>01094 
<a name="l01100"></a>01100 <span class="keywordtype">void</span> insertNodeBefore(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; pos, <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> node);
<a name="l01106"></a>01106 <span class="keywordtype">void</span> insertNodeAfter(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; pos, <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> node);
<a name="l01112"></a>01112 <span class="keywordtype">void</span> eraseNode(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; deleteThis);
<a name="l01118"></a>01118 <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> removeNode(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>&amp; removeThis);
<a name="l01132"></a>01132 
<a name="l01138"></a>01138 <span class="keywordtype">bool</span> isValueElement() <span class="keyword">const</span>;
<a name="l01139"></a>01139 
<a name="l01147"></a>01147 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getValue() <span class="keyword">const</span>;
<a name="l01148"></a>01148 
<a name="l01154"></a>01154 <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; updValue();
<a name="l01155"></a>01155 
<a name="l01161"></a>01161 <span class="keywordtype">void</span> setValue(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; value);
<a name="l01162"></a>01162 
<a name="l01166"></a>01166 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01167"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4">01167</a> <span class="keywordtype">void</span> setValueAs(<span class="keyword">const</span> T&amp; value) 
<a name="l01168"></a>01168 {   setValue(<a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>(value)); }
<a name="l01169"></a>01169 
<a name="l01176"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec">01176</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; T getValueAs()<span class="keyword"> const </span>
<a name="l01177"></a>01177 <span class="keyword"></span>{   T out; convertStringTo(getValue(),out); <span class="keywordflow">return</span> out;}
<a name="l01178"></a>01178 
<a name="l01181"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a665fafcd7535ac1db55c9ed81caea4c3">01181</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> getValueAs(T&amp; out)<span class="keyword"> const </span>
<a name="l01182"></a>01182 <span class="keyword"></span>{   convertStringTo(getValue(),out); }
<a name="l01183"></a>01183 
<a name="l01191"></a>01191 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; 
<a name="l01192"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#af527410d9e2b0483da3b7384d8c497ec">01192</a> getRequiredElementValue(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag)<span class="keyword"> const</span>
<a name="l01193"></a>01193 <span class="keyword"></span>{   <span class="keywordflow">return</span> unconst().getRequiredElement(tag).getValue(); }
<a name="l01194"></a>01194 
<a name="l01198"></a>01198 <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> 
<a name="l01199"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#aaeeab5895d7485590ab1fec6177c7a91">01199</a> getOptionalElementValue(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; def=<span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l01200"></a>01200 <span class="keyword"></span>{   <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> opt(unconst().getOptionalElement(tag));
<a name="l01201"></a>01201     <span class="keywordflow">return</span> opt.<a class="code" href="classSimTK_1_1Xml_1_1Node.html#a8a08c6ea7d9b3362a5b2af3b7012d09a" title="Return true if this Node handle is referencing some node, false if the Node handle is empty...">isValid</a>() ? opt.<a class="code" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce" title="Get the text value of this value element.">getValue</a>() : def; }
<a name="l01202"></a>01202 
<a name="l01211"></a>01211 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; T  
<a name="l01212"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#acd51b037e620848e76d1591cdb26a457">01212</a> getRequiredElementValueAs(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag)<span class="keyword"> const</span>
<a name="l01213"></a>01213 <span class="keyword"></span>{   T out; convertStringTo(unconst().getRequiredElementValue(tag), out); 
<a name="l01214"></a>01214     <span class="keywordflow">return</span> out; }
<a name="l01215"></a>01215 
<a name="l01227"></a>01227 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; T 
<a name="l01228"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a2bf04099eb57a7ce81de228ba6b2c034">01228</a> getOptionalElementValueAs(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag, <span class="keyword">const</span> T&amp; def)<span class="keyword"> const</span>
<a name="l01229"></a>01229 <span class="keyword"></span>{   <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> opt(unconst().getOptionalElement(tag));
<a name="l01230"></a>01230     <span class="keywordflow">if</span> (!opt.<a class="code" href="classSimTK_1_1Xml_1_1Node.html#a8a08c6ea7d9b3362a5b2af3b7012d09a" title="Return true if this Node handle is referencing some node, false if the Node handle is empty...">isValid</a>()) <span class="keywordflow">return</span> def;
<a name="l01231"></a>01231     T out; convertStringTo(opt.<a class="code" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce" title="Get the text value of this value element.">getValue</a>(), out); <span class="keywordflow">return</span> out; }
<a name="l01241"></a>01241 <span class="keywordtype">bool</span> hasAttribute(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name) <span class="keyword">const</span>;
<a name="l01242"></a>01242 
<a name="l01245"></a>01245 <span class="keywordtype">void</span> setAttributeValue(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; value);
<a name="l01246"></a>01246 
<a name="l01251"></a>01251 <span class="keywordtype">void</span> eraseAttribute(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name);
<a name="l01252"></a>01252 
<a name="l01255"></a>01255 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; 
<a name="l01256"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a65d6cb52b56efd3d9a1202ac827e1812">01256</a> getRequiredAttributeValue(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name)<span class="keyword"> const</span>
<a name="l01257"></a>01257 <span class="keyword"></span>{   <span class="keywordflow">return</span> unconst().getRequiredAttribute(name).getValue(); }
<a name="l01258"></a>01258 
<a name="l01265"></a>01265 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; T 
<a name="l01266"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a12c6820ae4a6507752eefd1ea960fd46">01266</a> getRequiredAttributeValueAs(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name)<span class="keyword"> const</span>
<a name="l01267"></a>01267 <span class="keyword"></span>{   T out; convertStringTo(getRequiredAttributeValue(name),out); <span class="keywordflow">return</span> out; }
<a name="l01268"></a>01268 
<a name="l01275"></a>01275 <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> 
<a name="l01276"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#ae54dacef8bea4acac95a89ce5aefb44d">01276</a> getOptionalAttributeValue(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; def=<span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l01277"></a>01277 <span class="keyword"></span>{   <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> attr = unconst().getOptionalAttribute(name);
<a name="l01278"></a>01278     <span class="keywordflow">if</span> (!attr.<a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a73dd96ffa2cbe7b3fc45b94598f26b4a" title="Is this handle currently holding an attribute?">isValid</a>()) <span class="keywordflow">return</span> def;
<a name="l01279"></a>01279     <span class="keywordflow">return</span> attr.<a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a4d68b6c1aade2f9da74a639ec2ecc898" title="If this is a valid attribute handle, get the value of the attribute as a String, not including the qu...">getValue</a>(); }
<a name="l01280"></a>01280 
<a name="l01291"></a>01291 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; T 
<a name="l01292"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a24d8bc6dc30f3d97af5a393a7b057b83">01292</a> getOptionalAttributeValueAs(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name, <span class="keyword">const</span> T&amp; def)<span class="keyword"> const</span>
<a name="l01293"></a>01293 <span class="keyword"></span>{   <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> attr = unconst().getOptionalAttribute(name);
<a name="l01294"></a>01294     <span class="keywordflow">if</span> (!attr.<a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a73dd96ffa2cbe7b3fc45b94598f26b4a" title="Is this handle currently holding an attribute?">isValid</a>()) <span class="keywordflow">return</span> def;
<a name="l01295"></a>01295     T out; convertStringTo(attr.<a class="code" href="classSimTK_1_1Xml_1_1Attribute.html#a4d68b6c1aade2f9da74a639ec2ecc898" title="If this is a valid attribute handle, get the value of the attribute as a String, not including the qu...">getValue</a>(), out); <span class="keywordflow">return</span> out; }
<a name="l01296"></a>01296 
<a name="l01299"></a>01299 <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> getRequiredAttribute(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name);
<a name="l01300"></a>01300 
<a name="l01304"></a>01304 <a class="code" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> getOptionalAttribute(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; name);
<a name="l01305"></a>01305 
<a name="l01314"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a34d797fd21a8b3d851616dc8d00241a6">01314</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;Attribute&gt;</a> getAllAttributes()
<a name="l01315"></a>01315 {   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;Attribute&gt;</a>(attribute_begin(), attribute_end()); }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317 
<a name="l01321"></a>01321 <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a> attribute_begin();
<a name="l01324"></a>01324 <a class="code" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a> attribute_end() <span class="keyword">const</span>;
<a name="l01338"></a>01338 
<a name="l01340"></a>01340 <span class="keywordtype">bool</span> hasElement(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag) <span class="keyword">const</span>;
<a name="l01343"></a>01343 <span class="keywordtype">bool</span> hasNode(<a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a> allowed=AnyNodes) <span class="keyword">const</span>;
<a name="l01344"></a>01344 
<a name="l01349"></a>01349 <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> getRequiredElement(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag);
<a name="l01350"></a>01350 
<a name="l01354"></a>01354 <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> getOptionalElement(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag);
<a name="l01355"></a>01355 
<a name="l01363"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#af9c43f8749c9def7a0b65136e8fc1329">01363</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;Element&gt;</a> getAllElements(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag=<span class="stringliteral">&quot;&quot;</span>)
<a name="l01364"></a>01364 {   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;Element&gt;</a>(element_begin(tag), element_end()); }
<a name="l01365"></a>01365 
<a name="l01372"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a60f0a78da097f84bf67bef22bb5b5372">01372</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;Node&gt;</a> getAllNodes(<a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a> allowed=AnyNodes)
<a name="l01373"></a>01373 {   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;Node&gt;</a>(node_begin(allowed), node_end()); }
<a name="l01374"></a>01374 
<a name="l01379"></a>01379 <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a> element_begin(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag=<span class="stringliteral">&quot;&quot;</span>);
<a name="l01382"></a>01382 <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a> element_end() <span class="keyword">const</span>;
<a name="l01383"></a>01383 
<a name="l01388"></a>01388 <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> node_begin(<a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">NodeType</a> allowed=AnyNodes);
<a name="l01391"></a>01391 <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> node_end() <span class="keyword">const</span>;
<a name="l01399"></a>01399 <span class="keyword">static</span> <span class="keywordtype">bool</span> isA(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp;);
<a name="l01402"></a>01402 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>&amp; getAs(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node);
<a name="l01405"></a>01405 <span class="keyword">static</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>&amp; getAs(<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node);
<a name="l01408"></a>01408 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01409"></a>01409                                   <span class="keyword">private</span>:
<a name="l01410"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#aee787d4b6e5639c308b632173814ece7">01410</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Xml::Node</a>;
<a name="l01411"></a><a class="code" href="classSimTK_1_1Xml_1_1Element.html#ad4ee202f3a1549ce45c613ddce919565">01411</a> <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">Xml::element_iterator</a>;
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>(TiXmlElement* tiElt) 
<a name="l01414"></a>01414 :   <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>(reinterpret_cast&lt;TiXmlNode*&gt;(tiElt)) {}
<a name="l01415"></a>01415 
<a name="l01416"></a>01416 TiXmlElement&amp; updTiElement() 
<a name="l01417"></a>01417 {   <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>TiXmlElement&amp;<span class="keyword">&gt;</span>(updTiNode()); } 
<a name="l01418"></a>01418 <span class="keyword">const</span> TiXmlElement&amp; getTiElement()<span class="keyword"> const</span>
<a name="l01419"></a>01419 <span class="keyword"></span>{   <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>TiXmlElement&amp;<span class="keyword">&gt;</span>(getTiNode()); }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421 <span class="comment">// Careful: these &quot;Ptr&quot; methods provide raw access to the contained </span>
<a name="l01422"></a>01422 <span class="comment">// pointer without any cleanup or error checking. In particular, </span>
<a name="l01423"></a>01423 <span class="comment">// setTiElementPtr() does not attempt to delete the current contents.</span>
<a name="l01424"></a>01424 <span class="keyword">const</span> TiXmlElement* getTiElementPtr()<span class="keyword"> const </span>
<a name="l01425"></a>01425 <span class="keyword"></span>{   <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>TiXmlElement*<span class="keyword">&gt;</span>(getTiNodePtr()); }
<a name="l01426"></a>01426 TiXmlElement*       updTiElementPtr()
<a name="l01427"></a>01427 {   <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>TiXmlElement*<span class="keyword">&gt;</span>(updTiNodePtr()); }
<a name="l01428"></a>01428 <span class="keywordtype">void</span>                setTiElementPtr(TiXmlElement* elt)
<a name="l01429"></a>01429 {   setTiNodePtr(reinterpret_cast&lt;TiXmlNode*&gt;(elt)); }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431 Element&amp; unconst()<span class="keyword"> const </span>{<span class="keywordflow">return</span> *<span class="keyword">const_cast&lt;</span>Element*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);}
<a name="l01432"></a>01432 
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="comment">// no data members; see Node</span>
<a name="l01435"></a>01435 };
<a name="l01436"></a>01436 
<a name="l01437"></a>01437 
<a name="l01438"></a>01438 
<a name="l01439"></a>01439 <span class="comment">// A few element_iterator inline definitions had to wait for Element to be</span>
<a name="l01440"></a>01440 <span class="comment">// defined.</span>
<a name="l01441"></a>01441 <span class="keyword">inline</span> <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#aff45a7e3df5957a36ed9044679b62158" title="This is the default constructor which leaves the element_iterator empty, and you can optionally set t...">Xml::element_iterator::element_iterator</a>
<a name="l01442"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#ac1b3cb4cb94ae89d5486b8e3ea85ec49">01442</a>    (<a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>&amp; elt, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; tag) 
<a name="l01443"></a>01443 :   <a class="code" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">Xml::node_iterator</a>(elt, <a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca9e989384ca13f6904a03508b95daca5e" title="Element node type and only-Elements filter.">Xml::ElementNode</a>), tag(tag) {}
<a name="l01444"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#a4ac0e2a649a9a92ee36fa8a770a0d40f">01444</a> <span class="keyword">inline</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>&amp; <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#a4ac0e2a649a9a92ee36fa8a770a0d40f">Xml::element_iterator::operator*</a>()<span class="keyword"> const </span>
<a name="l01445"></a>01445 <span class="keyword"></span>{   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html#a869b394c523a22dc160a5990850457e3" title="Recast a Node to a const Element, throwing an error if the Node is not actually an element node...">Element::getAs</a>(*upcast());}
<a name="l01446"></a><a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#a6242b99be499cc0924116bc95216488a">01446</a> <span class="keyword">inline</span> <a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>* <a class="code" href="classSimTK_1_1Xml_1_1element__iterator.html#a6242b99be499cc0924116bc95216488a">Xml::element_iterator::operator-&gt;</a>()<span class="keyword"> const </span>
<a name="l01447"></a>01447 <span class="keyword"></span>{   <span class="keywordflow">return</span> &amp;<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a869b394c523a22dc160a5990850457e3" title="Recast a Node to a const Element, throwing an error if the Node is not actually an element node...">Element::getAs</a>(*upcast());}
<a name="l01448"></a>01448 
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01453"></a>01453 <span class="comment">//                               XML TEXT NODE</span>
<a name="l01454"></a>01454 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01456"></a><a class="code" href="classSimTK_1_1Xml_1_1Text.html">01456</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> : <span class="keyword">public</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> {
<a name="l01457"></a>01457 <span class="keyword">public</span>:
<a name="l01460"></a><a class="code" href="classSimTK_1_1Xml_1_1Text.html#aecf6e2a0e6d1b0d72b474b6cb3687557">01460</a> <a class="code" href="classSimTK_1_1Xml_1_1Text.html#aecf6e2a0e6d1b0d72b474b6cb3687557" title="Create an empty Text node handle, suitable only for holding references to other Text nodes...">Text</a>() : <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>() {}
<a name="l01461"></a>01461 
<a name="l01464"></a>01464 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; text);
<a name="l01465"></a>01465 
<a name="l01469"></a>01469 <a class="code" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a> clone() <span class="keyword">const</span>;
<a name="l01470"></a>01470 
<a name="l01473"></a>01473 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getText() <span class="keyword">const</span>;
<a name="l01476"></a>01476 <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; updText();
<a name="l01477"></a>01477 
<a name="l01483"></a>01483 <span class="keyword">static</span> <span class="keywordtype">bool</span> isA(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp;);
<a name="l01486"></a>01486 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a>&amp; getAs(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node);
<a name="l01489"></a>01489 <span class="keyword">static</span> <a class="code" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a>&amp; getAs(<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node);
<a name="l01492"></a>01492 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01493"></a>01493                                    <span class="keyword">private</span>:
<a name="l01494"></a>01494 <span class="comment">// no data members; see Node</span>
<a name="l01495"></a>01495 
<a name="l01496"></a>01496 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element.">Text</a>(TiXmlText* tiText) 
<a name="l01497"></a>01497 :   <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>(reinterpret_cast&lt;TiXmlNode*&gt;(tiText)) {}
<a name="l01498"></a>01498 };
<a name="l01499"></a>01499 
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01503"></a>01503 <span class="comment">//                             XML COMMENT NODE</span>
<a name="l01504"></a>01504 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01506"></a><a class="code" href="classSimTK_1_1Xml_1_1Comment.html">01506</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text.">Comment</a> : <span class="keyword">public</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> {
<a name="l01507"></a>01507 <span class="keyword">public</span>:
<a name="l01510"></a><a class="code" href="classSimTK_1_1Xml_1_1Comment.html#a51ee7d3b5113ce5a3dc193afe2763d61">01510</a> <a class="code" href="classSimTK_1_1Xml_1_1Comment.html#a51ee7d3b5113ce5a3dc193afe2763d61" title="Create an empty Comment node handle, suitable only for holding references to other Comment nodes...">Comment</a>() : <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>() {}
<a name="l01511"></a>01511 
<a name="l01516"></a>01516 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text.">Comment</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; text);
<a name="l01517"></a>01517 
<a name="l01521"></a>01521 <a class="code" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text.">Comment</a> clone() <span class="keyword">const</span>;
<a name="l01522"></a>01522 
<a name="l01528"></a>01528 <span class="keyword">static</span> <span class="keywordtype">bool</span> isA(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp;);
<a name="l01531"></a>01531 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text.">Comment</a>&amp; getAs(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node);
<a name="l01534"></a>01534 <span class="keyword">static</span> <a class="code" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text.">Comment</a>&amp; getAs(<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node);
<a name="l01537"></a>01537 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01538"></a>01538                                    <span class="keyword">private</span>:
<a name="l01539"></a>01539 <span class="comment">// no data members; see Node</span>
<a name="l01540"></a>01540 
<a name="l01541"></a>01541 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text.">Comment</a>(TiXmlComment* tiComment) 
<a name="l01542"></a>01542 :   <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>(reinterpret_cast&lt;TiXmlNode*&gt;(tiComment)) {}
<a name="l01543"></a>01543 };
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 
<a name="l01547"></a>01547 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01548"></a>01548 <span class="comment">//                             XML UNKNOWN NODE</span>
<a name="l01549"></a>01549 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01551"></a><a class="code" href="classSimTK_1_1Xml_1_1Unknown.html">01551</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Unknown</a> : <span class="keyword">public</span> <a class="code" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings.">Xml</a>::<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a> {
<a name="l01552"></a>01552 <span class="keyword">public</span>:
<a name="l01555"></a><a class="code" href="classSimTK_1_1Xml_1_1Unknown.html#ab4c34efd76b61edef0b9653c833b3af1">01555</a> <a class="code" href="classSimTK_1_1Xml_1_1Unknown.html#ab4c34efd76b61edef0b9653c833b3af1" title="Create an empty Unknown node handle, suitable only for holding references to other Unknown nodes...">Unknown</a>() : <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>() {}
<a name="l01556"></a>01556 
<a name="l01562"></a>01562 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Unknown</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; contents);
<a name="l01563"></a>01563 
<a name="l01567"></a><a class="code" href="classSimTK_1_1Xml_1_1Unknown.html#ab2a727090c6d782e3f3d7f5a4b9c94cc">01567</a> <a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Unknown</a>(<a class="code" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>&amp; element, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; contents)
<a name="l01568"></a>01568 {   <span class="keyword">new</span>(<span class="keyword">this</span>) <a class="code" href="classSimTK_1_1Xml_1_1Unknown.html#ab2a727090c6d782e3f3d7f5a4b9c94cc" title="Create a new Unknown node and append it to the list of nodes that are children of the given Element...">Unknown</a>(contents); 
<a name="l01569"></a>01569     element.<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a4e79c09e3f397a48c65f40f86d113664" title="Insert a node into the list of this Element&#39;s children, just before the node pointed to by the suppli...">insertNodeBefore</a>(element.<a class="code" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end</a>(), *<span class="keyword">this</span>); }
<a name="l01570"></a>01570 
<a name="l01574"></a>01574 <a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Unknown</a> clone() <span class="keyword">const</span>;
<a name="l01575"></a>01575 
<a name="l01578"></a>01578 <span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; getContents() <span class="keyword">const</span>;
<a name="l01581"></a>01581 <span class="keywordtype">void</span> setContents(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>&amp; contents);
<a name="l01582"></a>01582 
<a name="l01588"></a>01588 <span class="keyword">static</span> <span class="keywordtype">bool</span> isA(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp;);
<a name="l01591"></a>01591 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Unknown</a>&amp; getAs(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node);
<a name="l01594"></a>01594 <span class="keyword">static</span> <a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Unknown</a>&amp; getAs(<a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>&amp; node);
<a name="l01597"></a>01597 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01598"></a>01598                                    <span class="keyword">private</span>:
<a name="l01599"></a>01599 <span class="comment">// no data members; see Node</span>
<a name="l01600"></a>01600 
<a name="l01601"></a>01601 <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around.">Unknown</a>(TiXmlUnknown* tiUnknown) 
<a name="l01602"></a>01602 :   <a class="code" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree.">Node</a>(reinterpret_cast&lt;TiXmlNode*&gt;(tiUnknown)) {}
<a name="l01603"></a>01603 };
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 } <span class="comment">// namespace SimTK</span>
<a name="l01606"></a>01606 
<a name="l01607"></a>01607 <span class="preprocessor">#endif // SimTK_SimTKCOMMON_XML_H_</span>
<a name="l01608"></a>01608 <span class="preprocessor"></span>
<a name="l01609"></a>01609 
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="Xml_8h.html">Xml.h</a>      </li>

    <li class="footer">Generated on Wed Oct 9 2013 08:38:48 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
