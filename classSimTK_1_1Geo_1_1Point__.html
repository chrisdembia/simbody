<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::Geo::Point_&lt; P &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1Geo_1_1Point__.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Geo::Point_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::Geo::Point_" -->
<p>A 3d point primitive represented by a Vec3 from the origin of an unspecified frame, and a collection of point-related utility methods.  
 <a href="classSimTK_1_1Geo_1_1Point__.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Geo__Point_8h_source.html">Geo_Point.h</a>&gt;</code></p>

<p><a href="classSimTK_1_1Geo_1_1Point__-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a2a2ceb87665ce7b5bb1deaceef04ab29">Point_</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an uninitialized Point object; the location will be garbage.  <a href="#a2a2ceb87665ce7b5bb1deaceef04ab29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a0ecd1e5c04e396cf8426f912bbd45cb7">Point_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;location)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a Point with the given location. Also serves as implicit conversion from Vec3 to <a class="el" href="classSimTK_1_1Geo.html#ab97c535710a7081de18ebc4257765022">Geo::Point</a>.  <a href="#a0ecd1e5c04e396cf8426f912bbd45cb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html">Point_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a342017a965f8f0d00171343f2299ed65">setLocation</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;location)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the location of this point.  <a href="#a342017a965f8f0d00171343f2299ed65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a3f117f8213cbadc1cc1fc410d51956c7">getLocation</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of this Point.  <a href="#a3f117f8213cbadc1cc1fc410d51956c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a0830cd38f173881bf162c93c8699244b">calcDistance</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between this point and another one whose location is expressed in the same frame (expensive).  <a href="#a0830cd38f173881bf162c93c8699244b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#af5b1fc5890183910e2c17f03a0b92300">findDistanceSqr</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the square of the distance between this point and another one whose location is expressed in the same frame (cheap).  <a href="#af5b1fc5890183910e2c17f03a0b92300"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous point-related utilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These static methods work with points or collections of points.</p>
<p>Collections of points are represented either as an Array of point locations or as an indirect Array of pointers to point locations, which can save a lot of copying for large point sets. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a398f9d5b3d838a38e36825e51e519ac9">calcDistance</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between two points (expensive).  <a href="#a398f9d5b3d838a38e36825e51e519ac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a728dbcfc2fd830afbee8ecc0edc512b5">findDistanceSqr</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the square of the distance between two points (cheap).  <a href="#a728dbcfc2fd830afbee8ecc0edc512b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#aee36d794410d937b32171ac93705a3cb">findMidpoint</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the point midway between two points.  <a href="#aee36d794410d937b32171ac93705a3cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#abdcd93886ac3fb0203916f5e2da270d2">pointsAreNumericallyCoincident</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two points whose locations are known to an accuracy <em>tol</em> are numerically indistinguishable.  <a href="#abdcd93886ac3fb0203916f5e2da270d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a3c5d2c97d06c2c9c15385278ee4255e2">pointsAreNumericallyCoincident</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2, RealP tol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature with explicitly-supplied tolerance.  <a href="#a3c5d2c97d06c2c9c15385278ee4255e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a7f2a2c300a8cbfa0b848b80fbc144242">findSupportPoint</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;direction, int &amp;most, RealP &amp;mostCoord)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points, find the one that is the furthest in a given direction, and return its index and location along that direction.  <a href="#a7f2a2c300a8cbfa0b848b80fbc144242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a731bb2637a8184660f5dbf61436db593">findSupportPointIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;direction, int &amp;most, RealP &amp;mostCoord)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#a731bb2637a8184660f5dbf61436db593"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a1ae12783fe37fc35b21f842874c8c5ea">findExtremePoints</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;direction, int &amp;least, int &amp;most, RealP &amp;leastCoord, RealP &amp;mostCoord)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points, find the two points that are the most extreme along a given direction (not necessarily distinct), and return their indices and locations along the given direction.  <a href="#a1ae12783fe37fc35b21f842874c8c5ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a6d8874d5eeea64737a7ea9f5e7a9a5a2">findExtremePointsIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;direction, int &amp;least, int &amp;most, RealP &amp;leastCoord, RealP &amp;mostCoord)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#a6d8874d5eeea64737a7ea9f5e7a9a5a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a2ae91f41cffde8982f9aa9df4772d090">calcCentroid</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points_F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points, calculate the centroid (average location) of those points.  <a href="#a2ae91f41cffde8982f9aa9df4772d090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a766f2ad6b99c6e1be933e5be2431ee8d">calcCentroidIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points_F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#a766f2ad6b99c6e1be933e5be2431ee8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#aa90b727e7aaaa6bba0be0f45cf14f8a3">calcCovariance</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points_F, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;centroid, <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;covariance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points, calculate the centroid (average location) and covariance matrix of those points.  <a href="#aa90b727e7aaaa6bba0be0f45cf14f8a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a21fa0f91a4149e4caae35ea101be77af">calcCovarianceIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points_F, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;centroid, <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;covariance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#a21fa0f91a4149e4caae35ea101be77af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a76682893e79f6893b143f3f98b056b3d">calcPrincipalComponents</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points_F, <a class="el" href="classSimTK_1_1Transform__.html">TransformP</a> &amp;X_FP)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in an unspecified frame F, find the principal component directions describing the distribution of the points in space.  <a href="#a76682893e79f6893b143f3f98b056b3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a167e51d9bb244c7b043550aadf05def0">calcPrincipalComponentsIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points_F, <a class="el" href="classSimTK_1_1Transform__.html">TransformP</a> &amp;X_FP)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#a167e51d9bb244c7b043550aadf05def0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Axis-aligned bounding box creation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These static methods create a minimal axis-aligned box that includes all of a set of given points.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#acd97445a94f77bdb8dd9cf8646415a70">findAxisAlignedExtremePoints</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points, int least[3], int most[3], <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;low, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;high)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points, find the six points that are the most extreme along the axial directions (not necessarily distinct points).  <a href="#acd97445a94f77bdb8dd9cf8646415a70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a2b150e0c37f95bead85402e8ff596a54">findAxisAlignedExtremePointsIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points, int least[3], int most[3], <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;low, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;high)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#a2b150e0c37f95bead85402e8ff596a54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#acc5885ee6f88429656b6c8c6c4d32e96">calcAxisAlignedBoundingBox</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;support)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the smallest axis-aligned bounding box including all n given points.  <a href="#acc5885ee6f88429656b6c8c6c4d32e96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a33faed8ffeac8046a450cef049b6d5bf">calcAxisAlignedBoundingBox</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature doesn't return support points.  <a href="#a33faed8ffeac8046a450cef049b6d5bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a99018ecf44484328f6526c7d9f5d2eab">calcAxisAlignedBoundingBoxIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;support)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#a99018ecf44484328f6526c7d9f5d2eab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a712ecc9721323e3b51e75de69dc73438">calcAxisAlignedBoundingBoxIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature doesn't return support points.  <a href="#a712ecc9721323e3b51e75de69dc73438"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Oriented bounding box creation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These static methods create a tight-fitting oriented bounding box (OBB) that includes all of a set of given points.</p>
<p>The OBB is not guaranteed to be minimal but will usually be very good. You can optionally obtain the set of support points that determined the size of the box. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a95cb29dc68b233fd81817cabeb78f2e7">findOrientedExtremePoints</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points_F, const <a class="el" href="classSimTK_1_1Rotation__.html">RotationP</a> &amp;R_FB, int least[3], int most[3], <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;low_B, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;high_B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points, find the six points that are the most extreme along specified orientation directions (not necessarily distinct points).  <a href="#a95cb29dc68b233fd81817cabeb78f2e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a4c59a3588f0e0906b03ef83ab324f5f4">findOrientedExtremePointsIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points_F, const <a class="el" href="classSimTK_1_1Rotation__.html">RotationP</a> &amp;R_FB, int least[3], int most[3], <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;low_B, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;high_B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#a4c59a3588f0e0906b03ef83ab324f5f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a5465798feac95e1534e0232f95756855">calcOrientedBoundingBox</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;support, bool optimize=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a tight-fitting oriented bounding box (OBB) that includes all n given points.  <a href="#a5465798feac95e1534e0232f95756855"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#afff738a3fa51ae4e379ab100d658bfbd">calcOrientedBoundingBox</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature doesn't return support points.  <a href="#afff738a3fa51ae4e379ab100d658bfbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ae5b91e495b48b802fc4ee4e92c8dbb16">calcOrientedBoundingBoxIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;support, bool optimize=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature taking an array of pointers to points rather than the points themselves.  <a href="#ae5b91e495b48b802fc4ee4e92c8dbb16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a9d6e77c1b7f860870789fed793f44c95">calcOrientedBoundingBoxIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points, bool optimize=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature doesn't return support points.  <a href="#a9d6e77c1b7f860870789fed793f44c95"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sphere-related utilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These static methods work with spheres or collections of spheres.</p>
<h3>Bounding spheres</h3>
<p>Bounding sphere methods calculate the smallest sphere around a given set of points such that no point is outside the sphere, although some may be on its surface. How many and specifically which points were actually used to define the sphere can be returned; there will never be more than 4. This information is primarily used to construct bounding sphere algorithms; users normally just need the sphere so can use the simpler signatures.</p>
<p>Bounding sphere methods address roundoff by stretching the sphere enough to guarantee that all points are strictly inside the sphere and that later tests can produce only false positives not false negatives which might cause a contact to be missed. To do that we have to account not just for machine precision, but for relative errors caused by spheres of large radius or spheres that are located far from the origin. These adjustments ensure that if a test point appears numerically to be outside the sphere, it really cannot contact anything that is inside the sphere.</p>
<p>We use a bounding sphere method due originally to Emo Welzl that computes a near-perfect minimal bounding sphere around a set of points with expected O(n) run time. Our implementation has been extensively modified to deal with singular cases so you do not have to precondition the points before asking for their bounding sphere.</p>
<p>We also provide a conventional fast and dumb approximate bounding sphere using Ritter's method as described in Christer Ericson's book. This is mostly useful for testing the Welzl method's accuracy and performance and should not generally be used. A Welzl bounding sphere should never be larger than a Ritter sphere and should normally be substantially smaller. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tiny bounding sphere around a single point.  <a href="#a49341e63fdcb5290af1acfc9156b9663"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a082d91291219035f2fcb971c40b3684c">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p0, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimal bounding sphere around two points.  <a href="#a082d91291219035f2fcb971c40b3684c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ace9d11627d1f525081ec32efe57fd7aa">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p0, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimal bounding sphere around three points.  <a href="#ace9d11627d1f525081ec32efe57fd7aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a3ebd70986aa7f0a0466aeae6c291843a">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p0, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimal bounding sphere around four points.  <a href="#a3ebd70986aa7f0a0466aeae6c291843a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ad7592467141069172a35f136058ff592">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimal bounding sphere around a collection of n points.  <a href="#ad7592467141069172a35f136058ff592"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ad22c3e29308b06e70e7dfc7df3e0d5cb">calcBoundingSphere</a> (const std::vector&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This signature takes an std::vector rather than a <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_</a>; no extra copying is required.  <a href="#ad22c3e29308b06e70e7dfc7df3e0d5cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ab71d8029d017c9c675e5c2e8f4965718">calcBoundingSphereIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimal bounding sphere around a collection of n points, given indirectly as an array of pointers.  <a href="#ab71d8029d017c9c675e5c2e8f4965718"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a6ed44ac9098a19e1d82edada119f4d0d">calcBoundingSphere</a> (const std::vector&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This signature takes an std::vector rather than a <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_</a>; no extra copying is required.  <a href="#a6ed44ac9098a19e1d82edada119f4d0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a51456770f377afd90500e3dfea6ab5f1">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p0, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;which)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create one-point bounding sphere and return the (trivial) support point, of which there is always one.  <a href="#a51456770f377afd90500e3dfea6ab5f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#af91f337fb9b4e42ee956907bfcb0db74">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p0, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;which)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimum sphere around two points.  <a href="#af91f337fb9b4e42ee956907bfcb0db74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#aca1628caca0314c0e4617b3dd4319bef">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p0, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2, bool forceCircumsphere, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;which)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimum sphere around three points.  <a href="#aca1628caca0314c0e4617b3dd4319bef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ab9273f6d6bc41e2de233f5478f3f077e">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p0, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p2, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p3, bool forceCircumsphere, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;which)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a minimum sphere around four points.  <a href="#ab9273f6d6bc41e2de233f5478f3f077e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a6438abc63c5c2b93b8313c9528fe270e">calcBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;which)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an optimal minimum sphere around a collection of n points.  <a href="#a6438abc63c5c2b93b8313c9528fe270e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a498aae5ff58b788fb5d756aacb64408f">calcBoundingSphereIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;which)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature works with an array of pointers to points.  <a href="#a498aae5ff58b788fb5d756aacb64408f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a56514b3f1cd2835190b47e62724224af">calcApproxBoundingSphere</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an approximate bounding sphere. You should normally use <a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663" title="Create a tiny bounding sphere around a single point.">calcBoundingSphere()</a> which will give a smaller sphere.  <a href="#a56514b3f1cd2835190b47e62724224af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a4e66321dfcda41a4d431b11bac7dbbb2">calcApproxBoundingSphere</a> (const std::vector&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This signature takes an std::vector rather than a <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_</a>; no extra copying is required.  <a href="#a4e66321dfcda41a4d431b11bac7dbbb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a0abf7d090bac57683f044d8ff274f2a1">calcApproxBoundingSphereIndirect</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature works with an array of pointers to points.  <a href="#a0abf7d090bac57683f044d8ff274f2a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html#adada1ef22931ae38d1f21a89eb42dbf2">calcApproxBoundingSphereIndirect</a> (const std::vector&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This signature takes an std::vector rather than a <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_</a>; no extra copying is required.  <a href="#adada1ef22931ae38d1f21a89eb42dbf2"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br/>
class SimTK::Geo::Point_&lt; P &gt;</h3>

<p>A 3d point primitive represented by a Vec3 from the origin of an unspecified frame, and a collection of point-related utility methods. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2a2ceb87665ce7b5bb1deaceef04ab29"></a><!-- doxytag: member="SimTK::Geo::Point_::Point_" ref="a2a2ceb87665ce7b5bb1deaceef04ab29" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html">Point_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an uninitialized Point object; the location will be garbage. </p>

</div>
</div>
<a class="anchor" id="a0ecd1e5c04e396cf8426f912bbd45cb7"></a><!-- doxytag: member="SimTK::Geo::Point_::Point_" ref="a0ecd1e5c04e396cf8426f912bbd45cb7" args="(const Vec3P &amp;location)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html">Point_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Point with the given location. Also serves as implicit conversion from Vec3 to <a class="el" href="classSimTK_1_1Geo.html#ab97c535710a7081de18ebc4257765022">Geo::Point</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a342017a965f8f0d00171343f2299ed65"></a><!-- doxytag: member="SimTK::Geo::Point_::setLocation" ref="a342017a965f8f0d00171343f2299ed65" args="(const Vec3P &amp;location)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html">Point_</a>&amp; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a342017a965f8f0d00171343f2299ed65">setLocation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the location of this point. </p>

</div>
</div>
<a class="anchor" id="a3f117f8213cbadc1cc1fc410d51956c7"></a><!-- doxytag: member="SimTK::Geo::Point_::getLocation" ref="a3f117f8213cbadc1cc1fc410d51956c7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&amp; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a3f117f8213cbadc1cc1fc410d51956c7">getLocation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the location of this Point. </p>

</div>
</div>
<a class="anchor" id="a0830cd38f173881bf162c93c8699244b"></a><!-- doxytag: member="SimTK::Geo::Point_::calcDistance" ref="a0830cd38f173881bf162c93c8699244b" args="(const Vec3P &amp;p2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a0830cd38f173881bf162c93c8699244b">calcDistance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the distance between this point and another one whose location is expressed in the same frame (expensive). </p>
<p>Cost is about 30 flops. </p>

</div>
</div>
<a class="anchor" id="af5b1fc5890183910e2c17f03a0b92300"></a><!-- doxytag: member="SimTK::Geo::Point_::findDistanceSqr" ref="af5b1fc5890183910e2c17f03a0b92300" args="(const Vec3P &amp;p2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#af5b1fc5890183910e2c17f03a0b92300">findDistanceSqr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the square of the distance between this point and another one whose location is expressed in the same frame (cheap). </p>
<p>Cost is 8 flops. </p>

</div>
</div>
<a class="anchor" id="a398f9d5b3d838a38e36825e51e519ac9"></a><!-- doxytag: member="SimTK::Geo::Point_::calcDistance" ref="a398f9d5b3d838a38e36825e51e519ac9" args="(const Vec3P &amp;p1, const Vec3P &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static RealP <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a0830cd38f173881bf162c93c8699244b">calcDistance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the distance between two points (expensive). </p>
<p>Cost is about 30 flops. </p>

</div>
</div>
<a class="anchor" id="a728dbcfc2fd830afbee8ecc0edc512b5"></a><!-- doxytag: member="SimTK::Geo::Point_::findDistanceSqr" ref="a728dbcfc2fd830afbee8ecc0edc512b5" args="(const Vec3P &amp;p1, const Vec3P &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static RealP <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#af5b1fc5890183910e2c17f03a0b92300">findDistanceSqr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the square of the distance between two points (cheap). </p>
<p>Cost is 8 flops. </p>

</div>
</div>
<a class="anchor" id="aee36d794410d937b32171ac93705a3cb"></a><!-- doxytag: member="SimTK::Geo::Point_::findMidpoint" ref="aee36d794410d937b32171ac93705a3cb" args="(const Vec3P &amp;p1, const Vec3P &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#aee36d794410d937b32171ac93705a3cb">findMidpoint</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the point midway between two points. </p>
<p>Cost is 4 flops. </p>

</div>
</div>
<a class="anchor" id="abdcd93886ac3fb0203916f5e2da270d2"></a><!-- doxytag: member="SimTK::Geo::Point_::pointsAreNumericallyCoincident" ref="abdcd93886ac3fb0203916f5e2da270d2" args="(const Vec3P &amp;p1, const Vec3P &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#abdcd93886ac3fb0203916f5e2da270d2">pointsAreNumericallyCoincident</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether two points whose locations are known to an accuracy <em>tol</em> are numerically indistinguishable. </p>
<p>We define this to mean that they are so close that a perturbation of their measure numbers by no more than tol could make them coincident. If a measure number has value x, we define a tol-sized perturbation to be max(tol, |x|*tol). We use the default tolerance if none is supplied. Cost is about 20 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Geo.html#a022a5f4a5fc4359d76d67256298a480b" title="Return the default tolerance to use for degeneracy tests and other tests for &quot;too small&quot; or &quot;near eno...">Geo::getDefaultTol()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3c5d2c97d06c2c9c15385278ee4255e2"></a><!-- doxytag: member="SimTK::Geo::Point_::pointsAreNumericallyCoincident" ref="a3c5d2c97d06c2c9c15385278ee4255e2" args="(const Vec3P &amp;p1, const Vec3P &amp;p2, RealP tol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#abdcd93886ac3fb0203916f5e2da270d2">pointsAreNumericallyCoincident</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature with explicitly-supplied tolerance. </p>

</div>
</div>
<a class="anchor" id="a7f2a2c300a8cbfa0b848b80fbc144242"></a><!-- doxytag: member="SimTK::Geo::Point_::findSupportPoint" ref="a7f2a2c300a8cbfa0b848b80fbc144242" args="(const Array_&lt; Vec3P &gt; &amp;points, const UnitVec3P &amp;direction, int &amp;most, RealP &amp;mostCoord)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a7f2a2c300a8cbfa0b848b80fbc144242">findSupportPoint</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>most</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP &amp;&#160;</td>
          <td class="paramname"><em>mostCoord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of points, find the one that is the furthest in a given direction, and return its index and location along that direction. </p>
<p>There must be at least one point in the set. </p>

</div>
</div>
<a class="anchor" id="a731bb2637a8184660f5dbf61436db593"></a><!-- doxytag: member="SimTK::Geo::Point_::findSupportPointIndirect" ref="a731bb2637a8184660f5dbf61436db593" args="(const Array_&lt; const Vec3P * &gt; &amp;points, const UnitVec3P &amp;direction, int &amp;most, RealP &amp;mostCoord)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a731bb2637a8184660f5dbf61436db593">findSupportPointIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>most</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP &amp;&#160;</td>
          <td class="paramname"><em>mostCoord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="a1ae12783fe37fc35b21f842874c8c5ea"></a><!-- doxytag: member="SimTK::Geo::Point_::findExtremePoints" ref="a1ae12783fe37fc35b21f842874c8c5ea" args="(const Array_&lt; Vec3P &gt; &amp;points, const UnitVec3P &amp;direction, int &amp;least, int &amp;most, RealP &amp;leastCoord, RealP &amp;mostCoord)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a1ae12783fe37fc35b21f842874c8c5ea">findExtremePoints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>least</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>most</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP &amp;&#160;</td>
          <td class="paramname"><em>leastCoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP &amp;&#160;</td>
          <td class="paramname"><em>mostCoord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of points, find the two points that are the most extreme along a given direction (not necessarily distinct), and return their indices and locations along the given direction. </p>
<p>There must be at least one point in the set. </p>

</div>
</div>
<a class="anchor" id="a6d8874d5eeea64737a7ea9f5e7a9a5a2"></a><!-- doxytag: member="SimTK::Geo::Point_::findExtremePointsIndirect" ref="a6d8874d5eeea64737a7ea9f5e7a9a5a2" args="(const Array_&lt; const Vec3P * &gt; &amp;points, const UnitVec3P &amp;direction, int &amp;least, int &amp;most, RealP &amp;leastCoord, RealP &amp;mostCoord)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a6d8874d5eeea64737a7ea9f5e7a9a5a2">findExtremePointsIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>least</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>most</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP &amp;&#160;</td>
          <td class="paramname"><em>leastCoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP &amp;&#160;</td>
          <td class="paramname"><em>mostCoord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="a2ae91f41cffde8982f9aa9df4772d090"></a><!-- doxytag: member="SimTK::Geo::Point_::calcCentroid" ref="a2ae91f41cffde8982f9aa9df4772d090" args="(const Array_&lt; Vec3P &gt; &amp;points_F)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a2ae91f41cffde8982f9aa9df4772d090">calcCentroid</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_F</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of points, calculate the centroid (average location) of those points. </p>
<p>Cost is about 3*n+10 flops for n points. </p>

</div>
</div>
<a class="anchor" id="a766f2ad6b99c6e1be933e5be2431ee8d"></a><!-- doxytag: member="SimTK::Geo::Point_::calcCentroidIndirect" ref="a766f2ad6b99c6e1be933e5be2431ee8d" args="(const Array_&lt; const Vec3P * &gt; &amp;points_F)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a766f2ad6b99c6e1be933e5be2431ee8d">calcCentroidIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_F</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="aa90b727e7aaaa6bba0be0f45cf14f8a3"></a><!-- doxytag: member="SimTK::Geo::Point_::calcCovariance" ref="aa90b727e7aaaa6bba0be0f45cf14f8a3" args="(const Array_&lt; Vec3P &gt; &amp;points_F, Vec3P &amp;centroid, SymMat33P &amp;covariance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#aa90b727e7aaaa6bba0be0f45cf14f8a3">calcCovariance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>covariance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of points, calculate the centroid (average location) and covariance matrix of those points. </p>

</div>
</div>
<a class="anchor" id="a21fa0f91a4149e4caae35ea101be77af"></a><!-- doxytag: member="SimTK::Geo::Point_::calcCovarianceIndirect" ref="a21fa0f91a4149e4caae35ea101be77af" args="(const Array_&lt; const Vec3P * &gt; &amp;points_F, Vec3P &amp;centroid, SymMat33P &amp;covariance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a21fa0f91a4149e4caae35ea101be77af">calcCovarianceIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>covariance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="a76682893e79f6893b143f3f98b056b3d"></a><!-- doxytag: member="SimTK::Geo::Point_::calcPrincipalComponents" ref="a76682893e79f6893b143f3f98b056b3d" args="(const Array_&lt; Vec3P &gt; &amp;points_F, TransformP &amp;X_FP)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a76682893e79f6893b143f3f98b056b3d">calcPrincipalComponents</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Transform__.html">TransformP</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of points in an unspecified frame F, find the principal component directions describing the distribution of the points in space. </p>
<p>The result is a frame P with origin at the centroid, x axis along the direction of maximum dispersion, y axis along the direction of minimum dispersion, and z=x X y. Note that clustering of points affects the directions. </p>

</div>
</div>
<a class="anchor" id="a167e51d9bb244c7b043550aadf05def0"></a><!-- doxytag: member="SimTK::Geo::Point_::calcPrincipalComponentsIndirect" ref="a167e51d9bb244c7b043550aadf05def0" args="(const Array_&lt; const Vec3P * &gt; &amp;points_F, TransformP &amp;X_FP)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a167e51d9bb244c7b043550aadf05def0">calcPrincipalComponentsIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Transform__.html">TransformP</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="acd97445a94f77bdb8dd9cf8646415a70"></a><!-- doxytag: member="SimTK::Geo::Point_::findAxisAlignedExtremePoints" ref="acd97445a94f77bdb8dd9cf8646415a70" args="(const Array_&lt; Vec3P &gt; &amp;points, int least[3], int most[3], Vec3P &amp;low, Vec3P &amp;high)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#acd97445a94f77bdb8dd9cf8646415a70">findAxisAlignedExtremePoints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>least</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>most</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of points, find the six points that are the most extreme along the axial directions (not necessarily distinct points). </p>
<p>Return the indices of the extreme points and the locations of the box corners. Note that the corners do not necessarily correspond to any points in the set. There must be at least one point in the set. </p>

</div>
</div>
<a class="anchor" id="a2b150e0c37f95bead85402e8ff596a54"></a><!-- doxytag: member="SimTK::Geo::Point_::findAxisAlignedExtremePointsIndirect" ref="a2b150e0c37f95bead85402e8ff596a54" args="(const Array_&lt; const Vec3P * &gt; &amp;points, int least[3], int most[3], Vec3P &amp;low, Vec3P &amp;high)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a2b150e0c37f95bead85402e8ff596a54">findAxisAlignedExtremePointsIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>least</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>most</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="acc5885ee6f88429656b6c8c6c4d32e96"></a><!-- doxytag: member="SimTK::Geo::Point_::calcAxisAlignedBoundingBox" ref="acc5885ee6f88429656b6c8c6c4d32e96" args="(const Array_&lt; Vec3P &gt; &amp;points, Array_&lt; int &gt; &amp;support)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#acc5885ee6f88429656b6c8c6c4d32e96">calcAxisAlignedBoundingBox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the smallest axis-aligned bounding box including all n given points. </p>
<p>Cost is O(n). </p>

</div>
</div>
<a class="anchor" id="a33faed8ffeac8046a450cef049b6d5bf"></a><!-- doxytag: member="SimTK::Geo::Point_::calcAxisAlignedBoundingBox" ref="a33faed8ffeac8046a450cef049b6d5bf" args="(const Array_&lt; Vec3P &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#acc5885ee6f88429656b6c8c6c4d32e96">calcAxisAlignedBoundingBox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature doesn't return support points. </p>

</div>
</div>
<a class="anchor" id="a99018ecf44484328f6526c7d9f5d2eab"></a><!-- doxytag: member="SimTK::Geo::Point_::calcAxisAlignedBoundingBoxIndirect" ref="a99018ecf44484328f6526c7d9f5d2eab" args="(const Array_&lt; const Vec3P * &gt; &amp;points, Array_&lt; int &gt; &amp;support)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a99018ecf44484328f6526c7d9f5d2eab">calcAxisAlignedBoundingBoxIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="a712ecc9721323e3b51e75de69dc73438"></a><!-- doxytag: member="SimTK::Geo::Point_::calcAxisAlignedBoundingBoxIndirect" ref="a712ecc9721323e3b51e75de69dc73438" args="(const Array_&lt; const Vec3P * &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a99018ecf44484328f6526c7d9f5d2eab">calcAxisAlignedBoundingBoxIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature doesn't return support points. </p>

</div>
</div>
<a class="anchor" id="a95cb29dc68b233fd81817cabeb78f2e7"></a><!-- doxytag: member="SimTK::Geo::Point_::findOrientedExtremePoints" ref="a95cb29dc68b233fd81817cabeb78f2e7" args="(const Array_&lt; Vec3P &gt; &amp;points_F, const RotationP &amp;R_FB, int least[3], int most[3], Vec3P &amp;low_B, Vec3P &amp;high_B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a95cb29dc68b233fd81817cabeb78f2e7">findOrientedExtremePoints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">RotationP</a> &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>least</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>most</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>low_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>high_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of points, find the six points that are the most extreme along specified orientation directions (not necessarily distinct points). </p>
<p>The points are given in an arbitrary frame F. We have an oriented "box" frame B given by its orientation in F, R_FB. The origin of the B frame is coincident with the F frame. We'll find the points that are the most extreme along the B frame axis directions, and we'll also return the corner points <em>in B</em> (that is, the points having minimum and maximum x,y,z values in B). Note that the corners do not necessarily correspond to any points in the set. If you want to know where the corners are in F, just compute R_FB*low_B and R_FB*high_B on return. There must be at least one point in the given set. </p>

</div>
</div>
<a class="anchor" id="a4c59a3588f0e0906b03ef83ab324f5f4"></a><!-- doxytag: member="SimTK::Geo::Point_::findOrientedExtremePointsIndirect" ref="a4c59a3588f0e0906b03ef83ab324f5f4" args="(const Array_&lt; const Vec3P * &gt; &amp;points_F, const RotationP &amp;R_FB, int least[3], int most[3], Vec3P &amp;low_B, Vec3P &amp;high_B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a4c59a3588f0e0906b03ef83ab324f5f4">findOrientedExtremePointsIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">RotationP</a> &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>least</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>most</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>low_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>high_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="a5465798feac95e1534e0232f95756855"></a><!-- doxytag: member="SimTK::Geo::Point_::calcOrientedBoundingBox" ref="a5465798feac95e1534e0232f95756855" args="(const Array_&lt; Vec3P &gt; &amp;points, Array_&lt; int &gt; &amp;support, bool optimize=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a5465798feac95e1534e0232f95756855">calcOrientedBoundingBox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate a tight-fitting oriented bounding box (OBB) that includes all n given points. </p>
<p>The OBB is not guaranteed to be minimal but will usually be very good unless you suppress optimization to save runtime. Cost is O(n). </p>

</div>
</div>
<a class="anchor" id="afff738a3fa51ae4e379ab100d658bfbd"></a><!-- doxytag: member="SimTK::Geo::Point_::calcOrientedBoundingBox" ref="afff738a3fa51ae4e379ab100d658bfbd" args="(const Array_&lt; Vec3P &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a5465798feac95e1534e0232f95756855">calcOrientedBoundingBox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature doesn't return support points. </p>

</div>
</div>
<a class="anchor" id="ae5b91e495b48b802fc4ee4e92c8dbb16"></a><!-- doxytag: member="SimTK::Geo::Point_::calcOrientedBoundingBoxIndirect" ref="ae5b91e495b48b802fc4ee4e92c8dbb16" args="(const Array_&lt; const Vec3P * &gt; &amp;points, Array_&lt; int &gt; &amp;support, bool optimize=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ae5b91e495b48b802fc4ee4e92c8dbb16">calcOrientedBoundingBoxIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature taking an array of pointers to points rather than the points themselves. </p>

</div>
</div>
<a class="anchor" id="a9d6e77c1b7f860870789fed793f44c95"></a><!-- doxytag: member="SimTK::Geo::Point_::calcOrientedBoundingBoxIndirect" ref="a9d6e77c1b7f860870789fed793f44c95" args="(const Array_&lt; const Vec3P * &gt; &amp;points, bool optimize=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ae5b91e495b48b802fc4ee4e92c8dbb16">calcOrientedBoundingBoxIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature doesn't return support points. </p>

</div>
</div>
<a class="anchor" id="a49341e63fdcb5290af1acfc9156b9663"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="a49341e63fdcb5290af1acfc9156b9663" args="(const Vec3P &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a tiny bounding sphere around a single point. </p>
<p>The center is the point and the radius is tiny but non-zero. </p>

</div>
</div>
<a class="anchor" id="a082d91291219035f2fcb971c40b3684c"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="a082d91291219035f2fcb971c40b3684c" args="(const Vec3P &amp;p0, const Vec3P &amp;p1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a minimal bounding sphere around two points. </p>
<p>Some care is taken to avoid roundoff problems if the points are far from the origin or very close together. </p>

</div>
</div>
<a class="anchor" id="ace9d11627d1f525081ec32efe57fd7aa"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="ace9d11627d1f525081ec32efe57fd7aa" args="(const Vec3P &amp;p0, const Vec3P &amp;p1, const Vec3P &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a minimal bounding sphere around three points. </p>

</div>
</div>
<a class="anchor" id="a3ebd70986aa7f0a0466aeae6c291843a"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="a3ebd70986aa7f0a0466aeae6c291843a" args="(const Vec3P &amp;p0, const Vec3P &amp;p1, const Vec3P &amp;p2, const Vec3P &amp;p3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a minimal bounding sphere around four points. </p>

</div>
</div>
<a class="anchor" id="ad7592467141069172a35f136058ff592"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="ad7592467141069172a35f136058ff592" args="(const Array_&lt; Vec3P &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a minimal bounding sphere around a collection of n points. </p>
<p>This has expected O(n) performance and usually yields a near-perfect bounding sphere. </p>

</div>
</div>
<a class="anchor" id="ad22c3e29308b06e70e7dfc7df3e0d5cb"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="ad22c3e29308b06e70e7dfc7df3e0d5cb" args="(const std::vector&lt; Vec3P &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This signature takes an std::vector rather than a <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_</a>; no extra copying is required. </p>

</div>
</div>
<a class="anchor" id="ab71d8029d017c9c675e5c2e8f4965718"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphereIndirect" ref="ab71d8029d017c9c675e5c2e8f4965718" args="(const Array_&lt; const Vec3P * &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ab71d8029d017c9c675e5c2e8f4965718">calcBoundingSphereIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a minimal bounding sphere around a collection of n points, given indirectly as an array of pointers. </p>
<p>This has expected O(n) performance and yields a perfect bounding sphere. </p>

</div>
</div>
<a class="anchor" id="a6ed44ac9098a19e1d82edada119f4d0d"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="a6ed44ac9098a19e1d82edada119f4d0d" args="(const std::vector&lt; const Vec3P * &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This signature takes an std::vector rather than a <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_</a>; no extra copying is required. </p>

</div>
</div>
<a class="anchor" id="a51456770f377afd90500e3dfea6ab5f1"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="a51456770f377afd90500e3dfea6ab5f1" args="(const Vec3P &amp;p0, Array_&lt; int &gt; &amp;which)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create one-point bounding sphere and return the (trivial) support point, of which there is always one. </p>

</div>
</div>
<a class="anchor" id="af91f337fb9b4e42ee956907bfcb0db74"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="af91f337fb9b4e42ee956907bfcb0db74" args="(const Vec3P &amp;p0, const Vec3P &amp;p1, Array_&lt; int &gt; &amp;which)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a minimum sphere around two points. </p>
<p>The center is the midpoint, and the radius is roughly half the distance between the points, possibly expanded in the face of roundoff to ensure that neither point tests outside. There will be two support points for the circle unless the given points are very close to one another. In that case, we treat these as a single point and report in <em>which</em> that only 1 point was used to define the sphere. Points far from the origin will produce a larger sphere because of roundoff. Cost is about 45 flops. </p>

</div>
</div>
<a class="anchor" id="aca1628caca0314c0e4617b3dd4319bef"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="aca1628caca0314c0e4617b3dd4319bef" args="(const Vec3P &amp;p0, const Vec3P &amp;p1, const Vec3P &amp;p2, bool forceCircumsphere, Array_&lt; int &gt; &amp;which)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceCircumsphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a minimum sphere around three points. </p>
<p>There can be 1, 2, or 3 support points returned in <em>which</em>. You can optionally force use of the 3-point circumsphere, which will not always be minimal. Even if <em>forceCircumsphere</em> is set <code>true</code>, if the points are singular (coincident, collinear, coplanar) then it may not be possible to generate a circumsphere and fewer support points will be used. </p>

</div>
</div>
<a class="anchor" id="ab9273f6d6bc41e2de233f5478f3f077e"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="ab9273f6d6bc41e2de233f5478f3f077e" args="(const Vec3P &amp;p0, const Vec3P &amp;p1, const Vec3P &amp;p2, const Vec3P &amp;p3, bool forceCircumsphere, Array_&lt; int &gt; &amp;which)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceCircumsphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a minimum sphere around four points. </p>
<p>There can be 1, 2, 3, or 4 support points returned in <em>which</em>. You can optionally force use of the 4-point circumsphere, which will not always be minimal. Even if <em>forceCircumsphere</em> is set <code>true</code>, if the points are singular (coincident, collinear, coplanar, cospherical) then it may not be possible to generate a circumsphere and fewer support points will be used. </p>

</div>
</div>
<a class="anchor" id="a6438abc63c5c2b93b8313c9528fe270e"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphere" ref="a6438abc63c5c2b93b8313c9528fe270e" args="(const Array_&lt; Vec3P &gt; &amp;points, Array_&lt; int &gt; &amp;which)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663">calcBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an optimal minimum sphere around a collection of n points. </p>
<p>This has expected O(n) performance and yields a near-perfect minimum sphere. There can be 1, 2, 3, or 4 support points used to define the sphere and <em>which</em> reports which of the input points were used. </p>

</div>
</div>
<a class="anchor" id="a498aae5ff58b788fb5d756aacb64408f"></a><!-- doxytag: member="SimTK::Geo::Point_::calcBoundingSphereIndirect" ref="a498aae5ff58b788fb5d756aacb64408f" args="(const Array_&lt; const Vec3P * &gt; &amp;points, Array_&lt; int &gt; &amp;which)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#ab71d8029d017c9c675e5c2e8f4965718">calcBoundingSphereIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature works with an array of pointers to points. </p>

</div>
</div>
<a class="anchor" id="a56514b3f1cd2835190b47e62724224af"></a><!-- doxytag: member="SimTK::Geo::Point_::calcApproxBoundingSphere" ref="a56514b3f1cd2835190b47e62724224af" args="(const Array_&lt; Vec3P &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a56514b3f1cd2835190b47e62724224af">calcApproxBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate an approximate bounding sphere. You should normally use <a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a49341e63fdcb5290af1acfc9156b9663" title="Create a tiny bounding sphere around a single point.">calcBoundingSphere()</a> which will give a smaller sphere. </p>

</div>
</div>
<a class="anchor" id="a4e66321dfcda41a4d431b11bac7dbbb2"></a><!-- doxytag: member="SimTK::Geo::Point_::calcApproxBoundingSphere" ref="a4e66321dfcda41a4d431b11bac7dbbb2" args="(const std::vector&lt; Vec3P &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a56514b3f1cd2835190b47e62724224af">calcApproxBoundingSphere</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This signature takes an std::vector rather than a <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_</a>; no extra copying is required. </p>

</div>
</div>
<a class="anchor" id="a0abf7d090bac57683f044d8ff274f2a1"></a><!-- doxytag: member="SimTK::Geo::Point_::calcApproxBoundingSphereIndirect" ref="a0abf7d090bac57683f044d8ff274f2a1" args="(const Array_&lt; const Vec3P * &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a0abf7d090bac57683f044d8ff274f2a1">calcApproxBoundingSphereIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature works with an array of pointers to points. </p>

</div>
</div>
<a class="anchor" id="adada1ef22931ae38d1f21a89eb42dbf2"></a><!-- doxytag: member="SimTK::Geo::Point_::calcApproxBoundingSphereIndirect" ref="adada1ef22931ae38d1f21a89eb42dbf2" args="(const std::vector&lt; const Vec3P * &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1Point__.html">SimTK::Geo::Point_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Point__.html#a0abf7d090bac57683f044d8ff274f2a1">calcApproxBoundingSphereIndirect</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This signature takes an std::vector rather than a <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_</a>; no extra copying is required. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Geo__Point_8h_source.html">Geo_Point.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Geo.html">Geo</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Geo_1_1Point__.html">Point_</a>      </li>

    <li class="footer">Generated on Mon Jul 14 2014 23:26:14 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
