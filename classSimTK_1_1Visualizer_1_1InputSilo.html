<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::Visualizer::InputSilo Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1Visualizer_1_1InputSilo.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Visualizer::InputSilo Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::Visualizer::InputSilo" --><!-- doxytag: inherits="SimTK::Visualizer::InputListener" -->
<p>This pre-built <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th...">InputListener</a> is extremely useful for processing user input that is intended to affect a running simulation.  
 <a href="classSimTK_1_1Visualizer_1_1InputSilo.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Visualizer__InputListener_8h_source.html">Visualizer_InputListener.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Visualizer::InputSilo:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Visualizer_1_1InputSilo.png" usemap="#SimTK::Visualizer::InputSilo_map" alt=""/>
  <map id="SimTK::Visualizer::InputSilo_map" name="SimTK::Visualizer::InputSilo_map">
<area href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th..." alt="SimTK::Visualizer::InputListener" shape="rect" coords="0,0,187,24"/>
</map>
 </div></div>

<p><a href="classSimTK_1_1Visualizer_1_1InputSilo-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a38c8eae9396680a1722c23fbc2ed7679">InputSilo</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construction is all that is needed; there are no options.  <a href="#a38c8eae9396680a1722c23fbc2ed7679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a21a921f6e8340aaae8d9498e2c4b9686">~InputSilo</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws away any unprocessed input.  <a href="#a21a921f6e8340aaae8d9498e2c4b9686"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#ad3f6291639e1e4bbe5925ef890f5d07d">isAnyUserInput</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a very fast test that does not require locking; you don't have to use this but it is a good idea to do so.  <a href="#ad3f6291639e1e4bbe5925ef890f5d07d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#affead6312b023d476eb1f45fdf811815">waitForAnyUserInput</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This will wait quietly until the user has provided some input to the VisualizerGUI. Any kind of input will terminate the wait; you'll have to look to see what it was.  <a href="#affead6312b023d476eb1f45fdf811815"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55">takeKeyHit</a> (unsigned &amp;key, unsigned &amp;modifiers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return user key hits until they have all been consumed, in the same order they were received.  <a href="#a9f46fd92d0bdfb04fff97bc5aaec7c55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a67031f2e92874d90a97748d4b6248424">waitForKeyHit</a> (unsigned &amp;key, unsigned &amp;modifiers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> except that if there is no key hit input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> would do.  <a href="#a67031f2e92874d90a97748d4b6248424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9">takeMenuPick</a> (int &amp;menu, int &amp;item)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return user menu picks until they have all been consumed, in the same order they were received.  <a href="#a4d1b3ad69db6ec46d3ef111e1b06ebf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a8d2a7d9dff88241bf8575441a1b0b81c">waitForMenuPick</a> (int &amp;menu, int &amp;item)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> except that if there is no menu pick input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> would do.  <a href="#a8d2a7d9dff88241bf8575441a1b0b81c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be">takeSliderMove</a> (int &amp;slider, Real &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return user changes to slider positions until they have all been consumed, in the same order they were received.  <a href="#a3007dc2fd54baefbc5b70334ffd174be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#afa31bec760845d2317786be75af6d128">waitForSliderMove</a> (int &amp;slider, Real &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received.">takeSliderMove()</a> except that if there is no slider move input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received.">takeSliderMove()</a> would do.  <a href="#afa31bec760845d2317786be75af6d128"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a77636bca2813e4a7d419ff7bff9c48bc">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw away any pending unprocessed input of all types.  <a href="#a77636bca2813e4a7d419ff7bff9c48bc"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This pre-built <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th...">InputListener</a> is extremely useful for processing user input that is intended to affect a running simulation. </p>
<p>The idea is that this object saves up all the user input in a set of "silos", which are first-in-first-out (FIFO) queues. The simulation periodically checks ("polls") to see if there is anything in the silos that needs processing, pulling off one user input at a time until they have all been consumed. This eliminates any need for tricky asynchronous handling of user input, and all thread synchronization issues are handled invisibly.</p>
<p>You can also request to wait quietly until some input arrives, which is useful when you can't proceed without some instruction from the user that you expect to get through the VisualizerGUI.</p>
<p>When the <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html" title="This pre-built InputListener is extremely useful for processing user input that is intended to affect...">InputSilo</a> receives user input through one of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th...">InputListener</a> methods it implements, it return <code>true</code> indicating that it has processed the input and that no further InputListeners should be called. So if you have other InputListeners that you would like to have called, be sure to add them to the Visulizer <em>prior</em> to adding an <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html" title="This pre-built InputListener is extremely useful for processing user input that is intended to affect...">InputSilo</a>, which is the last refuge for unwanted user input.</p>
<p>Here's how you can use this:</p>
<div class="fragment"><pre class="fragment">MultibodySystem system;
<span class="comment">// ... build system</span>

<span class="comment">// Set up a Visualizer to run in real time mode, and give it an</span>
<span class="comment">// InputSilo to gather user input.</span>
<a class="code" href="classSimTK_1_1Visualizer.html#a2fa1656e1330799158cd4e79c3c691a7" title="Construct a new Visualizer for the indicated System, and launch the visualizer display executable fro...">Visualizer</a> viz(system);
viz.setMode(<a class="code" href="classSimTK_1_1Visualizer.html#afd8266999e706427db3f86fd6bf5e1dfad5b12e033b09d5ff0f56ac6a0f5eb2d2" title="Synchronize real frame display times with the simulated time.">Visualizer::RealTime</a>);
<a class="code" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a38c8eae9396680a1722c23fbc2ed7679" title="Default construction is all that is needed; there are no options.">InputSilo</a>* silo = <span class="keyword">new</span> <a class="code" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a38c8eae9396680a1722c23fbc2ed7679" title="Default construction is all that is needed; there are no options.">InputSilo</a>;
viz.addInputListener(silo);

<span class="comment">// You create a PeriodicEventHandler to poll the input. Note that the interval</span>
<span class="comment">// you choose determines how responsive the simulation will be to user input,</span>
<span class="comment">// but it also limits the maximum step size that the integrator can take.</span>
system.addEventHandler
    (<span class="keyword">new</span> MyUserInputHandler(*silo, 0.1)); <span class="comment">// check every 100ms </span>

<span class="comment">// Then in MyUserInputHandler::handleEvent(...):</span>
<span class="keywordflow">while</span> (silo.isAnyUserInput()) {
    <span class="keywordflow">while</span> (silo.takeKeyHit(key,modifier)) {
        <span class="comment">// Process the key that was hit</span>
    }
    <span class="keywordflow">while</span> (silo.takeMenuPick(which, item)) {
        <span class="comment">// Process the picked menu item</span>
    }
    <span class="keywordflow">while</span> (silo.takeSliderMove(which, value)) {
        <span class="comment">// Process the new value for slider &quot;which&quot;</span>
    }
}
</pre></div><p>If you want to wait until some input arrives, create the <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html" title="This pre-built InputListener is extremely useful for processing user input that is intended to affect...">InputSilo</a> and add it to the <a class="el" href="classSimTK_1_1Visualizer.html" title="Provide simple visualization of and interaction with a Simbody simulation, with real time control of ...">Visualizer</a> as above, then in your main program (that is, not in the Handler) use code like this: </p>
<div class="fragment"><pre class="fragment">std::cout &lt;&lt; <span class="stringliteral">&quot;Hit ENTER in VisualizerGUI to continue ...\n&quot;</span>;
<span class="keywordtype">unsigned</span> key, modifiers;
<span class="keywordflow">do</span> {silo-&gt;waitForKeyHit(key,modifiers);}
<span class="keywordflow">while</span> (key != <a class="code" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea9e4131a8daeeb0705c1c3aee9c10f421">Visualizer::InputListener::KeyEnter</a>);
</pre></div><p> Similar methods are available for all the different input types, and you can also wait on the arrival of <em>any</em> input.</p>
<h3>Implementation</h3>
<p>The <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html" title="This pre-built InputListener is extremely useful for processing user input that is intended to affect...">InputSilo</a> implementations of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th...">InputListener</a> methods are called from the <a class="el" href="classSimTK_1_1Visualizer.html" title="Provide simple visualization of and interaction with a Simbody simulation, with real time control of ...">Visualizer</a>'s listener thread, which is a different thread than the one that is simultaneously running the simulation. The internal silos are double-ended queues (deques) that allow inputs to be pushed onto one end and pulled off the other, so that they can be consumed in FIFO order. There is a single mutex lock associated with <em>all</em> the silos together, and the lock must be held while anything is pushed onto or pulled off of any one of the silos.</p>
<p>Each of the methods for getting the input out of the silos is called from the simulation thread, which must obtain the lock before removing anything, thus safely synchronizing the listener and simulation threads.</p>
<p>A count is maintained of the total number of items in all the silos. It is incremented only when the listener thread holds the lock and adds something to a silo; it is decremented only when the simulation thread holds the lock and pulls something from a silo. The count may be examined without locking; it will have a value that was recently correct and can thus be used for a very fast check on whether there is likely to be any input worth holding a lock for; the <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#ad3f6291639e1e4bbe5925ef890f5d07d" title="This is a very fast test that does not require locking; you don&#39;t have to use this but it is a good i...">isAnyUserInput()</a> method returns <code>true</code> when the count is non-zero. It may occasionally return zero in cases where there is input, but only if that input just arrived so you can safely pick it up on the next poll.</p>
<p>When possible we optimize for the case where many inputs arrive from the same device by just keeping the most recent value. That applies to slider and mouse moves. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a38c8eae9396680a1722c23fbc2ed7679"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::InputSilo" ref="a38c8eae9396680a1722c23fbc2ed7679" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a38c8eae9396680a1722c23fbc2ed7679">SimTK::Visualizer::InputSilo::InputSilo</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default construction is all that is needed; there are no options. </p>

</div>
</div>
<a class="anchor" id="a21a921f6e8340aaae8d9498e2c4b9686"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::~InputSilo" ref="a21a921f6e8340aaae8d9498e2c4b9686" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a21a921f6e8340aaae8d9498e2c4b9686">SimTK::Visualizer::InputSilo::~InputSilo</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Throws away any unprocessed input. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad3f6291639e1e4bbe5925ef890f5d07d"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::isAnyUserInput" ref="ad3f6291639e1e4bbe5925ef890f5d07d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#ad3f6291639e1e4bbe5925ef890f5d07d">SimTK::Visualizer::InputSilo::isAnyUserInput</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a very fast test that does not require locking; you don't have to use this but it is a good idea to do so. </p>

</div>
</div>
<a class="anchor" id="affead6312b023d476eb1f45fdf811815"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::waitForAnyUserInput" ref="affead6312b023d476eb1f45fdf811815" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#affead6312b023d476eb1f45fdf811815">SimTK::Visualizer::InputSilo::waitForAnyUserInput</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This will wait quietly until the user has provided some input to the VisualizerGUI. Any kind of input will terminate the wait; you'll have to look to see what it was. </p>

</div>
</div>
<a class="anchor" id="a9f46fd92d0bdfb04fff97bc5aaec7c55"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::takeKeyHit" ref="a9f46fd92d0bdfb04fff97bc5aaec7c55" args="(unsigned &amp;key, unsigned &amp;modifiers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55">SimTK::Visualizer::InputSilo::takeKeyHit</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>modifiers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This will return user key hits until they have all been consumed, in the same order they were received. </p>
<p>The <em>key</em> and <em>modifiers</em> values are those that were provided to our implementation of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#ad73885d721fd80ed92b16d342c21e01d" title="This method is called when a user hits a keyboard key in the Visualizer window, unless that key is be...">InputListener::keyPressed()</a> method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>The key code for the key that was hit. See <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596e" title="These are the special keys that the Visualizer may report via the keyPressed() method.">InputListener::KeyCode</a> for interpretation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modifiers</td><td>Status of Shift,Ctrl,Alt and "special" key code. See <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a93b0adb12021df37dfb71b063d1a6412" title="These represent modifications to the character that is passed into the keyPressed() method...">InputListener::Modifier</a> for interpretation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if a key and modifiers have been returned; <code>false</code> if the character silo is now empty in which case both <em>key</em> and <em>modifiers</em> will be set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a67031f2e92874d90a97748d4b6248424"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::waitForKeyHit" ref="a67031f2e92874d90a97748d4b6248424" args="(unsigned &amp;key, unsigned &amp;modifiers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a67031f2e92874d90a97748d4b6248424">SimTK::Visualizer::InputSilo::waitForKeyHit</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>modifiers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> except that if there is no key hit input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> would do. </p>
<p>The behavior is like calling <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#affead6312b023d476eb1f45fdf811815" title="This will wait quietly until the user has provided some input to the VisualizerGUI. Any kind of input will terminate the wait; you&#39;ll have to look to see what it was.">waitForAnyUserInput()</a> repeatedly until <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> returns <code>true</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a>, <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#affead6312b023d476eb1f45fdf811815" title="This will wait quietly until the user has provided some input to the VisualizerGUI. Any kind of input will terminate the wait; you&#39;ll have to look to see what it was.">waitForAnyUserInput()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4d1b3ad69db6ec46d3ef111e1b06ebf9"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::takeMenuPick" ref="a4d1b3ad69db6ec46d3ef111e1b06ebf9" args="(int &amp;menu, int &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9">SimTK::Visualizer::InputSilo::takeMenuPick</a> </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>menu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This will return user menu picks until they have all been consumed, in the same order they were received. </p>
<p>The <em>item</em> value returned is the value that was provided to our implementation of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a37b21fde4c4b9177f4c84c14795081e3" title="The user has clicked one of the menu items you defined; here is the integer value you specified when ...">InputListener::menuSelected()</a> method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">menu</td><td>The id number of the menu that was selected. This is the value that was assigned to this menu in the <a class="el" href="classSimTK_1_1Visualizer.html#a3939bbfe663c4b0436bd12baa6d2c270" title="Add a new pull-down menu to the VisualizerGUI&#39;s display.">Visualizer::addMenu()</a> call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>The menu item number for the entry that the user selected. This is the number that was assigned at the time the menu was added via the <a class="el" href="classSimTK_1_1Visualizer.html#a3939bbfe663c4b0436bd12baa6d2c270" title="Add a new pull-down menu to the VisualizerGUI&#39;s display.">Visualizer::addMenu()</a> method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if a menu item number has been returned; <code>false</code> if the menu pick silo is now empty in which case <em>item</em> will be set to zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d2a7d9dff88241bf8575441a1b0b81c"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::waitForMenuPick" ref="a8d2a7d9dff88241bf8575441a1b0b81c" args="(int &amp;menu, int &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a8d2a7d9dff88241bf8575441a1b0b81c">SimTK::Visualizer::InputSilo::waitForMenuPick</a> </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>menu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> except that if there is no menu pick input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> would do. </p>
<p>The behavior is like calling <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#affead6312b023d476eb1f45fdf811815" title="This will wait quietly until the user has provided some input to the VisualizerGUI. Any kind of input will terminate the wait; you&#39;ll have to look to see what it was.">waitForAnyUserInput()</a> repeatedly until <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> returns <code>true</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a>, <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#affead6312b023d476eb1f45fdf811815" title="This will wait quietly until the user has provided some input to the VisualizerGUI. Any kind of input will terminate the wait; you&#39;ll have to look to see what it was.">waitForAnyUserInput()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3007dc2fd54baefbc5b70334ffd174be"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::takeSliderMove" ref="a3007dc2fd54baefbc5b70334ffd174be" args="(int &amp;slider, Real &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be">SimTK::Visualizer::InputSilo::takeSliderMove</a> </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>slider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This will return user changes to slider positions until they have all been consumed, in the same order they were received. </p>
<p>The <em>slider</em> and <em>value</em> returns are those that were provided to our implementation of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a33c4bf3d5b720025ea2ef327f1692bc5" title="The user has moved one of the sliders you defined; here is the integer value you specified when you d...">InputListener::sliderMoved()</a> method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">slider</td><td>The id number of the slider that was moved. This is the value that was assigned to this slider in the <a class="el" href="classSimTK_1_1Visualizer.html#a1e2cb9ddc47715b23a8acacaa846e70d" title="Add a new slider to the VisualizerGUI&#39;s display.">Visualizer::addSlider()</a> call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>This is the new value associated with the slider position to which the user moved it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if a slider move has been returned; <code>false</code> if the slider move silo is now empty in which case <em>which</em> will be set to zero and <em>value</em> will be NaN. </dd></dl>

</div>
</div>
<a class="anchor" id="afa31bec760845d2317786be75af6d128"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::waitForSliderMove" ref="afa31bec760845d2317786be75af6d128" args="(int &amp;slider, Real &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#afa31bec760845d2317786be75af6d128">SimTK::Visualizer::InputSilo::waitForSliderMove</a> </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>slider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received.">takeSliderMove()</a> except that if there is no slider move input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received.">takeSliderMove()</a> would do. </p>
<p>The behavior is like calling <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#affead6312b023d476eb1f45fdf811815" title="This will wait quietly until the user has provided some input to the VisualizerGUI. Any kind of input will terminate the wait; you&#39;ll have to look to see what it was.">waitForAnyUserInput()</a> repeatedly until <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received.">takeSliderMove()</a> returns <code>true</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received.">takeSliderMove()</a>, <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#affead6312b023d476eb1f45fdf811815" title="This will wait quietly until the user has provided some input to the VisualizerGUI. Any kind of input will terminate the wait; you&#39;ll have to look to see what it was.">waitForAnyUserInput()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a77636bca2813e4a7d419ff7bff9c48bc"></a><!-- doxytag: member="SimTK::Visualizer::InputSilo::clear" ref="a77636bca2813e4a7d419ff7bff9c48bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a77636bca2813e4a7d419ff7bff9c48bc">SimTK::Visualizer::InputSilo::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Throw away any pending unprocessed input of all types. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Visualizer__InputListener_8h_source.html">Visualizer_InputListener.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Visualizer.html">Visualizer</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html">InputSilo</a>      </li>

    <li class="footer">Generated on Mon Jul 14 2014 23:26:05 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
