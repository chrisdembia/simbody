<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::Constraint::Custom::Implementation Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Constraint::Custom::Implementation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::Constraint::Custom::Implementation" --><!-- doxytag: inherits="PIMPLHandle&lt; Implementation, ImplementationImpl &gt;" -->
<p>This is the abstract base class for the implementation of custom constraints. See <a class="el" href="classSimTK_1_1Constraint_1_1Custom.html" title="The handle class Constraint::Custom (dataless) and its companion class Constraint::Custom::Implementa...">Constraint::Custom</a> for more information.  
 <a href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Constraint_8h_source.html">Constraint.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Constraint::Custom::Implementation:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.png" usemap="#SimTK::Constraint::Custom::Implementation_map" alt=""/>
  <map id="SimTK::Constraint::Custom::Implementation_map" name="SimTK::Constraint::Custom::Implementation_map">
<area href="classSimTK_1_1PIMPLHandle.html" alt="SimTK::PIMPLHandle&lt; Implementation, ImplementationImpl &gt;" shape="rect" coords="0,0,349,24"/>
</map>
 </div></div>

<p><a href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ab3a7affd642106cf2b5be876651bac18">~Implementation</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor is virtual so derived classes get a chance to clean up if necessary.  <a href="#ab3a7affd642106cf2b5be876651bac18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html">Implementation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#afa40e50dcc5f319b7603f2e49e6acb18">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should produce a deep copy identical to the concrete derived <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> object underlying this <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> base class object.  <a href="#afa40e50dcc5f319b7603f2e49e6acb18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6d9252d86f8e9b59536d7b50956d4857">Implementation</a> (<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;, int mp, int mv, int ma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> base class constructor sets the topological defaults for the number of position level (holonomic), velocity level (nonholonomic), and acceleration-only constraint equations to be generated.  <a href="#a6d9252d86f8e9b59536d7b50956d4857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af0243c670fa04674b7f2b67f2f52bb76">Implementation</a> (<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor for the <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> base class sets the number of generated equations to zero for this constraint, meaning the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> won't do anything by default.  <a href="#af0243c670fa04674b7f2b67f2f52bb76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1df134d565988ce31c7da79da6c9b4e8">getMatterSubsystem</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the matter subsystem containing this constraint.  <a href="#a1df134d565988ce31c7da79da6c9b4e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a993c7e54628fb4fc65512344bec85ef2">invalidateTopologyCache</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you want to make sure that the next <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a99f1ba084b572abc6eb40e1f8d9ff2e7" title="The Matter Subsystem&#39;s realizeTopology() method will call this method after all MobilizedBody topolog...">realizeTopology()</a> call does something.  <a href="#a993c7e54628fb4fc65512344bec85ef2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html">Implementation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a51dcdcb1d7b64e4fd917745d6978d1c5">setDefaultNumConstraintEquations</a> (int mp, int mv, int ma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an alternate way to set the default number of equations to be generated if you didn't specify them in the base class constructor.  <a href="#a51dcdcb1d7b64e4fd917745d6978d1c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html">Implementation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7231e9ec01ea01f5926adf6ea54a5fcd">setDisabledByDefault</a> (bool shouldBeDisabled)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally Constraints are enabled when defined and can be disabled later.  <a href="#a7231e9ec01ea01f5926adf6ea54a5fcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConstrainedBodyIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ae4adc6491ab17669023c5d6407e7c60e">addConstrainedBody</a> (const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this during construction phase to add a body to the topological structure of this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>.  <a href="#ae4adc6491ab17669023c5d6407e7c60e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConstrainedMobilizerIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6d4694ca92ccc188ecef00509675b1ea">addConstrainedMobilizer</a> (const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this during construction phase to add a mobilizer to the topological structure of this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>.  <a href="#a6d4694ca92ccc188ecef00509675b1ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aebb703a32e953ff6ae3bad7f55076534">getMobilizedBodyIndexOfConstrainedBody</a> (ConstrainedBodyIndex) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a constrained body for this constraint to the mobilized body to which it corresponds in the matter subsystem.  <a href="#aebb703a32e953ff6ae3bad7f55076534"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6783b360c399e6e37c63c5bac2507c3d">getMobilizedBodyIndexOfConstrainedMobilizer</a> (ConstrainedMobilizerIndex) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a constrained mobilizer for this constraint to the mobilized body to which it corresponds in the matter subsystem.  <a href="#a6783b360c399e6e37c63c5bac2507c3d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for use with ConstrainedMobilizers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>When a constraint acts directly on generalized coordinates q or generalized speeds u (or their time derivatives), use methods in this section to access those values in your constraint error and force methods.</p>
<p>The "from state" methods should only be used to pull information from the state that is at a higher level than the method being written. For example, if you are calculating velocity errors you can get positions from the state, but not velocities. Instead, the velocities will be passed as an argument. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a8f5d36ffa409453f483dd16db67924c7">getOneQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQ, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a> whichQ) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a> implementation to extract the value of a particular generalized coordinate q selected by (mobilizer,whichQ), from the "constrained q" argument that is passed to the method from Simbody.  <a href="#a8f5d36ffa409453f483dd16db67924c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2f2e70cc801353257877229718eaa6e7">getOneQFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a> whichQ) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a8f5d36ffa409453f483dd16db67924c7" title="Use this method in your calcPositionErrors() implementation to extract the value of a particular gene...">getOneQ()</a> method but for use in methods to which no explicit "constrained q" argument is supplied.  <a href="#a2f2e70cc801353257877229718eaa6e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0a464d7395bef1a45f81a262a42cb809">getOneQDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQDot, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a> whichQ) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5ad3a319511a9090af12074c6b01b492" title="Calculate the mp velocity errors arising from the first time derivative of the position-level holonom...">calcPositionDotErrors()</a> implementation to extract the value of a particular generalized coordinate derivative qdot selected by (mobilizer,whichQ), from the "constrained qdot" argument that is passed to the method from Simbody.  <a href="#a0a464d7395bef1a45f81a262a42cb809"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5dba6dd2509a84746892d6b5a8c79462">getOneQDotFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a> whichQ) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0a464d7395bef1a45f81a262a42cb809" title="Use this method in your calcPositionDotErrors() implementation to extract the value of a particular g...">getOneQDot()</a> method above but for use in velocity- or acceleration-level methods to which no explicit "constrained qdot" argument is supplied.  <a href="#a5dba6dd2509a84746892d6b5a8c79462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad117284b1c544765c82b48a56c0e550c">getOneQDotDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQDotDot, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a> whichQ) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1772dfc2ef9beadcc1ae8dc4a69349db" title="Calculate the mp errors arising from the second time derivative of the position-level holonomic const...">calcPositionDotDotErrors()</a> implementation to extract the value of a particular generalized coordinate second derivative qdotdot selected by (mobilizer,whichQ), from the "constrained qdotdot" argument that is passed to the method from Simbody.  <a href="#ad117284b1c544765c82b48a56c0e550c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2bf2a13122ba29a14bc26e6ea4722117">getOneU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;constrainedU, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> whichU) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac1a652c53c39b2b73937e250a35d953b" title="Calculate the mv velocity-constraint errors due to the velocity-level specification of a nonholonomic...">calcVelocityErrors()</a> implementation to extract the value of a particular generalized speed u selected by (mobilizer,whichU), from the "constrained u" argument that is passed to the method from Simbody.  <a href="#a2bf2a13122ba29a14bc26e6ea4722117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a4752391c58afea1c20ad8d40b5f244ff">getOneUFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> whichU) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2bf2a13122ba29a14bc26e6ea4722117" title="Use this method in your calcVelocityErrors() implementation to extract the value of a particular gene...">getOneU()</a> method but for use in velocity- or acceleration- level methods to which no explicit "constrained u" argument is supplied.  <a href="#a4752391c58afea1c20ad8d40b5f244ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac79efe42c6959f6db7ca8c6661b66b66">getOneUDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;constrainedUDot, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> whichU) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6f08835ee1dbc0b3bb5fcf5874517672" title="Calculate the mv errors arising from the first time derivative of the velocity-level specification of...">calcVelocityDotErrors()</a> and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad858507140b96505635cc9a0fef4fdf6" title="Calculate the ma acceleration-constraint errors due to the specification of an acceleration-only cons...">calcAccelerationErrors()</a> implementations to extract the value of a particular generalized speed derivative udot selected by (mobilizer,whichU), from the "constrained udot" argument that is passed to these two methods from Simbody.  <a href="#ac79efe42c6959f6db7ca8c6661b66b66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a57208e8f15f98285c54ebdc28e5991fd">addInOneMobilityForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> whichU, Real fu, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;mobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a scalar generalized (mobility-space) force <em>fu</em> to a particular mobility of one of this Constraint's Constrained Mobilizers, <em>adding</em> it in to the appropriate slot of the mobilityForces vector, which is of length <a class="el" href="classSimTK_1_1Constraint.html#a1bf71bb7e093d99f16537393c398fe35" title="Return the number of constrainable mobilities u associated with a particular constrained mobilizer...">getNumConstrainedU()</a> for this Constraint.  <a href="#a57208e8f15f98285c54ebdc28e5991fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aed846d20c3e7a3c2c24e5708bb946393">addInOneQForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedMobilizerIndex mobilizer, <a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a> whichQ, Real fq, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;qForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For use with holonomic (position) constraints, this method allows generalized forces to be applied in "q-space" rather than "u-space".  <a href="#aed846d20c3e7a3c2c24e5708bb946393"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for use with Constrained Bodies</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>When a constraint is enforced (at least in part) by applying forces to bodies, use the methods in this section to access position, velocity, and acceleration information about those constrained bodies.</p>
<p>Note that you can pull higher-level information from the state, but information at the current level for a method must be taken from the supplied arguments instead. For example, if you are writing an acceleration error routine, you can get time, position, and velocity information from the state but must get acceleration information from the body accelerations that are supplied by Simbody as arguments. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3551c1427f3526d23fb6f0a1029bce1c">getBodyTransform</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;allX_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the <em>allX_AB</em> argument the spatial transform X_AB giving the pose (orientation and location) of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B in this constraint's Ancestor frame A.  <a href="#a3551c1427f3526d23fb6f0a1029bce1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a215d13299e99df4ebc15ff2f465041ee">getBodyRotation</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;allX_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3551c1427f3526d23fb6f0a1029bce1c" title="Extract from the allX_AB argument the spatial transform X_AB giving the pose (orientation and locatio...">getBodyTransform()</a> that returns just the orientation as the Rotation matrix R_AB.  <a href="#a215d13299e99df4ebc15ff2f465041ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aab92a4c7417d7d396c02a8d62c8c10bc">getBodyOriginLocation</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;allX_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3551c1427f3526d23fb6f0a1029bce1c" title="Extract from the allX_AB argument the spatial transform X_AB giving the pose (orientation and locatio...">getBodyTransform()</a> that returns just the location part of B's pose in A, that is the vector p_AB from A's origin Ao to B's origin Bo, expressed in A.  <a href="#aab92a4c7417d7d396c02a8d62c8c10bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a307aaa19ecb04d37c9c4df5440de4712">getBodyTransformFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex B) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> cache the spatial transform X_AB giving the pose (orientation and location) of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B in this constraint's Ancestor frame A.  <a href="#a307aaa19ecb04d37c9c4df5440de4712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2d1556009bb593241e7410e797b7878b">getBodyRotationFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a307aaa19ecb04d37c9c4df5440de4712" title="Extract from the State cache the spatial transform X_AB giving the pose (orientation and location) of...">getBodyTransformFromState()</a> that returns just the orientation as the Rotation matrix R_AB.  <a href="#a2d1556009bb593241e7410e797b7878b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6c5ec5a45be0dace470ce9af45516dcb">getBodyOriginLocationFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a307aaa19ecb04d37c9c4df5440de4712" title="Extract from the State cache the spatial transform X_AB giving the pose (orientation and location) of...">getBodyTransformFromState()</a> that returns just the location part of B's pose in A, that is the vector p_AB from A's origin Ao to B's origin Bo, expressed in A.  <a href="#a6c5ec5a45be0dace470ce9af45516dcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ade0b79471ec10de5d93eedb1fc7063c5">getBodyVelocity</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;allV_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the <em>allV_AB</em> argument the spatial velocity V_AB giving the angular and linear velocity of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B measured and expressed in this constraint's Ancestor frame A.  <a href="#ade0b79471ec10de5d93eedb1fc7063c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aac35e848b3063ff03b60081de732cdc8">getBodyAngularVelocity</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;allV_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ade0b79471ec10de5d93eedb1fc7063c5" title="Extract from the allV_AB argument the spatial velocity V_AB giving the angular and linear velocity of...">getBodyVelocity()</a> that returns just the angular velocity vector w_AB.  <a href="#aac35e848b3063ff03b60081de732cdc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6c0efa72caa680bd077b115c9c08c2ac">getBodyOriginVelocity</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;allV_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ade0b79471ec10de5d93eedb1fc7063c5" title="Extract from the allV_AB argument the spatial velocity V_AB giving the angular and linear velocity of...">getBodyVelocity()</a> that returns just the linear velocity vector v_AB.  <a href="#a6c0efa72caa680bd077b115c9c08c2ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af5f4d589e94f6a41f0f9da03a5444a1f">getBodyVelocityFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> cache the spatial velocity V_AB giving the angular and linear velocity of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B measured and expressed in this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>'s Ancestor frame A.  <a href="#af5f4d589e94f6a41f0f9da03a5444a1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ae8c9d2983af4fb1fb6dc662506ff76e5">getBodyAngularVelocityFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af5f4d589e94f6a41f0f9da03a5444a1f" title="Extract from the State cache the spatial velocity V_AB giving the angular and linear velocity of a Co...">getBodyVelocityFromState()</a> that returns just the angular velocity vector w_AB.  <a href="#ae8c9d2983af4fb1fb6dc662506ff76e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ab64effcd9e8680ead8c20f007f4adf40">getBodyOriginVelocityFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af5f4d589e94f6a41f0f9da03a5444a1f" title="Extract from the State cache the spatial velocity V_AB giving the angular and linear velocity of a Co...">getBodyVelocityFromState()</a> that returns just the linear velocity vector v_AB.  <a href="#ab64effcd9e8680ead8c20f007f4adf40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aa3209d049563debdddbebe44baa37e61">getBodyAcceleration</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;allA_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the <em>allA_AB</em> argument the spatial acceleration A_AB giving the angular and linear acceleration of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B measured and expressed in this constraint's Ancestor frame A.  <a href="#aa3209d049563debdddbebe44baa37e61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a4bc1a14f11e29fdce97f1ea34a096db8">getBodyAngularAcceleration</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;allA_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aa3209d049563debdddbebe44baa37e61" title="Extract from the allA_AB argument the spatial acceleration A_AB giving the angular and linear acceler...">getBodyAcceleration()</a> that returns just the angular acceleration vector b_AB.  <a href="#a4bc1a14f11e29fdce97f1ea34a096db8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3d803decfe2575df35f8ad34ea6c35a9">getBodyOriginAcceleration</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;allA_AB, ConstrainedBodyIndex bodyB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aa3209d049563debdddbebe44baa37e61" title="Extract from the allA_AB argument the spatial acceleration A_AB giving the angular and linear acceler...">getBodyAcceleration()</a> that returns just the linear acceleration vector a_AB.  <a href="#a3d803decfe2575df35f8ad34ea6c35a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad6acf838ab261b6590936aa56ba89693">findStationLocation</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;allX_AB, ConstrainedBodyIndex bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_BS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the position p_AS in the Ancestor frame of a station S of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B, specified with the position vector p_BS (or more explicitly, p_BoS) from the B frame origin Bo to the point S, expressed in the B frame.  <a href="#ad6acf838ab261b6590936aa56ba89693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a57b49bcfbc37665dfa48f9548b32a4b0">findStationLocationFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_BS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad6acf838ab261b6590936aa56ba89693" title="Calculate the position p_AS in the Ancestor frame of a station S of a Constrained Body B...">findStationLocation()</a> but for when you have to get the position information from the <em>state</em> rather than from an explicit argument.  <a href="#a57b49bcfbc37665dfa48f9548b32a4b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5f82f34f6ce65ef0e156a8f02f7c90dd">findStationVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;allV_AB, ConstrainedBodyIndex bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_BS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the velocity v_AS in the Ancestor frame of a station S of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B, specified with the position vector p_BS (or more explicitly, p_BoS) from the B frame origin Bo to the point S, expressed in the B frame.  <a href="#a5f82f34f6ce65ef0e156a8f02f7c90dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a4a210086ef3672ccd9b6dd3fd81326f2">findStationVelocityFromState</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_BS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5f82f34f6ce65ef0e156a8f02f7c90dd" title="Calculate the velocity v_AS in the Ancestor frame of a station S of a Constrained Body B...">findStationVelocity()</a> but for when you have to get the velocity information from the <em>state</em> rather than from an explicit argument.  <a href="#a4a210086ef3672ccd9b6dd3fd81326f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a26d44cabfb561bebf9cb21c01169f38d">findStationAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;allA_AB, ConstrainedBodyIndex bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_BS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration a_AS in the Ancestor frame of a station S of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B, specified with the position vector p_BS (or more explicitly, p_BoS) from the B frame origin Bo to the point S, expressed in the B frame.  <a href="#a26d44cabfb561bebf9cb21c01169f38d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2cd291bf9a8947bea8eca68e6227a930">addInStationForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_BS, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;forceInA, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;bodyForcesInA) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an Ancestor-frame force to a B-frame station S given by the position vector p_BS (or more explicitly, p_BoS) from the B frame origin Bo to the point S, expressed in the B frame, <em>adding to</em> the appropriate <code>bodyForcesInA</code> entry for this ConstrainedBody B.  <a href="#a2cd291bf9a8947bea8eca68e6227a930"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a8447d5095d5ad4825af9ae0cf925ad5f">addInBodyTorque</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, ConstrainedBodyIndex bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;torqueInA, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;bodyForcesInA) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an Ancestor-frame torque to body B, <em>adding to</em> the appropriate <code>bodyForcesInA</code> entry for this ConstrainedBody B.  <a href="#a8447d5095d5ad4825af9ae0cf925ad5f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These provide access to quantities associated with this constraint, suitable for use in the optional realize() virtual methods.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a88fdde686279d159bc9ecef61cfaa30e">getMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;multipliers) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <em>state</em> as passed to your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7d9b2ddaf0bb159115e95da1cb976ae5" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method after any MobilizedBody Acc...">realizeAcceleration()</a> implementation, obtain the multipliers that Simbody just calculated for this Constraint.  <a href="#a88fdde686279d159bc9ecef61cfaa30e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af8269a724cb77b298abdc7acbeeb0d56">calcDecorativeGeometryAndAppend</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> stage, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &gt; &amp;geom) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this optional method if you would like your constraint to generate any suggestions for geometry that could be used as default visualization as an aid to understanding a system containing this constraint.  <a href="#af8269a724cb77b298abdc7acbeeb0d56"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Optional realize() virtual methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Provide implementations of these methods if you want to allocate <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> variables (such as modeling options or parameters) or want to pre-calculate some expensive quantities and store them in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> cache for your future use.</p>
<p>Note that the Position, Velocity, and Acceleration-stage realize methods will be called <em>after</em> the constraint error calculating methods associated with this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>'s constraint equations have been used by Simbody to perform any constraint calculations. That means, for example, you can access calculated multipliers from your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7d9b2ddaf0bb159115e95da1cb976ae5" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method after any MobilizedBody Acc...">realizeAcceleration()</a> method. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a99f1ba084b572abc6eb40e1f8d9ff2e7">realizeTopology</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a99f1ba084b572abc6eb40e1f8d9ff2e7" title="The Matter Subsystem&#39;s realizeTopology() method will call this method after all MobilizedBody topolog...">realizeTopology()</a> method will call this method after all <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> topology has been processed.  <a href="#a99f1ba084b572abc6eb40e1f8d9ff2e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#adaef15dfa453837e25f124cf56c7a4e9">realizeModel</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#adaef15dfa453837e25f124cf56c7a4e9" title="The Matter Subsystem&#39;s realizeModel() method will call this method after all MobilizedBody Model-stag...">realizeModel()</a> method will call this method after all <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Model-stage processing has been done.  <a href="#adaef15dfa453837e25f124cf56c7a4e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a30849e5e2a6972ba7f8d43e841869681">realizeInstance</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a30849e5e2a6972ba7f8d43e841869681" title="The Matter Subsystem&#39;s realizeInstance() method will call this method after all MobilizedBody Instanc...">realizeInstance()</a> method will call this method after all <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Instance-stage processing has been done.  <a href="#a30849e5e2a6972ba7f8d43e841869681"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af50b75ae1ed74a80f8923c7ce2ae7556">realizeTime</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af50b75ae1ed74a80f8923c7ce2ae7556" title="The Matter Subsystem&#39;s realizeTime() method will call this method after any MobilizedBody Time-stage ...">realizeTime()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Time-stage processing has been done.  <a href="#af50b75ae1ed74a80f8923c7ce2ae7556"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0088e0d29d10565fe32ccb4941f75a14">realizePosition</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0088e0d29d10565fe32ccb4941f75a14" title="The Matter Subsystem&#39;s realizePosition() method will call this method after any MobilizedBody Positio...">realizePosition()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Position-stage processing has been done, and <em>after</em> the call has been made to your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a> operator.  <a href="#a0088e0d29d10565fe32ccb4941f75a14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a01960c769f9b9011fed580d3bd6c2200">realizeVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a01960c769f9b9011fed580d3bd6c2200" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method after any MobilizedBody Velocit...">realizeVelocity()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Velocity-stage processing has been done, and <em>after</em> your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac1a652c53c39b2b73937e250a35d953b" title="Calculate the mv velocity-constraint errors due to the velocity-level specification of a nonholonomic...">calcVelocityErrors()</a> and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5ad3a319511a9090af12074c6b01b492" title="Calculate the mp velocity errors arising from the first time derivative of the position-level holonom...">calcPositionDotErrors()</a> operators have been called.  <a href="#a01960c769f9b9011fed580d3bd6c2200"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7cca4e24f343623dc3a1816d45d40687">realizeDynamics</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7cca4e24f343623dc3a1816d45d40687" title="The Matter Subsystem&#39;s realizeDynamics() method will call this method after any MobilizedBody Dynamic...">realizeDynamics()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Dynamics-stage processing has been done.  <a href="#a7cca4e24f343623dc3a1816d45d40687"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7d9b2ddaf0bb159115e95da1cb976ae5">realizeAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7d9b2ddaf0bb159115e95da1cb976ae5" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method after any MobilizedBody Acc...">realizeAcceleration()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Acceleration-stage processing has been done, and <em>after</em> your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad858507140b96505635cc9a0fef4fdf6" title="Calculate the ma acceleration-constraint errors due to the specification of an acceleration-only cons...">calcAccelerationErrors()</a>, <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6f08835ee1dbc0b3bb5fcf5874517672" title="Calculate the mv errors arising from the first time derivative of the velocity-level specification of...">calcVelocityDotErrors()</a>, and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1772dfc2ef9beadcc1ae8dc4a69349db" title="Calculate the mp errors arising from the second time derivative of the position-level holonomic const...">calcPositionDotDotErrors()</a> operators have been called.  <a href="#a7d9b2ddaf0bb159115e95da1cb976ae5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ab5117afd79477db3a20a75c803175deb">realizeReport</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ab5117afd79477db3a20a75c803175deb" title="The Matter Subsystem&#39;s realizeReport() method will call this method after any MobilizedBody Report-st...">realizeReport()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Report-stage processing has been done.  <a href="#ab5117afd79477db3a20a75c803175deb"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Position (Holonomic) Constraint Virtuals</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These must be defined if there are any position (holonomic) constraint equations generated by this Constraint.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e">calcPositionErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;X_AB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQ, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;perr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the <em>mp</em> position-constraint errors due to the position-level specification of a holonomic constraint and write them to <em>perr</em>, which will have been allocated to length <em>mp</em>; do not reallocate it.  <a href="#ad5c47af5897f0d5827f8f70031dcf19e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5ad3a319511a9090af12074c6b01b492">calcPositionDotErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;V_AB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQDot, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;pverr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the <em>mp</em> velocity errors arising from the first time derivative of the position-level holonomic constraint function <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a>, and write them to <em>pverr</em>, which will have been allocated to length <em>mp</em>; do not reallocate it.  <a href="#a5ad3a319511a9090af12074c6b01b492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1772dfc2ef9beadcc1ae8dc4a69349db">calcPositionDotDotErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;A_AB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQDotDot, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;paerr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the <em>mp</em> errors arising from the second time derivative of the position-level holonomic constraint function <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a>, and write them to <em>paerr</em>, which will have been allocated to length <em>mp</em>; do not reallocate it.  <a href="#a1772dfc2ef9beadcc1ae8dc4a69349db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5f61701999a0b983d75bc1eb86e57956">addInPositionConstraintForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;multipliers, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;bodyForcesInA, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;qForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the <em>mp</em> supplied Lagrange multipliers provided in <em>multipliers</em>, calculate the forces produced by this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> on its Constrained Bodies and Constrained Qs.  <a href="#a5f61701999a0b983d75bc1eb86e57956"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Velocity (Nonholonomic) Constraint Virtuals</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These must be defined if there are any velocity (nonholonomic) constraint equations generated by this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac1a652c53c39b2b73937e250a35d953b">calcVelocityErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;V_AB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;constrainedU, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;verr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the <em>mv</em> velocity-constraint errors due to the velocity-level specification of a nonholonomic constraint and write them to <em>verr</em>, which will already have been allocated to length <em>mv</em>; do not reallocate it.  <a href="#ac1a652c53c39b2b73937e250a35d953b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6f08835ee1dbc0b3bb5fcf5874517672">calcVelocityDotErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;A_AB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;constrainedUDot, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;vaerr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the <em>mv</em> errors arising from the first time derivative of the velocity-level specification of a nonholonomic constraint and write them to <em>vaerr</em>, which will already have been allocated to length <em>mv</em>; do not reallocate it.  <a href="#a6f08835ee1dbc0b3bb5fcf5874517672"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac3e58b9941a8896373b157365c7e4578">addInVelocityConstraintForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;multipliers, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;bodyForcesInA, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;mobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the <code>mv</code> supplied Lagrange multipliers provided in <em>multipliers</em>, calculate the forces produced by this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> on its Constrained Bodies and Constrained Mobilities due to its velocity-level (nonholonomic) constraints.  <a href="#ac3e58b9941a8896373b157365c7e4578"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Acceleration-Only Constraint Virtuals</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These must be defined if there are any acceleration-only constraint equations generated by this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad858507140b96505635cc9a0fef4fdf6">calcAccelerationErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;A_AB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;constrainedUDot, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;aerr) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the <em>ma</em> acceleration-constraint errors due to the specification of an acceleration-only constraint and write them to <em>aerr</em>, which will already have been allocated to length <em>ma</em>; do not reallocate it.  <a href="#ad858507140b96505635cc9a0fef4fdf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a256f32f746ae6cc92780764da2b028f9">addInAccelerationConstraintForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;multipliers, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;bodyForcesInA, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;mobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the <em>ma</em> supplied Lagrange multipliers provided in <em>multipliers</em>, calculate the forces produced by this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> on its Constrained Bodies and Constrained Mobilities due to its acceleration-only constraints.  <a href="#a256f32f746ae6cc92780764da2b028f9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac7fb2fe2eab3303de126b490b5f62637">Constraint::CustomImpl</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is the abstract base class for the implementation of custom constraints. See <a class="el" href="classSimTK_1_1Constraint_1_1Custom.html" title="The handle class Constraint::Custom (dataless) and its companion class Constraint::Custom::Implementa...">Constraint::Custom</a> for more information. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab3a7affd642106cf2b5be876651bac18"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::~Implementation" ref="ab3a7affd642106cf2b5be876651bac18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ab3a7affd642106cf2b5be876651bac18">SimTK::Constraint::Custom::Implementation::~Implementation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor is virtual so derived classes get a chance to clean up if necessary. </p>

</div>
</div>
<a class="anchor" id="a6d9252d86f8e9b59536d7b50956d4857"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::Implementation" ref="a6d9252d86f8e9b59536d7b50956d4857" args="(SimbodyMatterSubsystem &amp;, int mp, int mv, int ma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6d9252d86f8e9b59536d7b50956d4857">SimTK::Constraint::Custom::Implementation::Implementation</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> base class constructor sets the topological defaults for the number of position level (holonomic), velocity level (nonholonomic), and acceleration-only constraint equations to be generated. </p>

</div>
</div>
<a class="anchor" id="af0243c670fa04674b7f2b67f2f52bb76"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::Implementation" ref="af0243c670fa04674b7f2b67f2f52bb76" args="(SimbodyMatterSubsystem &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6d9252d86f8e9b59536d7b50956d4857">SimTK::Constraint::Custom::Implementation::Implementation</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default constructor for the <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> base class sets the number of generated equations to zero for this constraint, meaning the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> won't do anything by default. </p>
<p>The actual number can be changed using setNumConstraintEquationsInUse() prior to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#adaef15dfa453837e25f124cf56c7a4e9" title="The Matter Subsystem&#39;s realizeModel() method will call this method after all MobilizedBody Model-stag...">realizeModel()</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afa40e50dcc5f319b7603f2e49e6acb18"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::clone" ref="afa40e50dcc5f319b7603f2e49e6acb18" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html">Implementation</a>* <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#afa40e50dcc5f319b7603f2e49e6acb18">SimTK::Constraint::Custom::Implementation::clone</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method should produce a deep copy identical to the concrete derived <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> object underlying this <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> base class object. </p>
<p>Note that the result is new heap space; the caller must be sure to take ownership of the returned pointer and call delete on it when done. </p>

</div>
</div>
<a class="anchor" id="a1df134d565988ce31c7da79da6c9b4e8"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getMatterSubsystem" ref="a1df134d565988ce31c7da79da6c9b4e8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1df134d565988ce31c7da79da6c9b4e8">SimTK::Constraint::Custom::Implementation::getMatterSubsystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the matter subsystem containing this constraint. </p>

</div>
</div>
<a class="anchor" id="a993c7e54628fb4fc65512344bec85ef2"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::invalidateTopologyCache" ref="a993c7e54628fb4fc65512344bec85ef2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a993c7e54628fb4fc65512344bec85ef2">SimTK::Constraint::Custom::Implementation::invalidateTopologyCache</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this if you want to make sure that the next <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a99f1ba084b572abc6eb40e1f8d9ff2e7" title="The Matter Subsystem&#39;s realizeTopology() method will call this method after all MobilizedBody topolog...">realizeTopology()</a> call does something. </p>
<p>This is done automatically when you modify the constraint in ways understood by Simbody, such as adding a ConstrainedBody. But if you are just changing some of your own topology and want to make sure you get a chance to recompute something in <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a99f1ba084b572abc6eb40e1f8d9ff2e7" title="The Matter Subsystem&#39;s realizeTopology() method will call this method after all MobilizedBody topolog...">realizeTopology()</a>, make this call at the time of modification. </p>

</div>
</div>
<a class="anchor" id="a51dcdcb1d7b64e4fd917745d6978d1c5"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::setDefaultNumConstraintEquations" ref="a51dcdcb1d7b64e4fd917745d6978d1c5" args="(int mp, int mv, int ma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html">Implementation</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a51dcdcb1d7b64e4fd917745d6978d1c5">SimTK::Constraint::Custom::Implementation::setDefaultNumConstraintEquations</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an alternate way to set the default number of equations to be generated if you didn't specify them in the base class constructor. </p>
<p>A reference to this <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> is returned so that this can be used in a sequence like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="a7231e9ec01ea01f5926adf6ea54a5fcd"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::setDisabledByDefault" ref="a7231e9ec01ea01f5926adf6ea54a5fcd" args="(bool shouldBeDisabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html">Implementation</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7231e9ec01ea01f5926adf6ea54a5fcd">SimTK::Constraint::Custom::Implementation::setDisabledByDefault</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldBeDisabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normally Constraints are enabled when defined and can be disabled later. </p>
<p>If you want to define this constraint but have it be off by default, use this method. A reference to this <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> is returned so that this can be used in a sequence like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="ae4adc6491ab17669023c5d6407e7c60e"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addConstrainedBody" ref="ae4adc6491ab17669023c5d6407e7c60e" args="(const MobilizedBody &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstrainedBodyIndex <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ae4adc6491ab17669023c5d6407e7c60e">SimTK::Constraint::Custom::Implementation::addConstrainedBody</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this during construction phase to add a body to the topological structure of this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>. </p>
<p>This body's mobilizer's mobilities are <em>not</em> part of the constraint; mobilizers must be added separately. Numbering starts from 0 for each <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>. The supplied <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> must be in the Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a> of which this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> is a part. </p>

</div>
</div>
<a class="anchor" id="a6d4694ca92ccc188ecef00509675b1ea"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addConstrainedMobilizer" ref="a6d4694ca92ccc188ecef00509675b1ea" args="(const MobilizedBody &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstrainedMobilizerIndex <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6d4694ca92ccc188ecef00509675b1ea">SimTK::Constraint::Custom::Implementation::addConstrainedMobilizer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this during construction phase to add a mobilizer to the topological structure of this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>. </p>
<p>All the coordinates q and mobilities u for this mobilizer are added also, but we don't know how many of those there will be until <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made.">Stage::Model</a>. Numbering starts from 0 for each <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>. The supplied <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> must be in the Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a> of which this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> is a part. </p>

</div>
</div>
<a class="anchor" id="aebb703a32e953ff6ae3bad7f55076534"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getMobilizedBodyIndexOfConstrainedBody" ref="aebb703a32e953ff6ae3bad7f55076534" args="(ConstrainedBodyIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aebb703a32e953ff6ae3bad7f55076534">SimTK::Constraint::Custom::Implementation::getMobilizedBodyIndexOfConstrainedBody</a> </td>
          <td>(</td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Map a constrained body for this constraint to the mobilized body to which it corresponds in the matter subsystem. </p>
<p>You should not use this to extract any information in the constraint error or forces methods; always work with the constrained bodies and constrained mobilities instead. </p>

</div>
</div>
<a class="anchor" id="a6783b360c399e6e37c63c5bac2507c3d"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getMobilizedBodyIndexOfConstrainedMobilizer" ref="a6783b360c399e6e37c63c5bac2507c3d" args="(ConstrainedMobilizerIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6783b360c399e6e37c63c5bac2507c3d">SimTK::Constraint::Custom::Implementation::getMobilizedBodyIndexOfConstrainedMobilizer</a> </td>
          <td>(</td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Map a constrained mobilizer for this constraint to the mobilized body to which it corresponds in the matter subsystem. </p>
<p>You should not use this to extract any information in the constraint error or forces methods; always work with the constrained bodies and constrained mobilities instead. </p>

</div>
</div>
<a class="anchor" id="a8f5d36ffa409453f483dd16db67924c7"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getOneQ" ref="a8f5d36ffa409453f483dd16db67924c7" args="(const State &amp;state, const Array_&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQ, ConstrainedMobilizerIndex mobilizer, MobilizerQIndex whichQ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a8f5d36ffa409453f483dd16db67924c7">SimTK::Constraint::Custom::Implementation::getOneQ</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a>&#160;</td>
          <td class="paramname"><em>whichQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a> implementation to extract the value of a particular generalized coordinate q selected by (mobilizer,whichQ), from the "constrained q" argument that is passed to the method from Simbody. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Supplied state which is used only for modeling information; generalized coordinates q within <em>state</em> are ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constrainedQ</td><td>This is the argument that is supplied to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a> from which we will extract the particular q value selected by the next two arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobilizer</td><td>The constrained mobilizer one of whose generalized coordinates is of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whichQ</td><td>The particular generalized coordinate of <em>mobilizer</em> whose value we want. The actual value will be selected from <em>constrainedQ</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the generalized coordinate q of interest, extracted from the <em>constrainedQ</em> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f2e70cc801353257877229718eaa6e7"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getOneQFromState" ref="a2f2e70cc801353257877229718eaa6e7" args="(const State &amp;state, ConstrainedMobilizerIndex mobilizer, MobilizerQIndex whichQ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2f2e70cc801353257877229718eaa6e7">SimTK::Constraint::Custom::Implementation::getOneQFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a>&#160;</td>
          <td class="paramname"><em>whichQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as the <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a8f5d36ffa409453f483dd16db67924c7" title="Use this method in your calcPositionErrors() implementation to extract the value of a particular gene...">getOneQ()</a> method but for use in methods to which no explicit "constrained q" argument is supplied. </p>
<p>The desired q value is obtained from <em>state</em>. You can call this from any constraint implementation method <em>except</em> calcPositionError(). </p>

</div>
</div>
<a class="anchor" id="a0a464d7395bef1a45f81a262a42cb809"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getOneQDot" ref="a0a464d7395bef1a45f81a262a42cb809" args="(const State &amp;state, const Array_&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQDot, ConstrainedMobilizerIndex mobilizer, MobilizerQIndex whichQ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0a464d7395bef1a45f81a262a42cb809">SimTK::Constraint::Custom::Implementation::getOneQDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedQDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a>&#160;</td>
          <td class="paramname"><em>whichQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5ad3a319511a9090af12074c6b01b492" title="Calculate the mp velocity errors arising from the first time derivative of the position-level holonom...">calcPositionDotErrors()</a> implementation to extract the value of a particular generalized coordinate derivative qdot selected by (mobilizer,whichQ), from the "constrained qdot" argument that is passed to the method from Simbody. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Supplied state which is used only for modeling information; qdots within <em>state</em> are ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constrainedQDot</td><td>This is the argument that is supplied to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5ad3a319511a9090af12074c6b01b492" title="Calculate the mp velocity errors arising from the first time derivative of the position-level holonom...">calcPositionDotErrors()</a> from which we will extract the particular qdot value selected by the next two arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobilizer</td><td>The constrained mobilizer one of whose generalized coordinates is of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whichQ</td><td>The particular generalized coordinate of <em>mobilizer</em> whose qdot value we want. The actual value will be selected from <em>constrainedQDot</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the generalized coordinate derivative qdot of interest, extracted from the <em>constrainedQDot</em> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dba6dd2509a84746892d6b5a8c79462"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getOneQDotFromState" ref="a5dba6dd2509a84746892d6b5a8c79462" args="(const State &amp;state, ConstrainedMobilizerIndex mobilizer, MobilizerQIndex whichQ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5dba6dd2509a84746892d6b5a8c79462">SimTK::Constraint::Custom::Implementation::getOneQDotFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a>&#160;</td>
          <td class="paramname"><em>whichQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as the <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0a464d7395bef1a45f81a262a42cb809" title="Use this method in your calcPositionDotErrors() implementation to extract the value of a particular g...">getOneQDot()</a> method above but for use in velocity- or acceleration-level methods to which no explicit "constrained qdot" argument is supplied. </p>
<p>The desired qdot value is obtained from <em>state</em>. You can call this from calcPositionDotDotError(). <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> must already be realized to the Velocity stage. </p>

</div>
</div>
<a class="anchor" id="ad117284b1c544765c82b48a56c0e550c"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getOneQDotDot" ref="ad117284b1c544765c82b48a56c0e550c" args="(const State &amp;state, const Array_&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQDotDot, ConstrainedMobilizerIndex mobilizer, MobilizerQIndex whichQ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad117284b1c544765c82b48a56c0e550c">SimTK::Constraint::Custom::Implementation::getOneQDotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedQDotDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a>&#160;</td>
          <td class="paramname"><em>whichQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1772dfc2ef9beadcc1ae8dc4a69349db" title="Calculate the mp errors arising from the second time derivative of the position-level holonomic const...">calcPositionDotDotErrors()</a> implementation to extract the value of a particular generalized coordinate second derivative qdotdot selected by (mobilizer,whichQ), from the "constrained qdotdot" argument that is passed to the method from Simbody. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Supplied state which is used only for modeling information; qdotdots within <em>state</em> are ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constrainedQDotDot</td><td>This is the argument that is supplied to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1772dfc2ef9beadcc1ae8dc4a69349db" title="Calculate the mp errors arising from the second time derivative of the position-level holonomic const...">calcPositionDotDotErrors()</a> from which we will extract the particular qdotdot value selected by the next two arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobilizer</td><td>The constrained mobilizer one of whose generalized coordinates is of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whichQ</td><td>The particular generalized coordinate of <em>mobilizer</em> whose qdotdot value we want. The actual value will be selected from <em>constrainedQDotDot</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the generalized coordinate second derivative qdotdot of interest, extracted from the <em>constrainedQDotDot</em> argument.</dd></dl>
<p>There is no getOneQDotDotFromState() method because all the acceleration- level methods are passed qdotdot or udot as an explicit argument. </p>

</div>
</div>
<a class="anchor" id="a2bf2a13122ba29a14bc26e6ea4722117"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getOneU" ref="a2bf2a13122ba29a14bc26e6ea4722117" args="(const State &amp;state, const Array_&lt; Real, ConstrainedUIndex &gt; &amp;constrainedU, ConstrainedMobilizerIndex mobilizer, MobilizerUIndex whichU) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2bf2a13122ba29a14bc26e6ea4722117">SimTK::Constraint::Custom::Implementation::getOneU</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>whichU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac1a652c53c39b2b73937e250a35d953b" title="Calculate the mv velocity-constraint errors due to the velocity-level specification of a nonholonomic...">calcVelocityErrors()</a> implementation to extract the value of a particular generalized speed u selected by (mobilizer,whichU), from the "constrained u" argument that is passed to the method from Simbody. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Supplied state which is used only for modeling information; generalized speeds u within <em>state</em> are ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constrainedU</td><td>This is the argument that is supplied to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac1a652c53c39b2b73937e250a35d953b" title="Calculate the mv velocity-constraint errors due to the velocity-level specification of a nonholonomic...">calcVelocityErrors()</a> from which we will extract the particular u value selected by the next two arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobilizer</td><td>The constrained mobilizer one of whose generalized speeds is of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whichU</td><td>The particular generalized speed of <em>mobilizer</em> whose value we want. The actual value will be selected from <em>constrainedU</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the generalized speed u of interest, extracted from the <em>constrainedU</em> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a4752391c58afea1c20ad8d40b5f244ff"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getOneUFromState" ref="a4752391c58afea1c20ad8d40b5f244ff" args="(const State &amp;state, ConstrainedMobilizerIndex mobilizer, MobilizerUIndex whichU) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a4752391c58afea1c20ad8d40b5f244ff">SimTK::Constraint::Custom::Implementation::getOneUFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>whichU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as the <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2bf2a13122ba29a14bc26e6ea4722117" title="Use this method in your calcVelocityErrors() implementation to extract the value of a particular gene...">getOneU()</a> method but for use in velocity- or acceleration- level methods to which no explicit "constrained u" argument is supplied. </p>
<p>The desired u value is obtained from <em>state</em>. You can call this only from calcVelocityDotError(), calcAccelerationError(), and any constraint force method. The <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> needs to be realized only as high as Model stage, but don't use this value in calcPositionError() or <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5f61701999a0b983d75bc1eb86e57956" title="From the mp supplied Lagrange multipliers provided in multipliers, calculate the forces produced by t...">addInPositionConstraintForces()</a>. Those must be limited to dependencies on time and configuration only. </p>

</div>
</div>
<a class="anchor" id="ac79efe42c6959f6db7ca8c6661b66b66"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getOneUDot" ref="ac79efe42c6959f6db7ca8c6661b66b66" args="(const State &amp;state, const Array_&lt; Real, ConstrainedUIndex &gt; &amp;constrainedUDot, ConstrainedMobilizerIndex mobilizer, MobilizerUIndex whichU) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac79efe42c6959f6db7ca8c6661b66b66">SimTK::Constraint::Custom::Implementation::getOneUDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedUDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>whichU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this method in your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6f08835ee1dbc0b3bb5fcf5874517672" title="Calculate the mv errors arising from the first time derivative of the velocity-level specification of...">calcVelocityDotErrors()</a> and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad858507140b96505635cc9a0fef4fdf6" title="Calculate the ma acceleration-constraint errors due to the specification of an acceleration-only cons...">calcAccelerationErrors()</a> implementations to extract the value of a particular generalized speed derivative udot selected by (mobilizer,whichU), from the "constrained udot" argument that is passed to these two methods from Simbody. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Supplied state which is used only for modeling information; udots within <em>state</em> are ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constrainedUDot</td><td>This is the argument that is supplied to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6f08835ee1dbc0b3bb5fcf5874517672" title="Calculate the mv errors arising from the first time derivative of the velocity-level specification of...">calcVelocityDotErrors()</a> and calcAccelerationErrros() from which we will extract the particular udot value selected by the next two arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mobilizer</td><td>The constrained mobilizer one of whose generalized speeds is of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whichU</td><td>The particular generalized speed of <em>mobilizer</em> whose udot value we want. The actual value will be selected from <em>constrainedUDot</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the generalized speed derivative udot of interest, extracted from the <em>constrainedUDot</em> argument.</dd></dl>
<p>There is no getOneUDotFromState() method because all the acceleration- level methods are passed qdotdot or udot as an explicit argument. </p>

</div>
</div>
<a class="anchor" id="a57208e8f15f98285c54ebdc28e5991fd"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addInOneMobilityForce" ref="a57208e8f15f98285c54ebdc28e5991fd" args="(const State &amp;state, ConstrainedMobilizerIndex mobilizer, MobilizerUIndex whichU, Real fu, Array_&lt; Real, ConstrainedUIndex &gt; &amp;mobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a57208e8f15f98285c54ebdc28e5991fd">SimTK::Constraint::Custom::Implementation::addInOneMobilityForce</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>whichU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>fu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a scalar generalized (mobility-space) force <em>fu</em> to a particular mobility of one of this Constraint's Constrained Mobilizers, <em>adding</em> it in to the appropriate slot of the mobilityForces vector, which is of length <a class="el" href="classSimTK_1_1Constraint.html#a1bf71bb7e093d99f16537393c398fe35" title="Return the number of constrainable mobilities u associated with a particular constrained mobilizer...">getNumConstrainedU()</a> for this Constraint. </p>
<p><a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> need only have been realized to Model stage, but this is intended for use in Velocity-stage calls to addInXXXConstraintForce() methods for nonholonomic (velocity) or acceleration-only constraint equations. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aed846d20c3e7a3c2c24e5708bb946393" title="For use with holonomic (position) constraints, this method allows generalized forces to be applied in...">addInOneQForce()</a> for use in position (holonomic) constraints </dd></dl>

</div>
</div>
<a class="anchor" id="aed846d20c3e7a3c2c24e5708bb946393"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addInOneQForce" ref="aed846d20c3e7a3c2c24e5708bb946393" args="(const State &amp;state, ConstrainedMobilizerIndex mobilizer, MobilizerQIndex whichQ, Real fq, Array_&lt; Real, ConstrainedQIndex &gt; &amp;qForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aed846d20c3e7a3c2c24e5708bb946393">SimTK::Constraint::Custom::Implementation::addInOneQForce</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedMobilizerIndex&#160;</td>
          <td class="paramname"><em>mobilizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a>&#160;</td>
          <td class="paramname"><em>whichQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>fq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>qForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For use with holonomic (position) constraints, this method allows generalized forces to be applied in "q-space" rather than "u-space". </p>
<p>A scalar q-space generalized force <em>fq</em> is applied to a particular generalized coordinate (q) of one of this position (holonomic) Constraint's Constrained Mobilizers, <em>adding</em> it in to the appropriate slot of the qForces vector, which must be of length <a class="el" href="classSimTK_1_1Constraint.html#a2ce8087160568d8baed8371ca2c05610" title="Return the number of constrainable generalized coordinates q associated with a particular constrained...">getNumConstrainedQ()</a> for this Constraint. <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> need only have been realized to Model stage, but this is intended for Position-stage use in the addInPositionConstraintForce() method for position constraint equations.</p>
<p>Simbody will convert these automatically to mobility (u) space as needed via fu = ~N * fq, where N is block-diagonal kinematic coupling matrix that appears in the equation qdot = N*u. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>addInOneMobilityForces() for velocity and acceleration-only constraint equations </dd></dl>

</div>
</div>
<a class="anchor" id="a3551c1427f3526d23fb6f0a1029bce1c"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyTransform" ref="a3551c1427f3526d23fb6f0a1029bce1c" args="(const Array_&lt; Transform, ConstrainedBodyIndex &gt; &amp;allX_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3551c1427f3526d23fb6f0a1029bce1c">SimTK::Constraint::Custom::Implementation::getBodyTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allX_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract from the <em>allX_AB</em> argument the spatial transform X_AB giving the pose (orientation and location) of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B in this constraint's Ancestor frame A. </p>

</div>
</div>
<a class="anchor" id="a215d13299e99df4ebc15ff2f465041ee"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyRotation" ref="a215d13299e99df4ebc15ff2f465041ee" args="(const Array_&lt; Transform, ConstrainedBodyIndex &gt; &amp;allX_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a215d13299e99df4ebc15ff2f465041ee">SimTK::Constraint::Custom::Implementation::getBodyRotation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allX_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3551c1427f3526d23fb6f0a1029bce1c" title="Extract from the allX_AB argument the spatial transform X_AB giving the pose (orientation and locatio...">getBodyTransform()</a> that returns just the orientation as the Rotation matrix R_AB. </p>

</div>
</div>
<a class="anchor" id="aab92a4c7417d7d396c02a8d62c8c10bc"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyOriginLocation" ref="aab92a4c7417d7d396c02a8d62c8c10bc" args="(const Array_&lt; Transform, ConstrainedBodyIndex &gt; &amp;allX_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aab92a4c7417d7d396c02a8d62c8c10bc">SimTK::Constraint::Custom::Implementation::getBodyOriginLocation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allX_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3551c1427f3526d23fb6f0a1029bce1c" title="Extract from the allX_AB argument the spatial transform X_AB giving the pose (orientation and locatio...">getBodyTransform()</a> that returns just the location part of B's pose in A, that is the vector p_AB from A's origin Ao to B's origin Bo, expressed in A. </p>

</div>
</div>
<a class="anchor" id="a307aaa19ecb04d37c9c4df5440de4712"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyTransformFromState" ref="a307aaa19ecb04d37c9c4df5440de4712" args="(const State &amp;state, ConstrainedBodyIndex B) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a307aaa19ecb04d37c9c4df5440de4712">SimTK::Constraint::Custom::Implementation::getBodyTransformFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract from the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> cache the spatial transform X_AB giving the pose (orientation and location) of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B in this constraint's Ancestor frame A. </p>
<p>Do not use this method in a routine that has an explicit argument providing the transforms X_AB; use the above <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3551c1427f3526d23fb6f0a1029bce1c" title="Extract from the allX_AB argument the spatial transform X_AB giving the pose (orientation and locatio...">getBodyTransform()</a> method instead. </p>

</div>
</div>
<a class="anchor" id="a2d1556009bb593241e7410e797b7878b"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyRotationFromState" ref="a2d1556009bb593241e7410e797b7878b" args="(const State &amp;state, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2d1556009bb593241e7410e797b7878b">SimTK::Constraint::Custom::Implementation::getBodyRotationFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a307aaa19ecb04d37c9c4df5440de4712" title="Extract from the State cache the spatial transform X_AB giving the pose (orientation and location) of...">getBodyTransformFromState()</a> that returns just the orientation as the Rotation matrix R_AB. </p>

</div>
</div>
<a class="anchor" id="a6c5ec5a45be0dace470ce9af45516dcb"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyOriginLocationFromState" ref="a6c5ec5a45be0dace470ce9af45516dcb" args="(const State &amp;state, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6c5ec5a45be0dace470ce9af45516dcb">SimTK::Constraint::Custom::Implementation::getBodyOriginLocationFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a307aaa19ecb04d37c9c4df5440de4712" title="Extract from the State cache the spatial transform X_AB giving the pose (orientation and location) of...">getBodyTransformFromState()</a> that returns just the location part of B's pose in A, that is the vector p_AB from A's origin Ao to B's origin Bo, expressed in A. </p>

</div>
</div>
<a class="anchor" id="ade0b79471ec10de5d93eedb1fc7063c5"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyVelocity" ref="ade0b79471ec10de5d93eedb1fc7063c5" args="(const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;allV_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ade0b79471ec10de5d93eedb1fc7063c5">SimTK::Constraint::Custom::Implementation::getBodyVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allV_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract from the <em>allV_AB</em> argument the spatial velocity V_AB giving the angular and linear velocity of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B measured and expressed in this constraint's Ancestor frame A. </p>

</div>
</div>
<a class="anchor" id="aac35e848b3063ff03b60081de732cdc8"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyAngularVelocity" ref="aac35e848b3063ff03b60081de732cdc8" args="(const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;allV_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aac35e848b3063ff03b60081de732cdc8">SimTK::Constraint::Custom::Implementation::getBodyAngularVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allV_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ade0b79471ec10de5d93eedb1fc7063c5" title="Extract from the allV_AB argument the spatial velocity V_AB giving the angular and linear velocity of...">getBodyVelocity()</a> that returns just the angular velocity vector w_AB. </p>

</div>
</div>
<a class="anchor" id="a6c0efa72caa680bd077b115c9c08c2ac"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyOriginVelocity" ref="a6c0efa72caa680bd077b115c9c08c2ac" args="(const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;allV_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6c0efa72caa680bd077b115c9c08c2ac">SimTK::Constraint::Custom::Implementation::getBodyOriginVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allV_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ade0b79471ec10de5d93eedb1fc7063c5" title="Extract from the allV_AB argument the spatial velocity V_AB giving the angular and linear velocity of...">getBodyVelocity()</a> that returns just the linear velocity vector v_AB. </p>

</div>
</div>
<a class="anchor" id="af5f4d589e94f6a41f0f9da03a5444a1f"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyVelocityFromState" ref="af5f4d589e94f6a41f0f9da03a5444a1f" args="(const State &amp;state, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af5f4d589e94f6a41f0f9da03a5444a1f">SimTK::Constraint::Custom::Implementation::getBodyVelocityFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract from the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> cache the spatial velocity V_AB giving the angular and linear velocity of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B measured and expressed in this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>'s Ancestor frame A. </p>
<p>Do not use this method in a routine that has an explicit argument providing the spatial velocities V_AB; use the above <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ade0b79471ec10de5d93eedb1fc7063c5" title="Extract from the allV_AB argument the spatial velocity V_AB giving the angular and linear velocity of...">getBodyVelocity()</a> method instead. </p>

</div>
</div>
<a class="anchor" id="ae8c9d2983af4fb1fb6dc662506ff76e5"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyAngularVelocityFromState" ref="ae8c9d2983af4fb1fb6dc662506ff76e5" args="(const State &amp;state, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ae8c9d2983af4fb1fb6dc662506ff76e5">SimTK::Constraint::Custom::Implementation::getBodyAngularVelocityFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af5f4d589e94f6a41f0f9da03a5444a1f" title="Extract from the State cache the spatial velocity V_AB giving the angular and linear velocity of a Co...">getBodyVelocityFromState()</a> that returns just the angular velocity vector w_AB. </p>

</div>
</div>
<a class="anchor" id="ab64effcd9e8680ead8c20f007f4adf40"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyOriginVelocityFromState" ref="ab64effcd9e8680ead8c20f007f4adf40" args="(const State &amp;state, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ab64effcd9e8680ead8c20f007f4adf40">SimTK::Constraint::Custom::Implementation::getBodyOriginVelocityFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af5f4d589e94f6a41f0f9da03a5444a1f" title="Extract from the State cache the spatial velocity V_AB giving the angular and linear velocity of a Co...">getBodyVelocityFromState()</a> that returns just the linear velocity vector v_AB. </p>

</div>
</div>
<a class="anchor" id="aa3209d049563debdddbebe44baa37e61"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyAcceleration" ref="aa3209d049563debdddbebe44baa37e61" args="(const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;allA_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aa3209d049563debdddbebe44baa37e61">SimTK::Constraint::Custom::Implementation::getBodyAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allA_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract from the <em>allA_AB</em> argument the spatial acceleration A_AB giving the angular and linear acceleration of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B's body frame B measured and expressed in this constraint's Ancestor frame A. </p>
<p>Note that there is no getBodyAccelerationFromState() method because all acceleration-level methods will be passed body accelerations explicitly. </p>

</div>
</div>
<a class="anchor" id="a4bc1a14f11e29fdce97f1ea34a096db8"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyAngularAcceleration" ref="a4bc1a14f11e29fdce97f1ea34a096db8" args="(const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;allA_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a4bc1a14f11e29fdce97f1ea34a096db8">SimTK::Constraint::Custom::Implementation::getBodyAngularAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allA_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aa3209d049563debdddbebe44baa37e61" title="Extract from the allA_AB argument the spatial acceleration A_AB giving the angular and linear acceler...">getBodyAcceleration()</a> that returns just the angular acceleration vector b_AB. </p>

</div>
</div>
<a class="anchor" id="a3d803decfe2575df35f8ad34ea6c35a9"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getBodyOriginAcceleration" ref="a3d803decfe2575df35f8ad34ea6c35a9" args="(const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;allA_AB, ConstrainedBodyIndex bodyB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a3d803decfe2575df35f8ad34ea6c35a9">SimTK::Constraint::Custom::Implementation::getBodyOriginAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allA_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient inline interface to <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#aa3209d049563debdddbebe44baa37e61" title="Extract from the allA_AB argument the spatial acceleration A_AB giving the angular and linear acceler...">getBodyAcceleration()</a> that returns just the linear acceleration vector a_AB. </p>

</div>
</div>
<a class="anchor" id="ad6acf838ab261b6590936aa56ba89693"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::findStationLocation" ref="ad6acf838ab261b6590936aa56ba89693" args="(const Array_&lt; Transform, ConstrainedBodyIndex &gt; &amp;allX_AB, ConstrainedBodyIndex bodyB, const Vec3 &amp;p_BS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad6acf838ab261b6590936aa56ba89693">SimTK::Constraint::Custom::Implementation::findStationLocation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allX_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_BS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the position p_AS in the Ancestor frame of a station S of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B, specified with the position vector p_BS (or more explicitly, p_BoS) from the B frame origin Bo to the point S, expressed in the B frame. </p>
<p>The return value is a position vector from the Ancestor frame's origin Ao to the location of the point S, expressed in the Ancestor frame. Cost is 18 flops. </p>

</div>
</div>
<a class="anchor" id="a57b49bcfbc37665dfa48f9548b32a4b0"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::findStationLocationFromState" ref="a57b49bcfbc37665dfa48f9548b32a4b0" args="(const State &amp;state, ConstrainedBodyIndex bodyB, const Vec3 &amp;p_BS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a57b49bcfbc37665dfa48f9548b32a4b0">SimTK::Constraint::Custom::Implementation::findStationLocationFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_BS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad6acf838ab261b6590936aa56ba89693" title="Calculate the position p_AS in the Ancestor frame of a station S of a Constrained Body B...">findStationLocation()</a> but for when you have to get the position information from the <em>state</em> rather than from an explicit argument. </p>
<p>Cost is 18 flops. </p>

</div>
</div>
<a class="anchor" id="a5f82f34f6ce65ef0e156a8f02f7c90dd"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::findStationVelocity" ref="a5f82f34f6ce65ef0e156a8f02f7c90dd" args="(const State &amp;state, const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;allV_AB, ConstrainedBodyIndex bodyB, const Vec3 &amp;p_BS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5f82f34f6ce65ef0e156a8f02f7c90dd">SimTK::Constraint::Custom::Implementation::findStationVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allV_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_BS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the velocity v_AS in the Ancestor frame of a station S of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B, specified with the position vector p_BS (or more explicitly, p_BoS) from the B frame origin Bo to the point S, expressed in the B frame. </p>
<p>The return value v_AS is a vector expressed in the Ancestor frame, and is the time derivative taken in A of the position vector p_AS. Cost is 27 flops. </p>

</div>
</div>
<a class="anchor" id="a4a210086ef3672ccd9b6dd3fd81326f2"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::findStationVelocityFromState" ref="a4a210086ef3672ccd9b6dd3fd81326f2" args="(const State &amp;state, ConstrainedBodyIndex bodyB, const Vec3 &amp;p_BS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a4a210086ef3672ccd9b6dd3fd81326f2">SimTK::Constraint::Custom::Implementation::findStationVelocityFromState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_BS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5f82f34f6ce65ef0e156a8f02f7c90dd" title="Calculate the velocity v_AS in the Ancestor frame of a station S of a Constrained Body B...">findStationVelocity()</a> but for when you have to get the velocity information from the <em>state</em> rather than from an explicit argument. </p>
<p>Cost is 27 flops. </p>

</div>
</div>
<a class="anchor" id="a26d44cabfb561bebf9cb21c01169f38d"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::findStationAcceleration" ref="a26d44cabfb561bebf9cb21c01169f38d" args="(const State &amp;state, const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;allA_AB, ConstrainedBodyIndex bodyB, const Vec3 &amp;p_BS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a26d44cabfb561bebf9cb21c01169f38d">SimTK::Constraint::Custom::Implementation::findStationAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>allA_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_BS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the acceleration a_AS in the Ancestor frame of a station S of a Constrained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> B, specified with the position vector p_BS (or more explicitly, p_BoS) from the B frame origin Bo to the point S, expressed in the B frame. </p>
<p>The return value a_AS is a vector expressed in the Ancestor frame, and is the time derivative taken in A of the velocity vector v_AS and hence the second derivative taken in A of the position vectory p_AS. Note that there is no findStationAccelerationFromState() method because all acceleration-level routines here are provided acceleration information in explicit arguments. Cost is 48 flops. </p>

</div>
</div>
<a class="anchor" id="a2cd291bf9a8947bea8eca68e6227a930"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addInStationForce" ref="a2cd291bf9a8947bea8eca68e6227a930" args="(const State &amp;state, ConstrainedBodyIndex bodyB, const Vec3 &amp;p_BS, const Vec3 &amp;forceInA, Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;bodyForcesInA) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2cd291bf9a8947bea8eca68e6227a930">SimTK::Constraint::Custom::Implementation::addInStationForce</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_BS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>forceInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply an Ancestor-frame force to a B-frame station S given by the position vector p_BS (or more explicitly, p_BoS) from the B frame origin Bo to the point S, expressed in the B frame, <em>adding to</em> the appropriate <code>bodyForcesInA</code> entry for this ConstrainedBody B. </p>

</div>
</div>
<a class="anchor" id="a8447d5095d5ad4825af9ae0cf925ad5f"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addInBodyTorque" ref="a8447d5095d5ad4825af9ae0cf925ad5f" args="(const State &amp;state, ConstrainedBodyIndex bodyB, const Vec3 &amp;torqueInA, Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;bodyForcesInA) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a8447d5095d5ad4825af9ae0cf925ad5f">SimTK::Constraint::Custom::Implementation::addInBodyTorque</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstrainedBodyIndex&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>torqueInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply an Ancestor-frame torque to body B, <em>adding to</em> the appropriate <code>bodyForcesInA</code> entry for this ConstrainedBody B. </p>

</div>
</div>
<a class="anchor" id="a88fdde686279d159bc9ecef61cfaa30e"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::getMultipliers" ref="a88fdde686279d159bc9ecef61cfaa30e" args="(const State &amp;state, Array_&lt; Real &gt; &amp;multipliers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a88fdde686279d159bc9ecef61cfaa30e">SimTK::Constraint::Custom::Implementation::getMultipliers</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipliers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <em>state</em> as passed to your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7d9b2ddaf0bb159115e95da1cb976ae5" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method after any MobilizedBody Acc...">realizeAcceleration()</a> implementation, obtain the multipliers that Simbody just calculated for this Constraint. </p>

</div>
</div>
<a class="anchor" id="a99f1ba084b572abc6eb40e1f8d9ff2e7"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizeTopology" ref="a99f1ba084b572abc6eb40e1f8d9ff2e7" args="(State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a99f1ba084b572abc6eb40e1f8d9ff2e7">SimTK::Constraint::Custom::Implementation::realizeTopology</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a99f1ba084b572abc6eb40e1f8d9ff2e7" title="The Matter Subsystem&#39;s realizeTopology() method will call this method after all MobilizedBody topolog...">realizeTopology()</a> method will call this method after all <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> topology has been processed. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Topology stage "cache" values (mutable values which are stored in the derived <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html" title="This is the abstract base class for the implementation of custom constraints. See Constraint::Custom ...">Implementation</a> class directly), and</li>
<li>allocate Model-stage state variables for later use, and</li>
<li>allocate Model-stage cache entries in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. The indices to the Model-stage state &amp; cache entries must be stored locally as part of the Topology-stage cache. </li>
</ul>

</div>
</div>
<a class="anchor" id="adaef15dfa453837e25f124cf56c7a4e9"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizeModel" ref="adaef15dfa453837e25f124cf56c7a4e9" args="(State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#adaef15dfa453837e25f124cf56c7a4e9">SimTK::Constraint::Custom::Implementation::realizeModel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#adaef15dfa453837e25f124cf56c7a4e9" title="The Matter Subsystem&#39;s realizeModel() method will call this method after all MobilizedBody Model-stag...">realizeModel()</a> method will call this method after all <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Model-stage processing has been done. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Model stage cache values according to the settings of the Model variables,</li>
<li>allocate any later-Stage variables that may be needed (typically these will be Instance stage variables containing geometric information or constraint parameters like lengths or velocities. The indices to any of the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> entries allocated here must be stored in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> as part of the Model-stage cache. </li>
</ul>

</div>
</div>
<a class="anchor" id="a30849e5e2a6972ba7f8d43e841869681"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizeInstance" ref="a30849e5e2a6972ba7f8d43e841869681" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a30849e5e2a6972ba7f8d43e841869681">SimTK::Constraint::Custom::Implementation::realizeInstance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a30849e5e2a6972ba7f8d43e841869681" title="The Matter Subsystem&#39;s realizeInstance() method will call this method after all MobilizedBody Instanc...">realizeInstance()</a> method will call this method after all <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Instance-stage processing has been done. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Instance stage cache values according to the settings of the Instance variables. </li>
</ul>

</div>
</div>
<a class="anchor" id="af50b75ae1ed74a80f8923c7ce2ae7556"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizeTime" ref="af50b75ae1ed74a80f8923c7ce2ae7556" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af50b75ae1ed74a80f8923c7ce2ae7556">SimTK::Constraint::Custom::Implementation::realizeTime</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af50b75ae1ed74a80f8923c7ce2ae7556" title="The Matter Subsystem&#39;s realizeTime() method will call this method after any MobilizedBody Time-stage ...">realizeTime()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Time-stage processing has been done. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Time stage cache values according to the current value of time found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0088e0d29d10565fe32ccb4941f75a14"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizePosition" ref="a0088e0d29d10565fe32ccb4941f75a14" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0088e0d29d10565fe32ccb4941f75a14">SimTK::Constraint::Custom::Implementation::realizePosition</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0088e0d29d10565fe32ccb4941f75a14" title="The Matter Subsystem&#39;s realizePosition() method will call this method after any MobilizedBody Positio...">realizePosition()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Position-stage processing has been done, and <em>after</em> the call has been made to your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a> operator. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Position stage cache values according to the current values of positions and position errors found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a01960c769f9b9011fed580d3bd6c2200"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizeVelocity" ref="a01960c769f9b9011fed580d3bd6c2200" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a01960c769f9b9011fed580d3bd6c2200">SimTK::Constraint::Custom::Implementation::realizeVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a01960c769f9b9011fed580d3bd6c2200" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method after any MobilizedBody Velocit...">realizeVelocity()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Velocity-stage processing has been done, and <em>after</em> your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac1a652c53c39b2b73937e250a35d953b" title="Calculate the mv velocity-constraint errors due to the velocity-level specification of a nonholonomic...">calcVelocityErrors()</a> and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5ad3a319511a9090af12074c6b01b492" title="Calculate the mp velocity errors arising from the first time derivative of the position-level holonom...">calcPositionDotErrors()</a> operators have been called. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Velocity stage cache values according to the current values of velocities and velocity errors found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7cca4e24f343623dc3a1816d45d40687"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizeDynamics" ref="a7cca4e24f343623dc3a1816d45d40687" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7cca4e24f343623dc3a1816d45d40687">SimTK::Constraint::Custom::Implementation::realizeDynamics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7cca4e24f343623dc3a1816d45d40687" title="The Matter Subsystem&#39;s realizeDynamics() method will call this method after any MobilizedBody Dynamic...">realizeDynamics()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Dynamics-stage processing has been done. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Dynamics stage cache values according to the current values found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7d9b2ddaf0bb159115e95da1cb976ae5"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizeAcceleration" ref="a7d9b2ddaf0bb159115e95da1cb976ae5" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7d9b2ddaf0bb159115e95da1cb976ae5">SimTK::Constraint::Custom::Implementation::realizeAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a7d9b2ddaf0bb159115e95da1cb976ae5" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method after any MobilizedBody Acc...">realizeAcceleration()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Acceleration-stage processing has been done, and <em>after</em> your <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad858507140b96505635cc9a0fef4fdf6" title="Calculate the ma acceleration-constraint errors due to the specification of an acceleration-only cons...">calcAccelerationErrors()</a>, <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6f08835ee1dbc0b3bb5fcf5874517672" title="Calculate the mv errors arising from the first time derivative of the velocity-level specification of...">calcVelocityDotErrors()</a>, and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1772dfc2ef9beadcc1ae8dc4a69349db" title="Calculate the mp errors arising from the second time derivative of the position-level holonomic const...">calcPositionDotDotErrors()</a> operators have been called. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Acceleration stage cache values according to the current values of body and mobility accelerations, acceleration errors, and multiplier values found in the state. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab5117afd79477db3a20a75c803175deb"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::realizeReport" ref="ab5117afd79477db3a20a75c803175deb" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ab5117afd79477db3a20a75c803175deb">SimTK::Constraint::Custom::Implementation::realizeReport</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ab5117afd79477db3a20a75c803175deb" title="The Matter Subsystem&#39;s realizeReport() method will call this method after any MobilizedBody Report-st...">realizeReport()</a> method will call this method after any <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> Report-stage processing has been done. </p>
<p>This gives the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> a chance to</p>
<ul>
<li>calculate Report stage cache values according to the current values found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad5c47af5897f0d5827f8f70031dcf19e"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::calcPositionErrors" ref="ad5c47af5897f0d5827f8f70031dcf19e" args="(const State &amp;state, const Array_&lt; Transform, ConstrainedBodyIndex &gt; &amp;X_AB, const Array_&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQ, Array_&lt; Real &gt; &amp;perr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e">SimTK::Constraint::Custom::Implementation::calcPositionErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>perr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the <em>mp</em> position-constraint errors due to the position-level specification of a holonomic constraint and write them to <em>perr</em>, which will have been allocated to length <em>mp</em>; do not reallocate it. </p>
<p>When this is called, <em>state</em> will already have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a06ce2e5708ad9e6c20d8265601afbdb9" title="A new time has been realized.">Stage::Time</a>; all position information used in your implementation must be taken from the passed-in arguments <em>X_AB</em> and <em>constrainedQ</em>, not from <em>state</em>. </p>

</div>
</div>
<a class="anchor" id="a5ad3a319511a9090af12074c6b01b492"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::calcPositionDotErrors" ref="a5ad3a319511a9090af12074c6b01b492" args="(const State &amp;state, const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;V_AB, const Array_&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQDot, Array_&lt; Real &gt; &amp;pverr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5ad3a319511a9090af12074c6b01b492">SimTK::Constraint::Custom::Implementation::calcPositionDotErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedQDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>pverr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the <em>mp</em> velocity errors arising from the first time derivative of the position-level holonomic constraint function <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a>, and write them to <em>pverr</em>, which will have been allocated to length <em>mp</em>; do not reallocate it. </p>
<p>When this is called, <em>state</em> will have already been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a>; all velocity information used in your implementation must be taken from the passed-in arguments <em>V_AB</em> and <em>constrainedQDot</em>, not from <em>state</em>. However, you can obtain position information for the constrained bodies and constrained mobilizers from <em>state</em> using <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2f2e70cc801353257877229718eaa6e7" title="Same as the getOneQ() method but for use in methods to which no explicit &quot;constrained q&quot; argument is ...">getOneQFromState()</a>, <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a307aaa19ecb04d37c9c4df5440de4712" title="Extract from the State cache the spatial transform X_AB giving the pose (orientation and location) of...">getBodyTransformFromState()</a>, and related methods. The implementation of this method must produce <em>exactly</em> the time derivative of the implementation of <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a>. </p>

</div>
</div>
<a class="anchor" id="a1772dfc2ef9beadcc1ae8dc4a69349db"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::calcPositionDotDotErrors" ref="a1772dfc2ef9beadcc1ae8dc4a69349db" args="(const State &amp;state, const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;A_AB, const Array_&lt; Real, ConstrainedQIndex &gt; &amp;constrainedQDotDot, Array_&lt; Real &gt; &amp;paerr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a1772dfc2ef9beadcc1ae8dc4a69349db">SimTK::Constraint::Custom::Implementation::calcPositionDotDotErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedQDotDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>paerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the <em>mp</em> errors arising from the second time derivative of the position-level holonomic constraint function <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a>, and write them to <em>paerr</em>, which will have been allocated to length <em>mp</em>; do not reallocate it. </p>
<p>When this is called, <em>state</em> will already have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a>; all acceleration-level information used in your implementation must be taken from the passed-in arguments <em>A_AB</em> and <em>constrainedQDotDot</em>, <em>not</em> from <em>state</em>. However, you can obtain position and velocity information for the constrained bodies and constrained mobilizers from <em>state</em> using <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a2f2e70cc801353257877229718eaa6e7" title="Same as the getOneQ() method but for use in methods to which no explicit &quot;constrained q&quot; argument is ...">getOneQFromState()</a>, <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5dba6dd2509a84746892d6b5a8c79462" title="Same as the getOneQDot() method above but for use in velocity- or acceleration-level methods to which...">getOneQDotFromState()</a>, <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a307aaa19ecb04d37c9c4df5440de4712" title="Extract from the State cache the spatial transform X_AB giving the pose (orientation and location) of...">getBodyTransformFromState()</a>, <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af5f4d589e94f6a41f0f9da03a5444a1f" title="Extract from the State cache the spatial velocity V_AB giving the angular and linear velocity of a Co...">getBodyVelocityFromState()</a>, and related methods. The implementation of this method must produce <em>exactly</em> the time derivative of the implementation of <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5ad3a319511a9090af12074c6b01b492" title="Calculate the mp velocity errors arising from the first time derivative of the position-level holonom...">calcPositionDotErrors()</a>. </p>

</div>
</div>
<a class="anchor" id="a5f61701999a0b983d75bc1eb86e57956"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addInPositionConstraintForces" ref="a5f61701999a0b983d75bc1eb86e57956" args="(const State &amp;state, const Array_&lt; Real &gt; &amp;multipliers, Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;bodyForcesInA, Array_&lt; Real, ConstrainedQIndex &gt; &amp;qForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a5f61701999a0b983d75bc1eb86e57956">SimTK::Constraint::Custom::Implementation::addInPositionConstraintForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedQIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>qForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the <em>mp</em> supplied Lagrange multipliers provided in <em>multipliers</em>, calculate the forces produced by this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> on its Constrained Bodies and Constrained Qs. </p>
<p><a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> spatial forces are applied at the body origin and expressed in the Ancestor frame and written to an array <em>bodyForcesInA</em> of length <a class="el" href="classSimTK_1_1Constraint.html#afdbb3bdc7ba81fd95d9ea8e8a5d9293e" title="Return the number of unique bodies directly restricted by this constraint.">getNumConstrainedBodies()</a>. Q forces are written to an array <em>qForces</em> of length <a class="el" href="classSimTK_1_1Constraint.html#a2ce8087160568d8baed8371ca2c05610" title="Return the number of constrainable generalized coordinates q associated with a particular constrained...">getNumConstrainedQ()</a>, that is, the number of constrained <em>generalized coordinates</em> q, not the number of constrained <em>mobilizers</em> or constrained <em>mobilities</em> u. When this is called, <em>state</em> will already have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a> and all position-stage cache information is available including any that may have been calculated during the prior call to this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>'s <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad5c47af5897f0d5827f8f70031dcf19e" title="Calculate the mp position-constraint errors due to the position-level specification of a holonomic co...">calcPositionErrors()</a> method and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0088e0d29d10565fe32ccb4941f75a14" title="The Matter Subsystem&#39;s realizePosition() method will call this method after any MobilizedBody Positio...">realizePosition()</a> method. Simbody will already have ensured that the force-return arrays have been allocated to the right size and properly initialized; you need update only those to which you are applying forces.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Don't forget that you must <em>add in</em> your force contributions; don't just write them or you'll wipe out all preceding constraints' contributions! </dd></dl>

</div>
</div>
<a class="anchor" id="ac1a652c53c39b2b73937e250a35d953b"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::calcVelocityErrors" ref="ac1a652c53c39b2b73937e250a35d953b" args="(const State &amp;state, const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;V_AB, const Array_&lt; Real, ConstrainedUIndex &gt; &amp;constrainedU, Array_&lt; Real &gt; &amp;verr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac1a652c53c39b2b73937e250a35d953b">SimTK::Constraint::Custom::Implementation::calcVelocityErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>verr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the <em>mv</em> velocity-constraint errors due to the velocity-level specification of a nonholonomic constraint and write them to <em>verr</em>, which will already have been allocated to length <em>mv</em>; do not reallocate it. </p>
<p>When this is called, <em>state</em> will have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a>; all velocity-level information used in your implementation must be taken from the passed-in arguments <em>V_AB</em> and <em>constrainedU</em>, not from <em>state</em>. However, you may obtain time or any position-related information from <em>state</em>. A nonholonomic constraint may depend on <em>any</em> position information; you do not have to limit that to constrained bodies and mobilizers as you do for velocity-level information. </p>

</div>
</div>
<a class="anchor" id="a6f08835ee1dbc0b3bb5fcf5874517672"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::calcVelocityDotErrors" ref="a6f08835ee1dbc0b3bb5fcf5874517672" args="(const State &amp;state, const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;A_AB, const Array_&lt; Real, ConstrainedUIndex &gt; &amp;constrainedUDot, Array_&lt; Real &gt; &amp;vaerr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a6f08835ee1dbc0b3bb5fcf5874517672">SimTK::Constraint::Custom::Implementation::calcVelocityDotErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedUDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>vaerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the <em>mv</em> errors arising from the first time derivative of the velocity-level specification of a nonholonomic constraint and write them to <em>vaerr</em>, which will already have been allocated to length <em>mv</em>; do not reallocate it. </p>
<p>When this is called, <em>state</em> will have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a>; all acceleration-level information used in your implementation must be taken from the passed-in arguments <em>A_AB</em> and <em>constrainedUDot</em>, <em>not</em> from <em>state</em>. However, you can obtain from <em>state</em> time, and any needed position and velocity information. The implementation of this method must produce <em>exactly</em> the time derivative of the implementation of <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac1a652c53c39b2b73937e250a35d953b" title="Calculate the mv velocity-constraint errors due to the velocity-level specification of a nonholonomic...">calcVelocityErrors()</a>. </p>

</div>
</div>
<a class="anchor" id="ac3e58b9941a8896373b157365c7e4578"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addInVelocityConstraintForces" ref="ac3e58b9941a8896373b157365c7e4578" args="(const State &amp;state, const Array_&lt; Real &gt; &amp;multipliers, Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;bodyForcesInA, Array_&lt; Real, ConstrainedUIndex &gt; &amp;mobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ac3e58b9941a8896373b157365c7e4578">SimTK::Constraint::Custom::Implementation::addInVelocityConstraintForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the <code>mv</code> supplied Lagrange multipliers provided in <em>multipliers</em>, calculate the forces produced by this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> on its Constrained Bodies and Constrained Mobilities due to its velocity-level (nonholonomic) constraints. </p>
<p><a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> spatial forces are applied at the body origin and expressed in the Ancestor frame and written to an array <em>bodyForcesInA</em> of length <a class="el" href="classSimTK_1_1Constraint.html#afdbb3bdc7ba81fd95d9ea8e8a5d9293e" title="Return the number of unique bodies directly restricted by this constraint.">getNumConstrainedBodies()</a>. Mobility (generalized) forces are written to an array <em>mobilityForces</em> of length <a class="el" href="classSimTK_1_1Constraint.html#a1bf71bb7e093d99f16537393c398fe35" title="Return the number of constrainable mobilities u associated with a particular constrained mobilizer...">getNumConstrainedU()</a>, that is, the number of constrained <em>mobilities</em>, not the number of constrained <em>mobilizers</em>. The supplied <em>state</em> will have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a> and all position- and velocity-stage cache information is available including any that may have been calculated during the prior call to this constraint's <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0088e0d29d10565fe32ccb4941f75a14" title="The Matter Subsystem&#39;s realizePosition() method will call this method after any MobilizedBody Positio...">realizePosition()</a> and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a01960c769f9b9011fed580d3bd6c2200" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method after any MobilizedBody Velocit...">realizeVelocity()</a> methods. Simbody will already have ensured that the force-return arrays have been allocated to the right size and initialized properly; you need only update the non-zero ones.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Don't forget that you must <em>add in</em> your force contributions; don't just write them or you'll wipe out all preceding constraints' contributions! </dd></dl>

</div>
</div>
<a class="anchor" id="ad858507140b96505635cc9a0fef4fdf6"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::calcAccelerationErrors" ref="ad858507140b96505635cc9a0fef4fdf6" args="(const State &amp;state, const Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;A_AB, const Array_&lt; Real, ConstrainedUIndex &gt; &amp;constrainedUDot, Array_&lt; Real &gt; &amp;aerr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#ad858507140b96505635cc9a0fef4fdf6">SimTK::Constraint::Custom::Implementation::calcAccelerationErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>constrainedUDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>aerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the <em>ma</em> acceleration-constraint errors due to the specification of an acceleration-only constraint and write them to <em>aerr</em>, which will already have been allocated to length <em>ma</em>; do not reallocate it. </p>
<p>When this is called, <em>state</em> will have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a>; all acceleration-level information used in your implementation must be taken from the passed-in arguments <em>A_AB</em> and <em>constrainedUDot</em>, <em>not</em> from <em>state</em>. However, an acceleration-only constraint may depend arbitrarily on time, position, and velocity information which you may obtain freely from <em>state</em>; you do not have to limit that to constrained bodies and mobilizers as you do for acceleration-level information.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method <em>must</em> be linear in the accelerations; Simbody has no way to enforce that so it is up to you to do this correctly. </dd></dl>

</div>
</div>
<a class="anchor" id="a256f32f746ae6cc92780764da2b028f9"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::addInAccelerationConstraintForces" ref="a256f32f746ae6cc92780764da2b028f9" args="(const State &amp;state, const Array_&lt; Real &gt; &amp;multipliers, Array_&lt; SpatialVec, ConstrainedBodyIndex &gt; &amp;bodyForcesInA, Array_&lt; Real, ConstrainedUIndex &gt; &amp;mobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a256f32f746ae6cc92780764da2b028f9">SimTK::Constraint::Custom::Implementation::addInAccelerationConstraintForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>, ConstrainedBodyIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; Real, ConstrainedUIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the <em>ma</em> supplied Lagrange multipliers provided in <em>multipliers</em>, calculate the forces produced by this <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> on its Constrained Bodies and Constrained Mobilities due to its acceleration-only constraints. </p>
<p><a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> spatial forces are applied at the body origin and expressed in the Ancestor frame and written to an array <em>bodyForcesInA</em> of length <a class="el" href="classSimTK_1_1Constraint.html#afdbb3bdc7ba81fd95d9ea8e8a5d9293e" title="Return the number of unique bodies directly restricted by this constraint.">getNumConstrainedBodies()</a>. Mobility forces are written to an array <em>mobilityForces</em> of length <a class="el" href="classSimTK_1_1Constraint.html#a1bf71bb7e093d99f16537393c398fe35" title="Return the number of constrainable mobilities u associated with a particular constrained mobilizer...">getNumConstrainedU()</a>, that is, the number of constrained <em>mobilities</em>, not the number of constrained <em>mobilizers</em>. The <em>state</em> will have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a> and all position- and velocity-stage cache information is available including any that may have been calculated during the prior call to this constraint's <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a0088e0d29d10565fe32ccb4941f75a14" title="The Matter Subsystem&#39;s realizePosition() method will call this method after any MobilizedBody Positio...">realizePosition()</a> and <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#a01960c769f9b9011fed580d3bd6c2200" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method after any MobilizedBody Velocit...">realizeVelocity()</a> methods. Simbody will already have ensured that the force-return arrays have been allocated to the right size and initialized properly; you need only update the non-zero ones.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Don't forget that you must <em>add in</em> your force contributions; don't just write them or you'll wipe out all preceding constraints' contributions! </dd></dl>

</div>
</div>
<a class="anchor" id="af8269a724cb77b298abdc7acbeeb0d56"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::calcDecorativeGeometryAndAppend" ref="af8269a724cb77b298abdc7acbeeb0d56" args="(const State &amp;s, Stage stage, Array_&lt; DecorativeGeometry &gt; &amp;geom) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html#af8269a724cb77b298abdc7acbeeb0d56">SimTK::Constraint::Custom::Implementation::calcDecorativeGeometryAndAppend</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>geom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implement this optional method if you would like your constraint to generate any suggestions for geometry that could be used as default visualization as an aid to understanding a system containing this constraint. </p>
<p>For example, if your constraint connects two points, you might want to draw a line between those points. You can also generate text labels, and you can provide methods for controlling the presence or appearance of your generated geometry. If you don't implement this routine no geometry will be generated. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac7fb2fe2eab3303de126b490b5f62637"></a><!-- doxytag: member="SimTK::Constraint::Custom::Implementation::Constraint::CustomImpl" ref="ac7fb2fe2eab3303de126b490b5f62637" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class Constraint::CustomImpl<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Constraint_8h_source.html">Constraint.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Constraint.html">Constraint</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Constraint_1_1Custom.html">Custom</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Constraint_1_1Custom_1_1Implementation.html">Implementation</a>      </li>

    <li class="footer">Generated on Wed Oct 9 2013 08:38:52 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
