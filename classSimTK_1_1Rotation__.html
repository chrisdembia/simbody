<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::Rotation_&lt; P &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1Rotation__.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Rotation_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::Rotation_" --><!-- doxytag: inherits="Mat&lt; 3, 3, P &gt;" -->
<p>The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated with the relative orientation of two right-handed, orthogonal, unit vector bases.  
 <a href="classSimTK_1_1Rotation__.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Rotation_8h_source.html">Rotation.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Rotation_&lt; P &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Rotation__.png" usemap="#SimTK::Rotation_&lt; P &gt;_map" alt=""/>
  <map id="SimTK::Rotation_&lt; P &gt;_map" name="SimTK::Rotation_&lt; P &gt;_map">
<area href="classSimTK_1_1Mat.html" alt="SimTK::Mat&lt; 3, 3, P &gt;" shape="rect" coords="0,0,138,24"/>
</map>
 </div></div>

<p><a href="classSimTK_1_1Rotation__-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, <br class="typebreak"/>
<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a27fc7b5604dacb9eedeef01198463960">Mat33P::RowSpacing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The column and row unit vector types do not necessarily have unit spacing.  <a href="#a8156453423742aa7ab103650c3ffa4a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1UnitRow.html">UnitRow</a>&lt; P, <br class="typebreak"/>
<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a91607a34c56f039489106477fcfcecac">Mat33P::ColSpacing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a7dc8a355b0476f8fc3897225bcec0028">Rotation_</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a352f6087f76d893011d1cf4a168d58d4">setRotationToIdentityMatrix</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a360123fced580910bb805feb3a602258">setRotationToNaN</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a966293b042b3b6f3906bb15aec3110d2">Rotation_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad66e7d173f96a983c32d011bb0d91fc7">operator=</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a451308fdf619ff01b3b07a7d960cf354">Rotation_</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, RealP angle1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, RealP angle2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians)  <a href="#a451308fdf619ff01b3b07a7d960cf354"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4de3e72e32205e18ea71b03dfdc08932">Rotation_</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, RealP angle1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, RealP angle2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2, RealP angle3, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians)  <a href="#a4de3e72e32205e18ea71b03dfdc08932"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#afc54e75b189a41cf6b0e9d23458eae32">setRotationFromTwoAnglesTwoAxes</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, RealP angle1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, RealP angle2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians)  <a href="#afc54e75b189a41cf6b0e9d23458eae32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad19a5140a685462e498d6d5c2c42c8c4">setRotationFromThreeAnglesThreeAxes</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, RealP angle1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, RealP angle2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2, RealP angle3, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians)  <a href="#ad19a5140a685462e498d6d5c2c42c8c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af44ae0c01f7118c690a0c47cbf44e9a7">setRotationToBodyFixedXY</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> to represent a rotation characterized by subsequent rotations of: +v[0] about the body frame's X axis, followed by a rotation of +v[1] about the body frame's NEW Y axis.  <a href="#af44ae0c01f7118c690a0c47cbf44e9a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a1b5b9946341290a869fdf36263c6e901">setRotationToBodyFixedXYZ</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> to represent a rotation characterized by subsequent rotations of: +v[0] about the body frame's X axis, followed by a rotation of +v[1] about the body frame's NEW Y axis, followed by a rotation of +v[2] about the body frame's NEW Z axis.  <a href="#a1b5b9946341290a869fdf36263c6e901"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a511a6db1f00e0b2e535f70fb01d4009e">Rotation_</a> (const <a class="el" href="classSimTK_1_1Quaternion__.html">QuaternionP</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a rotation matrix from a quaternion.  <a href="#a511a6db1f00e0b2e535f70fb01d4009e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aed39e831fc2c774c769b4afb72830874">setRotationFromQuaternion</a> (const <a class="el" href="classSimTK_1_1Quaternion__.html">QuaternionP</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for creating a rotation matrix from a quaternion.  <a href="#aed39e831fc2c774c769b4afb72830874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9c751d1b449be1eba50a5b026a18b907">Rotation_</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m, bool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> directly from a Mat33P (we trust that m is a valid Rotation_!)  <a href="#a9c751d1b449be1eba50a5b026a18b907"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a8c1c1cf9f8c55f4371795eab53da933e">Rotation_</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an (hopefully nearby) orthogonal rotation matrix from a generic Mat33P.  <a href="#a8c1c1cf9f8c55f4371795eab53da933e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#acf320049f0aa881075905d781eee032f">setRotationFromApproximateMat33</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to an (hopefully nearby) orthogonal rotation matrix from a generic Mat33P.  <a href="#acf320049f0aa881075905d781eee032f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ac24f6d58ac08a8aa027bd04dc294b4d5">convertOneAxisRotationToOneAngle</a> (const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to a single orientation angle.  <a href="#ac24f6d58ac08a8aa027bd04dc294b4d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec2P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0670932d36daa77ab1bec1dfc9a2dbd9">convertTwoAxesRotationToTwoAngles</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to two orientation angles.  <a href="#a0670932d36daa77ab1bec1dfc9a2dbd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a8fedf3e4f467b4c46cb3d75c72d1cbe7">convertThreeAxesRotationToThreeAngles</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis3) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to three orientation angles.  <a href="#a8fedf3e4f467b4c46cb3d75c72d1cbe7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Quaternion__.html">QuaternionP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aeb0dbfbe9692728363f19291a36582fd">convertRotationToQuaternion</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to a quaternion.  <a href="#aeb0dbfbe9692728363f19291a36582fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec4P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af32d025ec1a522a1f97a420bdc1c542f">convertRotationToAngleAxis</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to angle-axis form.  <a href="#af32d025ec1a522a1f97a420bdc1c542f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec2P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae8fde87c8bfcd30533f47cbaa96d2fc9">convertRotationToBodyFixedXY</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient special case of <a class="el" href="classSimTK_1_1Rotation__.html#a0670932d36daa77ab1bec1dfc9a2dbd9" title="Converts rotation matrix to two orientation angles.">convertTwoAxesRotationToTwoAngles()</a>.  <a href="#ae8fde87c8bfcd30533f47cbaa96d2fc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a852ebf23b0a5075f89079184eea129ef">convertRotationToBodyFixedXYZ</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient special case of <a class="el" href="classSimTK_1_1Rotation__.html#a8fedf3e4f467b4c46cb3d75c72d1cbe7" title="Converts rotation matrix to three orientation angles.">convertThreeAxesRotationToThreeAngles()</a>.  <a href="#a852ebf23b0a5075f89079184eea129ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9408d46027f2faf546417095f9da84d8">reexpressSymMat33</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;S_BB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an efficient transform of a symmetric matrix that must be re-expressed with a multiply from both left and right, such as an inertia matrix.  <a href="#a9408d46027f2faf546417095f9da84d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a5f79467f7a137c87f11fd50dad4f5f64">getMaxAbsDifferenceInRotationElements</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aa137c322dd6f46282e335365ae1a24ce">areAllRotationElementsSameToEpsilon</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R, RealP epsilon) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ac1db1f3a440a79ad2e5b403913f44042">areAllRotationElementsSameToMachinePrecision</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a125229971a87b9405c6943687ae5cb6c">Rotation_</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like copy constructor but for inverse rotation. This allows implicit conversion from <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a> to <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a>.  <a href="#a125229971a87b9405c6943687ae5cb6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4ac773d1fe4e964aebf5c62c51f1cb1a">operator=</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like copy assignment but for inverse rotation.  <a href="#a4ac773d1fe4e964aebf5c62c51f1cb1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a29dabf3d119461ff356a6536ff2859d9">invert</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> to <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a> (no cost). Overrides base class <a class="el" href="classSimTK_1_1Rotation__.html#a29dabf3d119461ff356a6536ff2859d9" title="Convert from Rotation_ to InverseRotation_ (no cost). Overrides base class invert().">invert()</a>.  <a href="#a29dabf3d119461ff356a6536ff2859d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#abcf61a10b96a4320c991e55caa582386">updInvert</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> to writable <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a> (no cost).  <a href="#abcf61a10b96a4320c991e55caa582386"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aeaccae1010b6c9cc9427d2a39b686c76">row</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a914bb4f7f7e7c1e82aa7cc095e6704f2">col</a> (int j) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af36bd122d1e1b06b05d6f6a518f9bc52">x</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a5ea9cb2cb1301a551be2f575ec5dc39c">y</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a635c34523b636e2b0e767cbcae7185a5">z</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a84f0d8ba224b1b812be0f354d5d407be">operator[]</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a64e2dae5549468bf72dfa6dfe83f1555">operator()</a> (int j) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a6d2d3b70084a3a474bf2c8ac1f598bf6">setRotationToBodyFixedXYZ</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;c, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given cosines and sines (in that order) of three angles, set this Rotation matrix to the body-fixed 1-2-3 sequence of those angles.  <a href="#a6d2d3b70084a3a474bf2c8ac1f598bf6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a19962cc7af21545ae8e8f63702e83624">Rotation_</a> (RealP angle, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a19962cc7af21545ae8e8f63702e83624"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aeaa3df1484427409f85bdba47f263d18">Rotation_</a> (RealP angle, const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1XCoordinateAxis.html">CoordinateAxis::XCoordinateAxis</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#aeaa3df1484427409f85bdba47f263d18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a6a3cf04efd08eda9a303036fa6346bb9">Rotation_</a> (RealP angle, const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1YCoordinateAxis.html">CoordinateAxis::YCoordinateAxis</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a6a3cf04efd08eda9a303036fa6346bb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ab1171f57869b8633941395bc3baed5ed">Rotation_</a> (RealP angle, const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1ZCoordinateAxis.html">CoordinateAxis::ZCoordinateAxis</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#ab1171f57869b8633941395bc3baed5ed"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9d85ae0f22416a5cd6866596fc40f2d8">setRotationFromAngleAboutAxis</a> (RealP angle, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a9d85ae0f22416a5cd6866596fc40f2d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a2b0dd8018a891fae9f52a77a8af85913">setRotationFromAngleAboutX</a> (RealP angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a2b0dd8018a891fae9f52a77a8af85913"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a03c34f207cd0c05dcf8fb4fe01bece15">setRotationFromAngleAboutY</a> (RealP angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a03c34f207cd0c05dcf8fb4fe01bece15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a019d1ba576917c1294376af5d5c07684">setRotationFromAngleAboutZ</a> (RealP angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a019d1ba576917c1294376af5d5c07684"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad3626657c38a81b2df9205db8dd48af2">setRotationFromAngleAboutX</a> (RealP cosAngle, RealP sinAngle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#ad3626657c38a81b2df9205db8dd48af2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0429ecf9ca8d6bf23b2ea6a1067c13bf">setRotationFromAngleAboutY</a> (RealP cosAngle, RealP sinAngle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a0429ecf9ca8d6bf23b2ea6a1067c13bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a12bea1532e99c7e6aa83e189053000b2">setRotationFromAngleAboutZ</a> (RealP cosAngle, RealP sinAngle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a12bea1532e99c7e6aa83e189053000b2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae551ca3f12b485259ba56def8ccd152a">Rotation_</a> (RealP angle, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;unitVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about an arbitrary vector.  <a href="#ae551ca3f12b485259ba56def8ccd152a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a340d147e68d17979a01248d6b70cfe45">Rotation_</a> (RealP angle, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;nonUnitVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about an arbitrary vector.  <a href="#a340d147e68d17979a01248d6b70cfe45"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a13e4dcab37f729839b79abf5a5e77840">setRotationFromAngleAboutNonUnitVector</a> (RealP angle, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;nonUnitVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation of an angle (in radians) about an arbitrary vector.  <a href="#a13e4dcab37f729839b79abf5a5e77840"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a69dbe7f3f47a4b0c6d7be8650d95049c">setRotationFromAngleAboutUnitVector</a> (RealP angle, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;unitVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation of an angle (in radians) about an arbitrary vector.  <a href="#a69dbe7f3f47a4b0c6d7be8650d95049c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a297f4ad4b10f009c4cb18830af8da154">Rotation_</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;uvec, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> axis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate R_AB by knowing one of B's unit vector expressed in A.  <a href="#a297f4ad4b10f009c4cb18830af8da154"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a1716a6bd3d8ae76bbd59b139edcc2e2d">setRotationFromOneAxis</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;uvec, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> axis)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate R_AB by knowing one of B's unit vector expressed in A.  <a href="#a1716a6bd3d8ae76bbd59b139edcc2e2d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#abf7001ed401fb3f4550a6fae494a0c7a">Rotation_</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;uveci, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axisi, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;vecjApprox, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axisjApprox)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz) expressed in A and a vector v (also expressed in A) that is approximately in the desired direction for a second one of B's unit vectors, u2 (!= u1).  <a href="#abf7001ed401fb3f4550a6fae494a0c7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a7efe475b1e8a00f0628a74e660e84dfa">setRotationFromTwoAxes</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;uveci, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axisi, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;vecjApprox, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axisjApprox)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz) expressed in A and a vector v (also expressed in A) that is approximately in the desired direction for a second one of B's unit vectors, u2 (!= u1).  <a href="#a7efe475b1e8a00f0628a74e660e84dfa"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a44abc241c4d901a0a784a94d8ffa40a6">isSameRotationToWithinAngle</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R, RealP okPointingAngleErrorRads) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if "this" Rotation is nearly identical to "R" within a specified pointing angle error.  <a href="#a44abc241c4d901a0a784a94d8ffa40a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ac725bd972c9c54809b4b63880cb84fd2">isSameRotationToWithinAngleOfMachinePrecision</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if "this" Rotation is nearly identical to "R" within a specified pointing angle error.  <a href="#ac725bd972c9c54809b4b63880cb84fd2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a5440d77a9933a385260197de908d8798">transpose</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose, and transpose operators.  <a href="#a5440d77a9933a385260197de908d8798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a94968ae3dab970ba1c9ef24e58989673">operator~</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose, and transpose operators.  <a href="#a94968ae3dab970ba1c9ef24e58989673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a83d8ca5d3b3edd6630b5fb7a0a577d72">updTranspose</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose, and transpose operators.  <a href="#a83d8ca5d3b3edd6630b5fb7a0a577d72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aec15e73cf4dbcdc7e1c6ac90f68fdef3">operator~</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose, and transpose operators.  <a href="#aec15e73cf4dbcdc7e1c6ac90f68fdef3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a26169557db013c2a8779098d00d5c846">operator*=</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place composition of Rotation matrices.  <a href="#a26169557db013c2a8779098d00d5c846"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ab38257532c21876c8629b224f0431080">operator/=</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place composition of Rotation matrices.  <a href="#ab38257532c21876c8629b224f0431080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a7fa2ee262d79bf91ba2465bdbecb40c2">operator*=</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place composition of Rotation matrices.  <a href="#a7fa2ee262d79bf91ba2465bdbecb40c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a94079169da0047a42fe96411f36f9f42">operator/=</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place composition of Rotation matrices.  <a href="#a94079169da0047a42fe96411f36f9f42"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a97e3dd684128236abdd4729ddffb208e">asMat33</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from Rotation to its base class Mat33.  <a href="#a97e3dd684128236abdd4729ddffb208e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a02a8b19b9c7dab9b72762bd339cdb6a1">toMat33</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from Rotation to its base class Mat33.  <a href="#a02a8b19b9c7dab9b72762bd339cdb6a1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a34a70e677a952560b2ab8d972ed79801">setRotationFromMat33TrustMe</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix directly - but you had better know what you are doing!  <a href="#a34a70e677a952560b2ab8d972ed79801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9913668d30b526d87c63b175ccef9c56">setRotationColFromUnitVecTrustMe</a> (int colj, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;uvecj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix directly - but you had better know what you are doing!  <a href="#a9913668d30b526d87c63b175ccef9c56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a38115244428f8fc0f4411dd092ee5fe4">setRotationFromUnitVecsTrustMe</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;colA, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;colB, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;colC)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix directly - but you had better know what you are doing!  <a href="#a38115244428f8fc0f4411dd092ee5fe4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ada7be536a78529d455a292a04fc267bf">convertAngVelToBodyFixed321Dot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB_B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles forming a body-fixed 3-2-1 sequence, and the relative angular velocity vector of B in the parent frame, *BUT EXPRESSED IN THE BODY FRAME*, return the Euler angle derivatives.  <a href="#ada7be536a78529d455a292a04fc267bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0b2274baac7bc6e82343040f1850f59c">convertBodyFixed321DotToAngVel</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of the above routine.  <a href="#a0b2274baac7bc6e82343040f1850f59c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a41b70da72a012a4e248150759ae09a0b">convertAngVelDotToBodyFixed321DotDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB_B, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;wdot_PB_B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a">calcNForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix such that qdot=N_B(q)*w_PB_B where w_PB_B is the angular velocity of B in P EXPRESSED IN *B*!!! Note that N_B=N_P*R_PB.  <a href="#a3eb22f98f2a9088cf1012a5559548e3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aaaa54243d974e2c0a8bb80c201343ad4">calcNForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;sq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#aaaa54243d974e2c0a8bb80c201343ad4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5">calcNForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N matrix such that qdot=N_P(q)*w_PB where w_PB is the angular velocity of B in P expressed in P (not the convention that Kane uses, where angular velocities are expressed in the outboard body B).  <a href="#a0127cac78bdb1aea48a1b8294d2f13a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aabd585adb5a86dc06adc011d46c4d2a4">calcNForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;sq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5" title="Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N m...">calcNForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#aabd585adb5a86dc06adc011d46c4d2a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a">multiplyByBodyXYZ_N_P</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;sinxy, RealP oocosy, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular velocity of child in parent is expected to be expressed in the parent.  <a href="#a3d8d055de40c8993a4bb9bb2d86c784a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a776789cb0d7ba32361b1b43813591754">multiplyByBodyXYZ_NT_P</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;sinxy, RealP oocosy, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the fastest way to form the product v_P=~N_P*q=~(~q*N_P); see the untransposed method <a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a" title="This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular...">multiplyByBodyXYZ_N_P()</a> for information.  <a href="#a776789cb0d7ba32361b1b43813591754"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad8b111f6521a2001a2c2dbc00414d5ad">convertAngVelInParentToBodyXYZDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;sinxy, RealP oocosy, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate first time derivative qdot of body-fixed XYZ Euler angles q given sines and cosines of the Euler angles and the angular velocity w_PB of child B in parent P, expressed in P.  <a href="#ad8b111f6521a2001a2c2dbc00414d5ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aa5ee4bdfde750e6cb198494b1b522b20">convertAngAccInParentToBodyXYZDotDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;sinxy, RealP oocosy, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qdot, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;b_PB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate second time derivative qdotdot of body-fixed XYZ Euler angles q given sines and cosines of the Euler angles, the first derivative qdot and the angular acceleration b_PB of child B in parent P, expressed in P.  <a href="#aa5ee4bdfde750e6cb198494b1b522b20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad0edcb1b005f9a4980302c60cec1840d">multiplyByBodyXYZ_NInv_P</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;sinxy, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastest way to form the product w_PB=NInv_P*qdot.  <a href="#ad0edcb1b005f9a4980302c60cec1840d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae19740559fc48c4651696e8e1d4ff6d8">multiplyByBodyXYZ_NInvT_P</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;sinxy, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;v_P)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastest way to form the product q=~NInv_P*v_P=~(~v_P*NInv_P).  <a href="#ae19740559fc48c4651696e8e1d4ff6d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a57cc6b4aa8b35bb60f885bc8c07927ed">calcNDotForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot, return the block of the NDot matrix such that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of B in P EXPRESSED IN *B*!!! This matrix will be singular if Y (q[1]) gets near 90 degrees! See <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a> for the matrix we're differentiating here.  <a href="#a57cc6b4aa8b35bb60f885bc8c07927ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af1a07a41343d026e5f95c7072aa180b1">calcNDotForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;sq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a57cc6b4aa8b35bb60f885bc8c07927ed" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot...">calcNDotForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#af1a07a41343d026e5f95c7072aa180b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a713ce2d2d7aa5e3ba6bc4107f715bca2">calcNDotForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot, return the block of the NDot matrix such that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of B in P expressed in P.  <a href="#a713ce2d2d7aa5e3ba6bc4107f715bca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a731e89578e363e9c42f998b542682a35">calcNDotForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;sq, RealP ooc1, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a713ce2d2d7aa5e3ba6bc4107f715bca2" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot...">calcNDotForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#a731e89578e363e9c42f998b542682a35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aba5b6c3e33f68fc8105d2f2099969753">calcNInvForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of routine <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a>.  <a href="#aba5b6c3e33f68fc8105d2f2099969753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a05421fe60aadcdc2c5b9a02747568a73">calcNInvForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;sq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#aba5b6c3e33f68fc8105d2f2099969753" title="Inverse of routine calcNForBodyXYZInBodyFrame().">calcNInvForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#a05421fe60aadcdc2c5b9a02747568a73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a37fc3fe5bd8a98217aafeb5a6639ccbc">calcNInvForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of the above routine.  <a href="#a37fc3fe5bd8a98217aafeb5a6639ccbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a020a2169bc07b8e28414b75892986c9f">calcNInvForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;sq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a37fc3fe5bd8a98217aafeb5a6639ccbc" title="Inverse of the above routine.">calcNInvForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#a020a2169bc07b8e28414b75892986c9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae87f86eb9a0b8dff3202c35e39f1b16d">convertAngVelInBodyFrameToBodyXYZDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB_B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the relative angular velocity vector w_PB_B of B in the parent frame, <em>BUT EXPRESSED IN THE BODY FRAME</em>, return the Euler angle derivatives.  <a href="#ae87f86eb9a0b8dff3202c35e39f1b16d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aa59271d0544a807b0d43617485365efd">convertAngVelInBodyFrameToBodyXYZDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;sq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB_B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#ae87f86eb9a0b8dff3202c35e39f1b16d" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the relative angular velocity vecto...">convertAngVelInBodyFrameToBodyXYZDot()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#aa59271d0544a807b0d43617485365efd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#afc7286af6f32e76ddc0b5f90f7efd22e">convertBodyXYZDotToAngVelInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of the above routine.  <a href="#afc7286af6f32e76ddc0b5f90f7efd22e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aaed9d79a18b05275c469d18d58413ca5">convertBodyXYZDotToAngVelInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;sq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#afc7286af6f32e76ddc0b5f90f7efd22e" title="Inverse of the above routine.">convertBodyXYZDotToAngVelInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#aaed9d79a18b05275c469d18d58413ca5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aed514d5990532404a82da26793049900">convertAngVelDotInBodyFrameToBodyXYZDotDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB_B, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;wdot_PB_B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: sherm: is this right? Warning: everything is measured in the PARENT* frame, but has to be expressed in the *BODY* frame.  <a href="#aed514d5990532404a82da26793049900"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4ae5a0d854e698521bde92dfe17b84a7">convertAngVelDotInBodyFrameToBodyXYZDotDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;sq, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB_B, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;wdot_PB_B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#aed514d5990532404a82da26793049900" title="TODO: sherm: is this right? Warning: everything is measured in the PARENT* frame, but has to be expre...">convertAngVelDotInBodyFrameToBodyXYZDotDot()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#a4ae5a0d854e698521bde92dfe17b84a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat43P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af8b7a0f3971e33ca93521589eeb7cc1d">calcUnnormalizedNForQuaternion</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a possibly unnormalized quaternion q, calculate the 4x3 matrix N which maps angular velocity w to quaternion derivatives qdot.  <a href="#af8b7a0f3971e33ca93521589eeb7cc1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat43P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a30c0b4373719c68c0a14783d8fa8e8aa">calcUnnormalizedNDotForQuaternion</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the time derivative qdot of a possibly unnormalized quaternion q, calculate the 4x3 matrix NDot which is the time derivative of the matrix N as described in <a class="el" href="classSimTK_1_1Rotation__.html#af8b7a0f3971e33ca93521589eeb7cc1d" title="Given a possibly unnormalized quaternion q, calculate the 4x3 matrix N which maps angular velocity w ...">calcUnnormalizedNForQuaternion()</a>.  <a href="#a30c0b4373719c68c0a14783d8fa8e8aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat34P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a939de389a2ef2d6516aee271d1f04ad7">calcUnnormalizedNInvForQuaternion</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a (possibly unnormalized) quaternion q, calculate the 3x4 matrix NInv (= N^-1) which maps quaternion derivatives qdot to angular velocity w, where the angular velocity is in the parent frame, i.e.  <a href="#a939de389a2ef2d6516aee271d1f04ad7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aea472db472765197f6daf4624b9a0700">convertAngVelToQuaternionDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB_P)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a possibly unnormalized quaternion (0th element is the scalar) and the relative angular velocity vector of B in its parent, expressed in the *PARENT*, return the quaternion derivatives.  <a href="#aea472db472765197f6daf4624b9a0700"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#adc55fc1b16c0df4962094d3173ae4372">convertQuaternionDotToAngVel</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;qdot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of the above routine.  <a href="#adc55fc1b16c0df4962094d3173ae4372"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a8891cd55bbfc43e47421b7534c17b947">OLDconvertAngVelDotToQuaternionDotDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB_P, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;wdot_PB_P)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a quaternion q representing R_PB, angular velocity of B in P, and the time derivative of the angular velocity, return the second time derivative qdotdot of the quaternion.  <a href="#a8891cd55bbfc43e47421b7534c17b947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ac39e2b91d6d396f2002afb7f26335e64">convertAngVelDotToQuaternionDotDot</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;q, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;w_PB, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;b_PB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">We want to differentiate qdot=N(q)*w to get qdotdot=N*b+NDot*w where b is angular acceleration wdot.  <a href="#ac39e2b91d6d396f2002afb7f26335e64"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br/>
class SimTK::Rotation_&lt; P &gt;</h3>

<p>The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated with the relative orientation of two right-handed, orthogonal, unit vector bases. </p>
<p>The Rotation class takes advantage of known properties of orthogonal matrices. For example, multiplication by a rotation matrix preserves a vector's length so unit vectors are still unit vectors afterwards and don't need to be re-normalized.</p>
<p>A rotation is an orthogonal matrix whose columns and rows are directions (that is, unit vectors) that are mutually orthogonal. Furthermore, if the columns (or rows) are labeled x,y,z it always holds that z = x X y (rather than -(x X y)) ensuring that this is a right-handed rotation matrix and not a reflection. This is equivalent to saying that the determinant of a rotation matrix is 1, not -1.</p>
<p>Suppose there is a vector v_F expressed in terms of the right-handed, orthogonal unit vectors Fx, Fy, Fz and one would like to express v instead as v_G, in terms of a right-handed, orthogonal unit vectors Gx, Gy, Gz. To calculate it, we form a rotation matrix R_GF whose columns are the F unit vectors re-expressed in G: </p>
<pre>
             G F   (      |      |      )
      R_GF =  R  = ( Fx_G | Fy_G | Fz_G )
                   (      |      |      )
 where
      Fx_G = ~( ~Fx*Gx, ~Fx*Gy, ~Fx*Gz ), etc.
 </pre><p> (~Fx*Gx means dot(Fx,Gx)). Note that we use "monogram" notation R_GF in code to represent the more typographically demanding superscripted notation for rotation matrices. Now we can re-express the vector v from frame F to frame G via </p>
<pre>
      v_G = R_GF * v_F. 
 </pre><p> Because a rotation is orthogonal, its transpose is its inverse. Hence R_FG = ~R_GF (where ~ is the <a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a> "transpose" operator). This transpose matrix can be used to expressed v_G in terms of Fx, Fy, Fz as </p>
<pre>
      v_F = R_FG * v_G  or  v_F = ~R_GF * v_G
 </pre><p> In either direction, correct behavior can be obtained by using the recommended notation and then matching up the frame labels (after interpreting the "~" operator as reversing the labels). </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a8156453423742aa7ab103650c3ffa4a2"></a><!-- doxytag: member="SimTK::Rotation_::ColType" ref="a8156453423742aa7ab103650c3ffa4a2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt;P,<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a27fc7b5604dacb9eedeef01198463960">Mat33P::RowSpacing</a>&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The column and row unit vector types do not necessarily have unit spacing. </p>

</div>
</div>
<a class="anchor" id="a0c41f591c9926e8436596f924967f45c"></a><!-- doxytag: member="SimTK::Rotation_::RowType" ref="a0c41f591c9926e8436596f924967f45c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1UnitRow.html">UnitRow</a>&lt;P,<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a91607a34c56f039489106477fcfcecac">Mat33P::ColSpacing</a>&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7dc8a355b0476f8fc3897225bcec0028"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a7dc8a355b0476f8fc3897225bcec0028" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a966293b042b3b6f3906bb15aec3110d2"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a966293b042b3b6f3906bb15aec3110d2" args="(const Rotation_ &amp;R)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a19962cc7af21545ae8e8f63702e83624"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a19962cc7af21545ae8e8f63702e83624" args="(RealP angle, const CoordinateAxis &amp;axis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="aeaa3df1484427409f85bdba47f263d18"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="aeaa3df1484427409f85bdba47f263d18" args="(RealP angle, const CoordinateAxis::XCoordinateAxis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1XCoordinateAxis.html">CoordinateAxis::XCoordinateAxis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="a6a3cf04efd08eda9a303036fa6346bb9"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a6a3cf04efd08eda9a303036fa6346bb9" args="(RealP angle, const CoordinateAxis::YCoordinateAxis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1YCoordinateAxis.html">CoordinateAxis::YCoordinateAxis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="ab1171f57869b8633941395bc3baed5ed"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="ab1171f57869b8633941395bc3baed5ed" args="(RealP angle, const CoordinateAxis::ZCoordinateAxis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1ZCoordinateAxis.html">CoordinateAxis::ZCoordinateAxis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="ae551ca3f12b485259ba56def8ccd152a"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="ae551ca3f12b485259ba56def8ccd152a" args="(RealP angle, const UnitVec3P &amp;unitVector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>unitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about an arbitrary vector. </p>

</div>
</div>
<a class="anchor" id="a340d147e68d17979a01248d6b70cfe45"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a340d147e68d17979a01248d6b70cfe45" args="(RealP angle, const Vec3P &amp;nonUnitVector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>nonUnitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about an arbitrary vector. </p>

</div>
</div>
<a class="anchor" id="a451308fdf619ff01b3b07a7d960cf354"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a451308fdf619ff01b3b07a7d960cf354" args="(BodyOrSpaceType bodyOrSpace, RealP angle1, const CoordinateAxis &amp;axis1, RealP angle2, const CoordinateAxis &amp;axis2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians) </p>

</div>
</div>
<a class="anchor" id="a4de3e72e32205e18ea71b03dfdc08932"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a4de3e72e32205e18ea71b03dfdc08932" args="(BodyOrSpaceType bodyOrSpace, RealP angle1, const CoordinateAxis &amp;axis1, RealP angle2, const CoordinateAxis &amp;axis2, RealP angle3, const CoordinateAxis &amp;axis3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians) </p>

</div>
</div>
<a class="anchor" id="a511a6db1f00e0b2e535f70fb01d4009e"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a511a6db1f00e0b2e535f70fb01d4009e" args="(const QuaternionP &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Quaternion__.html">QuaternionP</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for creating a rotation matrix from a quaternion. </p>

</div>
</div>
<a class="anchor" id="a9c751d1b449be1eba50a5b026a18b907"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a9c751d1b449be1eba50a5b026a18b907" args="(const Mat33P &amp;m, bool)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> directly from a Mat33P (we trust that m is a valid Rotation_!) </p>

</div>
</div>
<a class="anchor" id="a8c1c1cf9f8c55f4371795eab53da933e"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a8c1c1cf9f8c55f4371795eab53da933e" args="(const Mat33P &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs an (hopefully nearby) orthogonal rotation matrix from a generic Mat33P. </p>

</div>
</div>
<a class="anchor" id="a297f4ad4b10f009c4cb18830af8da154"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a297f4ad4b10f009c4cb18830af8da154" args="(const UnitVec3P &amp;uvec, const CoordinateAxis axis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate R_AB by knowing one of B's unit vector expressed in A. </p>
<p>Note: The other vectors are perpendicular (but somewhat arbitrarily so). </p>

</div>
</div>
<a class="anchor" id="abf7001ed401fb3f4550a6fae494a0c7a"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="abf7001ed401fb3f4550a6fae494a0c7a" args="(const UnitVec3P &amp;uveci, const CoordinateAxis &amp;axisi, const Vec3P &amp;vecjApprox, const CoordinateAxis &amp;axisjApprox)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uveci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axisi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>vecjApprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axisjApprox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz) expressed in A and a vector v (also expressed in A) that is approximately in the desired direction for a second one of B's unit vectors, u2 (!= u1). </p>
<p>If v is not perpendicular to u1, no worries - we'll find a direction for u2 that is perpendicular to u1 and comes closest to v. The third vector u3 is +/- u1 X u2, as appropriate for a right-handed rotation matrix. </p>

</div>
</div>
<a class="anchor" id="a125229971a87b9405c6943687ae5cb6c"></a><!-- doxytag: member="SimTK::Rotation_::Rotation_" ref="a125229971a87b9405c6943687ae5cb6c" args="(const InverseRotation_&lt; P &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like copy constructor but for inverse rotation. This allows implicit conversion from <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a> to <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a352f6087f76d893011d1cf4a168d58d4"></a><!-- doxytag: member="SimTK::Rotation_::setRotationToIdentityMatrix" ref="a352f6087f76d893011d1cf4a168d58d4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a352f6087f76d893011d1cf4a168d58d4">setRotationToIdentityMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a360123fced580910bb805feb3a602258"></a><!-- doxytag: member="SimTK::Rotation_::setRotationToNaN" ref="a360123fced580910bb805feb3a602258" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a360123fced580910bb805feb3a602258">setRotationToNaN</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad66e7d173f96a983c32d011bb0d91fc7"></a><!-- doxytag: member="SimTK::Rotation_::operator=" ref="ad66e7d173f96a983c32d011bb0d91fc7" args="(const Rotation_ &amp;R)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d85ae0f22416a5cd6866596fc40f2d8"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutAxis" ref="a9d85ae0f22416a5cd6866596fc40f2d8" args="(RealP angle, const CoordinateAxis &amp;axis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a9d85ae0f22416a5cd6866596fc40f2d8">setRotationFromAngleAboutAxis</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="a2b0dd8018a891fae9f52a77a8af85913"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutX" ref="a2b0dd8018a891fae9f52a77a8af85913" args="(RealP angle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a2b0dd8018a891fae9f52a77a8af85913">setRotationFromAngleAboutX</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="a03c34f207cd0c05dcf8fb4fe01bece15"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutY" ref="a03c34f207cd0c05dcf8fb4fe01bece15" args="(RealP angle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a03c34f207cd0c05dcf8fb4fe01bece15">setRotationFromAngleAboutY</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="a019d1ba576917c1294376af5d5c07684"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutZ" ref="a019d1ba576917c1294376af5d5c07684" args="(RealP angle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a019d1ba576917c1294376af5d5c07684">setRotationFromAngleAboutZ</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="ad3626657c38a81b2df9205db8dd48af2"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutX" ref="ad3626657c38a81b2df9205db8dd48af2" args="(RealP cosAngle, RealP sinAngle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a2b0dd8018a891fae9f52a77a8af85913">setRotationFromAngleAboutX</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>cosAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>sinAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="a0429ecf9ca8d6bf23b2ea6a1067c13bf"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutY" ref="a0429ecf9ca8d6bf23b2ea6a1067c13bf" args="(RealP cosAngle, RealP sinAngle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a03c34f207cd0c05dcf8fb4fe01bece15">setRotationFromAngleAboutY</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>cosAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>sinAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="a12bea1532e99c7e6aa83e189053000b2"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutZ" ref="a12bea1532e99c7e6aa83e189053000b2" args="(RealP cosAngle, RealP sinAngle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a019d1ba576917c1294376af5d5c07684">setRotationFromAngleAboutZ</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>cosAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>sinAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a class="anchor" id="a13e4dcab37f729839b79abf5a5e77840"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutNonUnitVector" ref="a13e4dcab37f729839b79abf5a5e77840" args="(RealP angle, const Vec3P &amp;nonUnitVector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a13e4dcab37f729839b79abf5a5e77840">setRotationFromAngleAboutNonUnitVector</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>nonUnitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation of an angle (in radians) about an arbitrary vector. </p>

</div>
</div>
<a class="anchor" id="a69dbe7f3f47a4b0c6d7be8650d95049c"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromAngleAboutUnitVector" ref="a69dbe7f3f47a4b0c6d7be8650d95049c" args="(RealP angle, const UnitVec3P &amp;unitVector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a69dbe7f3f47a4b0c6d7be8650d95049c">setRotationFromAngleAboutUnitVector</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>unitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a right-handed rotation of an angle (in radians) about an arbitrary vector. </p>

</div>
</div>
<a class="anchor" id="afc54e75b189a41cf6b0e9d23458eae32"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromTwoAnglesTwoAxes" ref="afc54e75b189a41cf6b0e9d23458eae32" args="(BodyOrSpaceType bodyOrSpace, RealP angle1, const CoordinateAxis &amp;axis1, RealP angle2, const CoordinateAxis &amp;axis2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#afc54e75b189a41cf6b0e9d23458eae32">setRotationFromTwoAnglesTwoAxes</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians) </p>

</div>
</div>
<a class="anchor" id="ad19a5140a685462e498d6d5c2c42c8c4"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromThreeAnglesThreeAxes" ref="ad19a5140a685462e498d6d5c2c42c8c4" args="(BodyOrSpaceType bodyOrSpace, RealP angle1, const CoordinateAxis &amp;axis1, RealP angle2, const CoordinateAxis &amp;axis2, RealP angle3, const CoordinateAxis &amp;axis3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ad19a5140a685462e498d6d5c2c42c8c4">setRotationFromThreeAnglesThreeAxes</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>angle3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to a three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians) </p>

</div>
</div>
<a class="anchor" id="af44ae0c01f7118c690a0c47cbf44e9a7"></a><!-- doxytag: member="SimTK::Rotation_::setRotationToBodyFixedXY" ref="af44ae0c01f7118c690a0c47cbf44e9a7" args="(const Vec2P &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#af44ae0c01f7118c690a0c47cbf44e9a7">setRotationToBodyFixedXY</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> to represent a rotation characterized by subsequent rotations of: +v[0] about the body frame's X axis, followed by a rotation of +v[1] about the body frame's NEW Y axis. </p>
<p>See Kane, Spacecraft Dynamics, pg. 423, body-three: 1-2-3. </p>

</div>
</div>
<a class="anchor" id="a1b5b9946341290a869fdf36263c6e901"></a><!-- doxytag: member="SimTK::Rotation_::setRotationToBodyFixedXYZ" ref="a1b5b9946341290a869fdf36263c6e901" args="(const Vec3P &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a1b5b9946341290a869fdf36263c6e901">setRotationToBodyFixedXYZ</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> to represent a rotation characterized by subsequent rotations of: +v[0] about the body frame's X axis, followed by a rotation of +v[1] about the body frame's NEW Y axis, followed by a rotation of +v[2] about the body frame's NEW Z axis. </p>
<p>See Kane, Spacecraft Dynamics, pg. 423, body-three: 1-2-3. </p>

</div>
</div>
<a class="anchor" id="aed39e831fc2c774c769b4afb72830874"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromQuaternion" ref="aed39e831fc2c774c769b4afb72830874" args="(const QuaternionP &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aed39e831fc2c774c769b4afb72830874">setRotationFromQuaternion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Quaternion__.html">QuaternionP</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method for creating a rotation matrix from a quaternion. </p>

</div>
</div>
<a class="anchor" id="acf320049f0aa881075905d781eee032f"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromApproximateMat33" ref="acf320049f0aa881075905d781eee032f" args="(const Mat33P &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#acf320049f0aa881075905d781eee032f">setRotationFromApproximateMat33</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> object to an (hopefully nearby) orthogonal rotation matrix from a generic Mat33P. </p>

</div>
</div>
<a class="anchor" id="a1716a6bd3d8ae76bbd59b139edcc2e2d"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromOneAxis" ref="a1716a6bd3d8ae76bbd59b139edcc2e2d" args="(const UnitVec3P &amp;uvec, const CoordinateAxis axis)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a1716a6bd3d8ae76bbd59b139edcc2e2d">setRotationFromOneAxis</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate R_AB by knowing one of B's unit vector expressed in A. </p>
<p>Note: The other vectors are perpendicular (but somewhat arbitrarily so). </p>

</div>
</div>
<a class="anchor" id="a7efe475b1e8a00f0628a74e660e84dfa"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromTwoAxes" ref="a7efe475b1e8a00f0628a74e660e84dfa" args="(const UnitVec3P &amp;uveci, const CoordinateAxis &amp;axisi, const Vec3P &amp;vecjApprox, const CoordinateAxis &amp;axisjApprox)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a7efe475b1e8a00f0628a74e660e84dfa">setRotationFromTwoAxes</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uveci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axisi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>vecjApprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axisjApprox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz) expressed in A and a vector v (also expressed in A) that is approximately in the desired direction for a second one of B's unit vectors, u2 (!= u1). </p>
<p>If v is not perpendicular to u1, no worries - we'll find a direction for u2 that is perpendicular to u1 and comes closest to v. The third vector u3 is +/- u1 X u2, as appropriate for a right-handed rotation matrix. </p>

</div>
</div>
<a class="anchor" id="ac24f6d58ac08a8aa027bd04dc294b4d5"></a><!-- doxytag: member="SimTK::Rotation_::convertOneAxisRotationToOneAngle" ref="ac24f6d58ac08a8aa027bd04dc294b4d5" args="(const CoordinateAxis &amp;axis1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ac24f6d58ac08a8aa027bd04dc294b4d5">convertOneAxisRotationToOneAngle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts rotation matrix to a single orientation angle. </p>
<p>Note: The result is most meaningful if the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix is one that can be produced by such a sequence. </p>

</div>
</div>
<a class="anchor" id="a0670932d36daa77ab1bec1dfc9a2dbd9"></a><!-- doxytag: member="SimTK::Rotation_::convertTwoAxesRotationToTwoAngles" ref="a0670932d36daa77ab1bec1dfc9a2dbd9" args="(BodyOrSpaceType bodyOrSpace, const CoordinateAxis &amp;axis1, const CoordinateAxis &amp;axis2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a0670932d36daa77ab1bec1dfc9a2dbd9">convertTwoAxesRotationToTwoAngles</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts rotation matrix to two orientation angles. </p>
<p>Note: The result is most meaningful if the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix is one that can be produced by such a sequence. </p>

</div>
</div>
<a class="anchor" id="a8fedf3e4f467b4c46cb3d75c72d1cbe7"></a><!-- doxytag: member="SimTK::Rotation_::convertThreeAxesRotationToThreeAngles" ref="a8fedf3e4f467b4c46cb3d75c72d1cbe7" args="(BodyOrSpaceType bodyOrSpace, const CoordinateAxis &amp;axis1, const CoordinateAxis &amp;axis2, const CoordinateAxis &amp;axis3) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a8fedf3e4f467b4c46cb3d75c72d1cbe7">convertThreeAxesRotationToThreeAngles</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts rotation matrix to three orientation angles. </p>
<p>Note: The result is most meaningful if the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix is one that can be produced by such a sequence. </p>

</div>
</div>
<a class="anchor" id="aeb0dbfbe9692728363f19291a36582fd"></a><!-- doxytag: member="SimTK::Rotation_::convertRotationToQuaternion" ref="aeb0dbfbe9692728363f19291a36582fd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Quaternion__.html">QuaternionP</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aeb0dbfbe9692728363f19291a36582fd">convertRotationToQuaternion</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts rotation matrix to a quaternion. </p>

</div>
</div>
<a class="anchor" id="af32d025ec1a522a1f97a420bdc1c542f"></a><!-- doxytag: member="SimTK::Rotation_::convertRotationToAngleAxis" ref="af32d025ec1a522a1f97a420bdc1c542f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#af32d025ec1a522a1f97a420bdc1c542f">convertRotationToAngleAxis</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts rotation matrix to angle-axis form. </p>

</div>
</div>
<a class="anchor" id="ae8fde87c8bfcd30533f47cbaa96d2fc9"></a><!-- doxytag: member="SimTK::Rotation_::convertRotationToBodyFixedXY" ref="ae8fde87c8bfcd30533f47cbaa96d2fc9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ae8fde87c8bfcd30533f47cbaa96d2fc9">convertRotationToBodyFixedXY</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenient special case of <a class="el" href="classSimTK_1_1Rotation__.html#a0670932d36daa77ab1bec1dfc9a2dbd9" title="Converts rotation matrix to two orientation angles.">convertTwoAxesRotationToTwoAngles()</a>. </p>

</div>
</div>
<a class="anchor" id="a852ebf23b0a5075f89079184eea129ef"></a><!-- doxytag: member="SimTK::Rotation_::convertRotationToBodyFixedXYZ" ref="a852ebf23b0a5075f89079184eea129ef" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a852ebf23b0a5075f89079184eea129ef">convertRotationToBodyFixedXYZ</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenient special case of <a class="el" href="classSimTK_1_1Rotation__.html#a8fedf3e4f467b4c46cb3d75c72d1cbe7" title="Converts rotation matrix to three orientation angles.">convertThreeAxesRotationToThreeAngles()</a>. </p>

</div>
</div>
<a class="anchor" id="a9408d46027f2faf546417095f9da84d8"></a><!-- doxytag: member="SimTK::Rotation_::reexpressSymMat33" ref="a9408d46027f2faf546417095f9da84d8" args="(const SymMat33P &amp;S_BB) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a9408d46027f2faf546417095f9da84d8">reexpressSymMat33</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>S_BB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform an efficient transform of a symmetric matrix that must be re-expressed with a multiply from both left and right, such as an inertia matrix. </p>
<p>Details: assuming this Rotation is R_AB, and given a symmetric dyadic matrix S_BB expressed in B, we can reexpress it in A using S_AA=R_AB*S_BB*R_BA. The matrix should be one that is formed as products of vectors expressed in A, such as inertia, gyration or covariance matrices. This can be done efficiently exploiting properties of R (orthogonal) and S (symmetric). Total cost is 57 flops. </p>

</div>
</div>
<a class="anchor" id="a44abc241c4d901a0a784a94d8ffa40a6"></a><!-- doxytag: member="SimTK::Rotation_::isSameRotationToWithinAngle" ref="a44abc241c4d901a0a784a94d8ffa40a6" args="(const Rotation_ &amp;R, RealP okPointingAngleErrorRads) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a44abc241c4d901a0a784a94d8ffa40a6">isSameRotationToWithinAngle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>okPointingAngleErrorRads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if "this" Rotation is nearly identical to "R" within a specified pointing angle error. </p>

</div>
</div>
<a class="anchor" id="ac725bd972c9c54809b4b63880cb84fd2"></a><!-- doxytag: member="SimTK::Rotation_::isSameRotationToWithinAngleOfMachinePrecision" ref="ac725bd972c9c54809b4b63880cb84fd2" args="(const Rotation_ &amp;R) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ac725bd972c9c54809b4b63880cb84fd2">isSameRotationToWithinAngleOfMachinePrecision</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if "this" Rotation is nearly identical to "R" within a specified pointing angle error. </p>

</div>
</div>
<a class="anchor" id="a5f79467f7a137c87f11fd50dad4f5f64"></a><!-- doxytag: member="SimTK::Rotation_::getMaxAbsDifferenceInRotationElements" ref="a5f79467f7a137c87f11fd50dad4f5f64" args="(const Rotation_ &amp;R) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a5f79467f7a137c87f11fd50dad4f5f64">getMaxAbsDifferenceInRotationElements</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa137c322dd6f46282e335365ae1a24ce"></a><!-- doxytag: member="SimTK::Rotation_::areAllRotationElementsSameToEpsilon" ref="aa137c322dd6f46282e335365ae1a24ce" args="(const Rotation_ &amp;R, RealP epsilon) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aa137c322dd6f46282e335365ae1a24ce">areAllRotationElementsSameToEpsilon</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1db1f3a440a79ad2e5b403913f44042"></a><!-- doxytag: member="SimTK::Rotation_::areAllRotationElementsSameToMachinePrecision" ref="ac1db1f3a440a79ad2e5b403913f44042" args="(const Rotation_ &amp;R) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ac1db1f3a440a79ad2e5b403913f44042">areAllRotationElementsSameToMachinePrecision</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ac773d1fe4e964aebf5c62c51f1cb1a"></a><!-- doxytag: member="SimTK::Rotation_::operator=" ref="a4ac773d1fe4e964aebf5c62c51f1cb1a" args="(const InverseRotation_&lt; P &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like copy assignment but for inverse rotation. </p>

</div>
</div>
<a class="anchor" id="a29dabf3d119461ff356a6536ff2859d9"></a><!-- doxytag: member="SimTK::Rotation_::invert" ref="a29dabf3d119461ff356a6536ff2859d9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a29dabf3d119461ff356a6536ff2859d9">invert</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert from <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> to <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a> (no cost). Overrides base class <a class="el" href="classSimTK_1_1Rotation__.html#a29dabf3d119461ff356a6536ff2859d9" title="Convert from Rotation_ to InverseRotation_ (no cost). Overrides base class invert().">invert()</a>. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#ad5d31751658e1c888e0a703acfca4923">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abcf61a10b96a4320c991e55caa582386"></a><!-- doxytag: member="SimTK::Rotation_::updInvert" ref="abcf61a10b96a4320c991e55caa582386" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#abcf61a10b96a4320c991e55caa582386">updInvert</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert from <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> to writable <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a> (no cost). </p>

</div>
</div>
<a class="anchor" id="a5440d77a9933a385260197de908d8798"></a><!-- doxytag: member="SimTK::Rotation_::transpose" ref="a5440d77a9933a385260197de908d8798" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a5440d77a9933a385260197de908d8798">transpose</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transpose, and transpose operators. </p>
<p>For an orthogonal matrix like this one, transpose is the same thing as inversion. These override the base class transpose methods. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#ad35d793f74658269d3ec07375f3ed9ff">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a94968ae3dab970ba1c9ef24e58989673"></a><!-- doxytag: member="SimTK::Rotation_::operator~" ref="a94968ae3dab970ba1c9ef24e58989673" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a94968ae3dab970ba1c9ef24e58989673">operator~</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transpose, and transpose operators. </p>
<p>For an orthogonal matrix like this one, transpose is the same thing as inversion. These override the base class transpose methods. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#ad34aa4ffc0a01399b96ddb12aa19faa8">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a83d8ca5d3b3edd6630b5fb7a0a577d72"></a><!-- doxytag: member="SimTK::Rotation_::updTranspose" ref="a83d8ca5d3b3edd6630b5fb7a0a577d72" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a83d8ca5d3b3edd6630b5fb7a0a577d72">updTranspose</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transpose, and transpose operators. </p>
<p>For an orthogonal matrix like this one, transpose is the same thing as inversion. These override the base class transpose methods. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#a7563cd32d9122374cc23dee6abee8f53">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aec15e73cf4dbcdc7e1c6ac90f68fdef3"></a><!-- doxytag: member="SimTK::Rotation_::operator~" ref="aec15e73cf4dbcdc7e1c6ac90f68fdef3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a94968ae3dab970ba1c9ef24e58989673">operator~</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transpose, and transpose operators. </p>
<p>For an orthogonal matrix like this one, transpose is the same thing as inversion. These override the base class transpose methods. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#a5e990f48f3610f38bc07d392c74cc80f">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a26169557db013c2a8779098d00d5c846"></a><!-- doxytag: member="SimTK::Rotation_::operator*=" ref="a26169557db013c2a8779098d00d5c846" args="(const Rotation_&lt; P &gt; &amp;R)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place composition of Rotation matrices. </p>

</div>
</div>
<a class="anchor" id="ab38257532c21876c8629b224f0431080"></a><!-- doxytag: member="SimTK::Rotation_::operator/=" ref="ab38257532c21876c8629b224f0431080" args="(const Rotation_&lt; P &gt; &amp;R)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place composition of Rotation matrices. </p>

</div>
</div>
<a class="anchor" id="a7fa2ee262d79bf91ba2465bdbecb40c2"></a><!-- doxytag: member="SimTK::Rotation_::operator*=" ref="a7fa2ee262d79bf91ba2465bdbecb40c2" args="(const InverseRotation_&lt; P &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place composition of Rotation matrices. </p>

</div>
</div>
<a class="anchor" id="a94079169da0047a42fe96411f36f9f42"></a><!-- doxytag: member="SimTK::Rotation_::operator/=" ref="a94079169da0047a42fe96411f36f9f42" args="(const InverseRotation_&lt; P &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place composition of Rotation matrices. </p>

</div>
</div>
<a class="anchor" id="a97e3dd684128236abdd4729ddffb208e"></a><!-- doxytag: member="SimTK::Rotation_::asMat33" ref="a97e3dd684128236abdd4729ddffb208e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a97e3dd684128236abdd4729ddffb208e">asMat33</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conversion from Rotation to its base class Mat33. </p>
<p>Note: asMat33 is more efficient than <a class="el" href="classSimTK_1_1Rotation__.html#a02a8b19b9c7dab9b72762bd339cdb6a1" title="Conversion from Rotation to its base class Mat33.">toMat33()</a> (no copy), but you have to know the internal layout. </p>

</div>
</div>
<a class="anchor" id="a02a8b19b9c7dab9b72762bd339cdb6a1"></a><!-- doxytag: member="SimTK::Rotation_::toMat33" ref="a02a8b19b9c7dab9b72762bd339cdb6a1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a02a8b19b9c7dab9b72762bd339cdb6a1">toMat33</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conversion from Rotation to its base class Mat33. </p>
<p>Note: asMat33 is more efficient than <a class="el" href="classSimTK_1_1Rotation__.html#a02a8b19b9c7dab9b72762bd339cdb6a1" title="Conversion from Rotation to its base class Mat33.">toMat33()</a> (no copy), but you have to know the internal layout. </p>

</div>
</div>
<a class="anchor" id="aeaccae1010b6c9cc9427d2a39b686c76"></a><!-- doxytag: member="SimTK::Rotation_::row" ref="aeaccae1010b6c9cc9427d2a39b686c76" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aeaccae1010b6c9cc9427d2a39b686c76">row</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#aeb0d5caaad53a170858643d6e8f9be40">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a914bb4f7f7e7c1e82aa7cc095e6704f2"></a><!-- doxytag: member="SimTK::Rotation_::col" ref="a914bb4f7f7e7c1e82aa7cc095e6704f2" args="(int j) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a914bb4f7f7e7c1e82aa7cc095e6704f2">col</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#a87d916168dd45ec3cb7abf0fa5589465">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af36bd122d1e1b06b05d6f6a518f9bc52"></a><!-- doxytag: member="SimTK::Rotation_::x" ref="af36bd122d1e1b06b05d6f6a518f9bc52" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#af36bd122d1e1b06b05d6f6a518f9bc52">x</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ea9cb2cb1301a551be2f575ec5dc39c"></a><!-- doxytag: member="SimTK::Rotation_::y" ref="a5ea9cb2cb1301a551be2f575ec5dc39c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a5ea9cb2cb1301a551be2f575ec5dc39c">y</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a635c34523b636e2b0e767cbcae7185a5"></a><!-- doxytag: member="SimTK::Rotation_::z" ref="a635c34523b636e2b0e767cbcae7185a5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a635c34523b636e2b0e767cbcae7185a5">z</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84f0d8ba224b1b812be0f354d5d407be"></a><!-- doxytag: member="SimTK::Rotation_::operator[]" ref="a84f0d8ba224b1b812be0f354d5d407be" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#afbad570edd00e7fd82f6fe59c68fba20">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a64e2dae5549468bf72dfa6dfe83f1555"></a><!-- doxytag: member="SimTK::Rotation_::operator()" ref="a64e2dae5549468bf72dfa6dfe83f1555" args="(int j) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classSimTK_1_1Mat.html#a2f281b88c90d1f07c1ec882ee6d2792f">SimTK::Mat&lt; 3, 3, P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a34a70e677a952560b2ab8d972ed79801"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromMat33TrustMe" ref="a34a70e677a952560b2ab8d972ed79801" args="(const Mat33P &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a34a70e677a952560b2ab8d972ed79801">setRotationFromMat33TrustMe</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix directly - but you had better know what you are doing! </p>

</div>
</div>
<a class="anchor" id="a9913668d30b526d87c63b175ccef9c56"></a><!-- doxytag: member="SimTK::Rotation_::setRotationColFromUnitVecTrustMe" ref="a9913668d30b526d87c63b175ccef9c56" args="(int colj, const UnitVec3P &amp;uvecj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a9913668d30b526d87c63b175ccef9c56">setRotationColFromUnitVecTrustMe</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uvecj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix directly - but you had better know what you are doing! </p>

</div>
</div>
<a class="anchor" id="a38115244428f8fc0f4411dd092ee5fe4"></a><!-- doxytag: member="SimTK::Rotation_::setRotationFromUnitVecsTrustMe" ref="a38115244428f8fc0f4411dd092ee5fe4" args="(const UnitVec3P &amp;colA, const UnitVec3P &amp;colB, const UnitVec3P &amp;colC)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a38115244428f8fc0f4411dd092ee5fe4">setRotationFromUnitVecsTrustMe</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>colA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>colB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>colC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix is a legitimate 3x3 array associated wi...">Rotation_</a> matrix directly - but you had better know what you are doing! </p>

</div>
</div>
<a class="anchor" id="a6d2d3b70084a3a474bf2c8ac1f598bf6"></a><!-- doxytag: member="SimTK::Rotation_::setRotationToBodyFixedXYZ" ref="a6d2d3b70084a3a474bf2c8ac1f598bf6" args="(const Vec3P &amp;c, const Vec3P &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a1b5b9946341290a869fdf36263c6e901">setRotationToBodyFixedXYZ</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given cosines and sines (in that order) of three angles, set this Rotation matrix to the body-fixed 1-2-3 sequence of those angles. </p>
<p>Cost is 18 flops. </p>

</div>
</div>
<a class="anchor" id="ada7be536a78529d455a292a04fc267bf"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelToBodyFixed321Dot" ref="ada7be536a78529d455a292a04fc267bf" args="(const Vec3P &amp;q, const Vec3P &amp;w_PB_B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ada7be536a78529d455a292a04fc267bf">convertAngVelToBodyFixed321Dot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given Euler angles forming a body-fixed 3-2-1 sequence, and the relative angular velocity vector of B in the parent frame, *BUT EXPRESSED IN THE BODY FRAME*, return the Euler angle derivatives. </p>
<p>You are dead if q[1] gets near 90 degrees! See Kane's Spacecraft Dynamics, page 428, body-three: 3-2-1. </p>

</div>
</div>
<a class="anchor" id="a0b2274baac7bc6e82343040f1850f59c"></a><!-- doxytag: member="SimTK::Rotation_::convertBodyFixed321DotToAngVel" ref="a0b2274baac7bc6e82343040f1850f59c" args="(const Vec3P &amp;q, const Vec3P &amp;qd)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a0b2274baac7bc6e82343040f1850f59c">convertBodyFixed321DotToAngVel</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse of the above routine. </p>
<p>Returned angular velocity is B in P, expressed in *B*: w_PB_B. </p>

</div>
</div>
<a class="anchor" id="a41b70da72a012a4e248150759ae09a0b"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelDotToBodyFixed321DotDot" ref="a41b70da72a012a4e248150759ae09a0b" args="(const Vec3P &amp;q, const Vec3P &amp;w_PB_B, const Vec3P &amp;wdot_PB_B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a41b70da72a012a4e248150759ae09a0b">convertAngVelDotToBodyFixed321DotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>wdot_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3eb22f98f2a9088cf1012a5559548e3a"></a><!-- doxytag: member="SimTK::Rotation_::calcNForBodyXYZInBodyFrame" ref="a3eb22f98f2a9088cf1012a5559548e3a" args="(const Vec3P &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a">calcNForBodyXYZInBodyFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix such that qdot=N_B(q)*w_PB_B where w_PB_B is the angular velocity of B in P EXPRESSED IN *B*!!! Note that N_B=N_P*R_PB. </p>
<p>This matrix will be singular if Y (q[1]) gets near 90 degrees! </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method.</dd></dl>
<p>Cost: about 100 flops for sin/cos plus 12 to calculate N_B. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>Kane's Spacecraft Dynamics, page 427, body-three: 1-2-3. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaa54243d974e2c0a8bb80c201343ad4"></a><!-- doxytag: member="SimTK::Rotation_::calcNForBodyXYZInBodyFrame" ref="aaaa54243d974e2c0a8bb80c201343ad4" args="(const Vec3P &amp;cq, const Vec3P &amp;sq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a">calcNForBodyXYZInBodyFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is one divide plus 6 flops, say 12 flops. </p>

</div>
</div>
<a class="anchor" id="a0127cac78bdb1aea48a1b8294d2f13a5"></a><!-- doxytag: member="SimTK::Rotation_::calcNForBodyXYZInParentFrame" ref="a0127cac78bdb1aea48a1b8294d2f13a5" args="(const Vec3P &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5">calcNForBodyXYZInParentFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N matrix such that qdot=N_P(q)*w_PB where w_PB is the angular velocity of B in P expressed in P (not the convention that Kane uses, where angular velocities are expressed in the outboard body B). </p>
<p>Note that N_P = N_B*~R_PB. This matrix will be singular if Y (q[1]) gets near 90 degrees!</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method.</dd></dl>
<p>Cost: about 100 flops for sin/cos plus 12 to calculate N_P. </p>

</div>
</div>
<a class="anchor" id="aabd585adb5a86dc06adc011d46c4d2a4"></a><!-- doxytag: member="SimTK::Rotation_::calcNForBodyXYZInParentFrame" ref="aabd585adb5a86dc06adc011d46c4d2a4" args="(const Vec3P &amp;cq, const Vec3P &amp;sq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5">calcNForBodyXYZInParentFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5" title="Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N m...">calcNForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[0] and q[1]; q[2] does not matter so you don't have to fill in the 3rd element of cq and sq. Cost is one divide plus 6 flops, say 12 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>Paul Mitiguy </dd></dl>

</div>
</div>
<a class="anchor" id="a3d8d055de40c8993a4bb9bb2d86c784a"></a><!-- doxytag: member="SimTK::Rotation_::multiplyByBodyXYZ_N_P" ref="a3d8d055de40c8993a4bb9bb2d86c784a" args="(const Vec2P &amp;cosxy, const Vec2P &amp;sinxy, RealP oocosy, const Vec3P &amp;w_PB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a">multiplyByBodyXYZ_N_P</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>oocosy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular velocity of child in parent is expected to be expressed in the parent. </p>
<p>Here we assume you have previously calculated sincos(qx), sincos(qy), and 1/cos(qy). Cost is 10 flops, faster even than the 15 it would take if you had saved N_P and then formed the N_P*w_PB product explicitly. </p>

</div>
</div>
<a class="anchor" id="a776789cb0d7ba32361b1b43813591754"></a><!-- doxytag: member="SimTK::Rotation_::multiplyByBodyXYZ_NT_P" ref="a776789cb0d7ba32361b1b43813591754" args="(const Vec2P &amp;cosxy, const Vec2P &amp;sinxy, RealP oocosy, const Vec3P &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a776789cb0d7ba32361b1b43813591754">multiplyByBodyXYZ_NT_P</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>oocosy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the fastest way to form the product v_P=~N_P*q=~(~q*N_P); see the untransposed method <a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a" title="This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular...">multiplyByBodyXYZ_N_P()</a> for information. </p>
<p>Cost is 9 flops. </p>

</div>
</div>
<a class="anchor" id="ad8b111f6521a2001a2c2dbc00414d5ad"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelInParentToBodyXYZDot" ref="ad8b111f6521a2001a2c2dbc00414d5ad" args="(const Vec2P &amp;cosxy, const Vec2P &amp;sinxy, RealP oocosy, const Vec3P &amp;w_PB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ad8b111f6521a2001a2c2dbc00414d5ad">convertAngVelInParentToBodyXYZDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>oocosy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate first time derivative qdot of body-fixed XYZ Euler angles q given sines and cosines of the Euler angles and the angular velocity w_PB of child B in parent P, expressed in P. </p>
<p>Cost is 10 flops.</p>
<p>Theory: calculate qdot=N_P(q)*w_PB using <a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a" title="This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular...">multiplyByBodyXYZ_N_P()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a" title="This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular...">multiplyByBodyXYZ_N_P()</a> </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cosxy</td><td>cos(qx), cos(qy) </td></tr>
    <tr><td class="paramname">sinxy</td><td>sin(qx), sin(qy) </td></tr>
    <tr><td class="paramname">oocosy</td><td>1/cos(qy) </td></tr>
    <tr><td class="paramname">w_PB</td><td>angular velocity of B in P, exp. in P </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5ee4bdfde750e6cb198494b1b522b20"></a><!-- doxytag: member="SimTK::Rotation_::convertAngAccInParentToBodyXYZDotDot" ref="aa5ee4bdfde750e6cb198494b1b522b20" args="(const Vec2P &amp;cosxy, const Vec2P &amp;sinxy, RealP oocosy, const Vec3P &amp;qdot, const Vec3P &amp;b_PB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aa5ee4bdfde750e6cb198494b1b522b20">convertAngAccInParentToBodyXYZDotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>oocosy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>b_PB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate second time derivative qdotdot of body-fixed XYZ Euler angles q given sines and cosines of the Euler angles, the first derivative qdot and the angular acceleration b_PB of child B in parent P, expressed in P. </p>
<p>Cost is 22 flops.</p>
<p>Theory: we have qdot=N_P*w_PB, which we differentiate in P to get qdotdot=N_P*b_PB + NDot_P*w_PB. Note that NDot_P=NDot_P(q,qdot) and w_PB=NInv_P*qdot (because N_P is invertible). We can then rewrite qdotdot=N_P*b_PB + NDot_P*(NInv_P*qdot) which can be calculated very efficiently. The second term is just an acceleration remainder term quadratic in qdot. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cosxy</td><td>cos(qx), cos(qy) </td></tr>
    <tr><td class="paramname">sinxy</td><td>sin(qx), sin(qy) </td></tr>
    <tr><td class="paramname">oocosy</td><td>1/cos(qy) </td></tr>
    <tr><td class="paramname">qdot</td><td>previously calculated BodyXYZDot </td></tr>
    <tr><td class="paramname">b_PB</td><td>angular acceleration, a.k.a. wdot_PB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0edcb1b005f9a4980302c60cec1840d"></a><!-- doxytag: member="SimTK::Rotation_::multiplyByBodyXYZ_NInv_P" ref="ad0edcb1b005f9a4980302c60cec1840d" args="(const Vec2P &amp;cosxy, const Vec2P &amp;sinxy, const Vec3P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ad0edcb1b005f9a4980302c60cec1840d">multiplyByBodyXYZ_NInv_P</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fastest way to form the product w_PB=NInv_P*qdot. </p>
<p>This is never singular. Cost is 9 flops. </p>

</div>
</div>
<a class="anchor" id="ae19740559fc48c4651696e8e1d4ff6d8"></a><!-- doxytag: member="SimTK::Rotation_::multiplyByBodyXYZ_NInvT_P" ref="ae19740559fc48c4651696e8e1d4ff6d8" args="(const Vec2P &amp;cosxy, const Vec2P &amp;sinxy, const Vec3P &amp;v_P)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ae19740559fc48c4651696e8e1d4ff6d8">multiplyByBodyXYZ_NInvT_P</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>v_P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fastest way to form the product q=~NInv_P*v_P=~(~v_P*NInv_P). </p>
<p>This is never singular. Cost is 10 flops. </p>

</div>
</div>
<a class="anchor" id="a57cc6b4aa8b35bb60f885bc8c07927ed"></a><!-- doxytag: member="SimTK::Rotation_::calcNDotForBodyXYZInBodyFrame" ref="a57cc6b4aa8b35bb60f885bc8c07927ed" args="(const Vec3P &amp;q, const Vec3P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a57cc6b4aa8b35bb60f885bc8c07927ed">calcNDotForBodyXYZInBodyFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot, return the block of the NDot matrix such that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of B in P EXPRESSED IN *B*!!! This matrix will be singular if Y (q[1]) gets near 90 degrees! See <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a> for the matrix we're differentiating here. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="af1a07a41343d026e5f95c7072aa180b1"></a><!-- doxytag: member="SimTK::Rotation_::calcNDotForBodyXYZInBodyFrame" ref="af1a07a41343d026e5f95c7072aa180b1" args="(const Vec3P &amp;cq, const Vec3P &amp;sq, const Vec3P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a57cc6b4aa8b35bb60f885bc8c07927ed">calcNDotForBodyXYZInBodyFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a57cc6b4aa8b35bb60f885bc8c07927ed" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot...">calcNDotForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is one divide plus 21 flops. </p>

</div>
</div>
<a class="anchor" id="a713ce2d2d7aa5e3ba6bc4107f715bca2"></a><!-- doxytag: member="SimTK::Rotation_::calcNDotForBodyXYZInParentFrame" ref="a713ce2d2d7aa5e3ba6bc4107f715bca2" args="(const Vec3P &amp;q, const Vec3P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a713ce2d2d7aa5e3ba6bc4107f715bca2">calcNDotForBodyXYZInParentFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot, return the block of the NDot matrix such that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of B in P expressed in P. </p>
<p>This matrix will be singular if Y (q[1]) gets near 90 degrees! See <a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5" title="Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N m...">calcNForBodyXYZInParentFrame()</a> for the matrix we're differentiating here. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a731e89578e363e9c42f998b542682a35"></a><!-- doxytag: member="SimTK::Rotation_::calcNDotForBodyXYZInParentFrame" ref="a731e89578e363e9c42f998b542682a35" args="(const Vec2P &amp;cq, const Vec2P &amp;sq, RealP ooc1, const Vec3P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a713ce2d2d7aa5e3ba6bc4107f715bca2">calcNDotForBodyXYZInParentFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>ooc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a713ce2d2d7aa5e3ba6bc4107f715bca2" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot...">calcNDotForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[0] and q[1]. Cost is 21 flops. </p>

</div>
</div>
<a class="anchor" id="aba5b6c3e33f68fc8105d2f2099969753"></a><!-- doxytag: member="SimTK::Rotation_::calcNInvForBodyXYZInBodyFrame" ref="aba5b6c3e33f68fc8105d2f2099969753" args="(const Vec3P &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aba5b6c3e33f68fc8105d2f2099969753">calcNInvForBodyXYZInBodyFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse of routine <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a>. </p>
<p>Return the inverse NInv_B of the N_B block computed above, such that w_PB_B=NInv_B(q)*qdot where w_PB_B is the angular velocity of B in P EXPRESSED IN *B*!!! (Kane's convention.) Note that NInv_B=~R_PB*NInv_P. This matrix is never singular. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a05421fe60aadcdc2c5b9a02747568a73"></a><!-- doxytag: member="SimTK::Rotation_::calcNInvForBodyXYZInBodyFrame" ref="a05421fe60aadcdc2c5b9a02747568a73" args="(const Vec3P &amp;cq, const Vec3P &amp;sq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aba5b6c3e33f68fc8105d2f2099969753">calcNInvForBodyXYZInBodyFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#aba5b6c3e33f68fc8105d2f2099969753" title="Inverse of routine calcNForBodyXYZInBodyFrame().">calcNInvForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is 3 flops. </p>

</div>
</div>
<a class="anchor" id="a37fc3fe5bd8a98217aafeb5a6639ccbc"></a><!-- doxytag: member="SimTK::Rotation_::calcNInvForBodyXYZInParentFrame" ref="a37fc3fe5bd8a98217aafeb5a6639ccbc" args="(const Vec3P &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a37fc3fe5bd8a98217aafeb5a6639ccbc">calcNInvForBodyXYZInParentFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse of the above routine. </p>
<p>Return the inverse NInv_P of the N_P block computed above, such that w_PB=NInv_P(q)*qdot where w_PB is the angular velocity of B in P (expressed in P). Note that NInv_P=R_PB*NInv_B. This matrix is never singular. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a020a2169bc07b8e28414b75892986c9f"></a><!-- doxytag: member="SimTK::Rotation_::calcNInvForBodyXYZInParentFrame" ref="a020a2169bc07b8e28414b75892986c9f" args="(const Vec3P &amp;cq, const Vec3P &amp;sq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a37fc3fe5bd8a98217aafeb5a6639ccbc">calcNInvForBodyXYZInParentFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a37fc3fe5bd8a98217aafeb5a6639ccbc" title="Inverse of the above routine.">calcNInvForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[0] and q[1]; q[2] does not matter so you don't have to fill in the 3rd element of cq and sq. Cost is 3 flops. </p>

</div>
</div>
<a class="anchor" id="ae87f86eb9a0b8dff3202c35e39f1b16d"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelInBodyFrameToBodyXYZDot" ref="ae87f86eb9a0b8dff3202c35e39f1b16d" args="(const Vec3P &amp;q, const Vec3P &amp;w_PB_B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ae87f86eb9a0b8dff3202c35e39f1b16d">convertAngVelInBodyFrameToBodyXYZDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the relative angular velocity vector w_PB_B of B in the parent frame, <em>BUT EXPRESSED IN THE BODY FRAME</em>, return the Euler angle derivatives. </p>
<p>You are dead if q[1] gets near 90 degrees! </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Kane's Spacecraft Dynamics, page 427, body-three: 1-2-3. </dd></dl>

</div>
</div>
<a class="anchor" id="aa59271d0544a807b0d43617485365efd"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelInBodyFrameToBodyXYZDot" ref="aa59271d0544a807b0d43617485365efd" args="(const Vec3P &amp;cq, const Vec3P &amp;sq, const Vec3P &amp;w_PB_B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ae87f86eb9a0b8dff3202c35e39f1b16d">convertAngVelInBodyFrameToBodyXYZDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#ae87f86eb9a0b8dff3202c35e39f1b16d" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the relative angular velocity vecto...">convertAngVelInBodyFrameToBodyXYZDot()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is XXX. </p>

</div>
</div>
<a class="anchor" id="afc7286af6f32e76ddc0b5f90f7efd22e"></a><!-- doxytag: member="SimTK::Rotation_::convertBodyXYZDotToAngVelInBodyFrame" ref="afc7286af6f32e76ddc0b5f90f7efd22e" args="(const Vec3P &amp;q, const Vec3P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#afc7286af6f32e76ddc0b5f90f7efd22e">convertBodyXYZDotToAngVelInBodyFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse of the above routine. </p>
<p>Returned angular velocity is B in P, expressed in *B*: w_PB_B. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="aaed9d79a18b05275c469d18d58413ca5"></a><!-- doxytag: member="SimTK::Rotation_::convertBodyXYZDotToAngVelInBodyFrame" ref="aaed9d79a18b05275c469d18d58413ca5" args="(const Vec3P &amp;cq, const Vec3P &amp;sq, const Vec3P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#afc7286af6f32e76ddc0b5f90f7efd22e">convertBodyXYZDotToAngVelInBodyFrame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#afc7286af6f32e76ddc0b5f90f7efd22e" title="Inverse of the above routine.">convertBodyXYZDotToAngVelInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is XXX flops. </p>

</div>
</div>
<a class="anchor" id="aed514d5990532404a82da26793049900"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelDotInBodyFrameToBodyXYZDotDot" ref="aed514d5990532404a82da26793049900" args="(const Vec3P &amp;q, const Vec3P &amp;w_PB_B, const Vec3P &amp;wdot_PB_B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aed514d5990532404a82da26793049900">convertAngVelDotInBodyFrameToBodyXYZDotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>wdot_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: sherm: is this right? Warning: everything is measured in the PARENT* frame, but has to be expressed in the *BODY* frame. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ae5a0d854e698521bde92dfe17b84a7"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelDotInBodyFrameToBodyXYZDotDot" ref="a4ae5a0d854e698521bde92dfe17b84a7" args="(const Vec3P &amp;cq, const Vec3P &amp;sq, const Vec3P &amp;w_PB_B, const Vec3P &amp;wdot_PB_B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aed514d5990532404a82da26793049900">convertAngVelDotInBodyFrameToBodyXYZDotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>wdot_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#aed514d5990532404a82da26793049900" title="TODO: sherm: is this right? Warning: everything is measured in the PARENT* frame, but has to be expre...">convertAngVelDotInBodyFrameToBodyXYZDotDot()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is XXX flops. </p>

</div>
</div>
<a class="anchor" id="af8b7a0f3971e33ca93521589eeb7cc1d"></a><!-- doxytag: member="SimTK::Rotation_::calcUnnormalizedNForQuaternion" ref="af8b7a0f3971e33ca93521589eeb7cc1d" args="(const Vec4P &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat43P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#af8b7a0f3971e33ca93521589eeb7cc1d">calcUnnormalizedNForQuaternion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a possibly unnormalized quaternion q, calculate the 4x3 matrix N which maps angular velocity w to quaternion derivatives qdot. </p>
<p>We expect the angular velocity in the parent frame, i.e. w==w_PB_P. We don't normalize, so N=|q|N' where N' is the normalized version. Cost is 7 flops. </p>

</div>
</div>
<a class="anchor" id="a30c0b4373719c68c0a14783d8fa8e8aa"></a><!-- doxytag: member="SimTK::Rotation_::calcUnnormalizedNDotForQuaternion" ref="a30c0b4373719c68c0a14783d8fa8e8aa" args="(const Vec4P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat43P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a30c0b4373719c68c0a14783d8fa8e8aa">calcUnnormalizedNDotForQuaternion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given the time derivative qdot of a possibly unnormalized quaternion q, calculate the 4x3 matrix NDot which is the time derivative of the matrix N as described in <a class="el" href="classSimTK_1_1Rotation__.html#af8b7a0f3971e33ca93521589eeb7cc1d" title="Given a possibly unnormalized quaternion q, calculate the 4x3 matrix N which maps angular velocity w ...">calcUnnormalizedNForQuaternion()</a>. </p>
<p>Note that NDot = d/dt N = d/dt (|q|N') = |q|(d/dt N'), where N' is the normalized matrix, since the length of the quaternion should be a constant. Cost is 7 flops. </p>

</div>
</div>
<a class="anchor" id="a939de389a2ef2d6516aee271d1f04ad7"></a><!-- doxytag: member="SimTK::Rotation_::calcUnnormalizedNInvForQuaternion" ref="a939de389a2ef2d6516aee271d1f04ad7" args="(const Vec4P &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat34P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a939de389a2ef2d6516aee271d1f04ad7">calcUnnormalizedNInvForQuaternion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a (possibly unnormalized) quaternion q, calculate the 3x4 matrix NInv (= N^-1) which maps quaternion derivatives qdot to angular velocity w, where the angular velocity is in the parent frame, i.e. </p>
<p>w==w_PB_P. Note: when the quaternion is not normalized, this is not precisely the (pseudo)inverse of N. inv(N)=inv(N')/|q| but we're returning |q|*inv(N')=|q|^2*inv(N). That is, NInv*N =|q|^2*I, which is I if the original q was normalized. (Note: N*NInv != I, not even close.) Cost is 7 flops. </p>

</div>
</div>
<a class="anchor" id="aea472db472765197f6daf4624b9a0700"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelToQuaternionDot" ref="aea472db472765197f6daf4624b9a0700" args="(const Vec4P &amp;q, const Vec3P &amp;w_PB_P)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#aea472db472765197f6daf4624b9a0700">convertAngVelToQuaternionDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a possibly unnormalized quaternion (0th element is the scalar) and the relative angular velocity vector of B in its parent, expressed in the *PARENT*, return the quaternion derivatives. </p>
<p>This is never singular. Cost is 27 flops. </p>

</div>
</div>
<a class="anchor" id="adc55fc1b16c0df4962094d3173ae4372"></a><!-- doxytag: member="SimTK::Rotation_::convertQuaternionDotToAngVel" ref="adc55fc1b16c0df4962094d3173ae4372" args="(const Vec4P &amp;q, const Vec4P &amp;qdot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#adc55fc1b16c0df4962094d3173ae4372">convertQuaternionDotToAngVel</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse of the above routine. </p>
<p>Returned AngVel is expressed in the *PARENT* frame: w_PB_P. Cost is 28 flops. </p>

</div>
</div>
<a class="anchor" id="a8891cd55bbfc43e47421b7534c17b947"></a><!-- doxytag: member="SimTK::Rotation_::OLDconvertAngVelDotToQuaternionDotDot" ref="a8891cd55bbfc43e47421b7534c17b947" args="(const Vec4P &amp;q, const Vec3P &amp;w_PB_P, const Vec3P &amp;wdot_PB_P)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a8891cd55bbfc43e47421b7534c17b947">OLDconvertAngVelDotToQuaternionDotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>wdot_PB_P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a quaternion q representing R_PB, angular velocity of B in P, and the time derivative of the angular velocity, return the second time derivative qdotdot of the quaternion. </p>
<p>Everything is measured and expressed in the parent. Cost is 78 flops. </p>

</div>
</div>
<a class="anchor" id="ac39e2b91d6d396f2002afb7f26335e64"></a><!-- doxytag: member="SimTK::Rotation_::convertAngVelDotToQuaternionDotDot" ref="ac39e2b91d6d396f2002afb7f26335e64" args="(const Vec4P &amp;q, const Vec3P &amp;w_PB, const Vec3P &amp;b_PB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ac39e2b91d6d396f2002afb7f26335e64">convertAngVelDotToQuaternionDotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>b_PB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We want to differentiate qdot=N(q)*w to get qdotdot=N*b+NDot*w where b is angular acceleration wdot. </p>
<p>Note that NDot=NDot(qdot), but it is far better to calculate the matrix-vector product NDot(N*w)*w directly rather than calculate NDot separately. That gives </p>
<pre>NDot*w = -(w^2)/4 * q</pre><p> Cost is 41 flops. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Rotation_8h_source.html">Rotation.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>      </li>

    <li class="footer">Generated on Wed Oct 9 2013 08:38:59 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
