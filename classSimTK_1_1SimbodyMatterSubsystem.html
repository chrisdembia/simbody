<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::SimbodyMatterSubsystem Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1SimbodyMatterSubsystem.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::SimbodyMatterSubsystem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::SimbodyMatterSubsystem" --><!-- doxytag: inherits="SimTK::Subsystem" -->
<p>This subsystem contains the bodies ("matter") in the multibody system, the mobilizers (joints) that define the generalized coordinates used to represent the motion of those bodies, and constraints that must be satisfied by the values of those coordinates.  
 <a href="classSimTK_1_1SimbodyMatterSubsystem.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SimbodyMatterSubsystem_8h_source.html">SimbodyMatterSubsystem.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::SimbodyMatterSubsystem:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1SimbodyMatterSubsystem.png" usemap="#SimTK::SimbodyMatterSubsystem_map" alt=""/>
  <map id="SimTK::SimbodyMatterSubsystem_map" name="SimTK::SimbodyMatterSubsystem_map">
<area href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems." alt="SimTK::Subsystem" shape="rect" coords="0,0,197,24"/>
</map>
 </div></div>

<p><a href="classSimTK_1_1SimbodyMatterSubsystem-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, Destruction, Topological information</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section are used in the extended construction phase for a SimbodyMatterSubsystem which we call defining the "topology" of the multibody system.</p>
<p>This includes adding mobilized bodies and constraints. Topological information is always state-independent since it is kept in the SimbodyMatterSubsystem object directly. The construction phase ends when realizeTopology() is called on the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1b1f2127fdc50c1c92b5a20db22cd43f">SimbodyMatterSubsystem</a> (<a class="el" href="classSimTK_1_1MultibodySystem.html">MultibodySystem</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a1b1f2127fdc50c1c92b5a20db22cd43f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b5ec5c33a93af6d9e3a8ebc6bf37b51">SimbodyMatterSubsystem</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an orphan matter subsystem containing only the Ground body (mobilized body 0); normally use the other constructor to place the subsystem in a <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a4b5ec5c33a93af6d9e3a8ebc6bf37b51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac49f39cefdaee87456ea572c72e1f1a1">~SimbodyMatterSubsystem</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor destroys the subsystem implementation object only if this handle is the last reference.  <a href="#ac49f39cefdaee87456ea572c72e1f1a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abca73afd312fc4fb59e912b35c928287">getMobilizedBody</a> (<a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>, return a read-only (const) reference to the corresponding <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem.  <a href="#abca73afd312fc4fb59e912b35c928287"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5142442d0d59524a47f604584040fdc1">updMobilizedBody</a> (<a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>, return a writable reference to the corresponding <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem.  <a href="#a5142442d0d59524a47f604584040fdc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a20c4cdac747e672314c6aeda0a59e876">getGround</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only (const) reference to the Ground <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem.  <a href="#a20c4cdac747e672314c6aeda0a59e876"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22">updGround</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the Ground <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem; you need a writable reference if you're adding a mobilized body that is directly connected to Ground.  <a href="#a0851b330170f8e5a0700382ddf58bd22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7776baa71fc6d342f3140284b56553fb">Ground</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a synonym for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22" title="Return a writable reference to the Ground MobilizedBody within this matter subsystem; you need a writ...">updGround()</a> that makes for nicer-looking examples.  <a href="#a7776baa71fc6d342f3140284b56553fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8c97c52cb41b5be3aa6afe3915f9a331">getConstraint</a> (<a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a>, return a read-only (const) reference to the corresponding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> within this matter subsystem.  <a href="#a8c97c52cb41b5be3aa6afe3915f9a331"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a85ca8b7eb162893128a6abc69d522e62">updConstraint</a> (<a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a>, return a writable reference to the corresponding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> within this matter subsystem.  <a href="#a85ca8b7eb162893128a6abc69d522e62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a19657abf3c40de3bc74bede59f8b1f7d">setShowDefaultGeometry</a> (bool show)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally the matter subsystem will attempt to generate some decorative geometry as a sketch of the defined multibody system; you can disable that with this method.  <a href="#a19657abf3c40de3bc74bede59f8b1f7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af29ad8515731d75d3e039b6d381ae860">getShowDefaultGeometry</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether this matter subsystem is set to generate default decorative geometry that can be used to visualize this multibody system.  <a href="#af29ad8515731d75d3e039b6d381ae860"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abd2d153469caadabcc34fcf60eb5e8c1">getNumBodies</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bodies includes all mobilized bodies <em>including</em> Ground, which is the 0th mobilized body.  <a href="#abd2d153469caadabcc34fcf60eb5e8c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad9348689e264c77ede60d222c7af8e00">getNumConstraints</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the total number of defined constraints, each of which may generate more than one constraint equation.  <a href="#ad9348689e264c77ede60d222c7af8e00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9e27f2490487cb16c8aaf09f20fea70b">getNumMobilities</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of all the mobilizer degrees of freedom.  <a href="#a9e27f2490487cb16c8aaf09f20fea70b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad52e47b213f5b60130fd13b6d154a9a3">getTotalQAlloc</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of all the q vector allocations for each joint.  <a href="#ad52e47b213f5b60130fd13b6d154a9a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a68644d94051594f5593a94936cad5f49">getTotalMultAlloc</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the sum of all the allocations for constraint multipliers, one per acceleration constraint equation.  <a href="#a68644d94051594f5593a94936cad5f49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a59d3e416b8263877d3e599774554f78d">adoptMobilizedBody</a> (<a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> parent, <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;child)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach new matter by attaching it to the indicated parent body (not normally called by users -- see <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>).  <a href="#a59d3e416b8263877d3e599774554f78d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adf98f3426a2778ba1db81c5d76bccce2">adoptConstraint</a> (<a class="el" href="classSimTK_1_1Constraint.html">Constraint</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> object to the matter subsystem (not normally called by users -- see <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>).  <a href="#adf98f3426a2778ba1db81c5d76bccce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af874cd8e7ca24c492042a0eef52ec9e8">SimbodyMatterSubsystem</a> (const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;ss)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is not very useful.  <a href="#af874cd8e7ca24c492042a0eef52ec9e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a29e07d273b578e2d1ae9935de12da608">operator=</a> (const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;ss)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is not very useful.  <a href="#a29e07d273b578e2d1ae9935de12da608"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Set/get modeling options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section involve setting and getting various modeling options that may be selected.</p>
<p>This includes whether to use quaternions or Euler angles to represent rotations, and enabling/disabling constraints. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a41930208004e6b3561c723c3cb5c3e47">setUseEulerAngles</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, bool useEulerAngles) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For all mobilizers offering unrestricted orientation, decide what method we should use to model their orientations.  <a href="#a41930208004e6b3561c723c3cb5c3e47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6a58f0c8f05f8f4416f78f9155ad726">getUseEulerAngles</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current setting of the "use Euler angles" model variable as set in the supplied <em>state</em>.  <a href="#af6a58f0c8f05f8f4416f78f9155ad726"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6e504f192dc23ed1ba8493c2e10ff487">getNumQuaternionsInUse</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of quaternions in use by the mobilizers of this system, given the current setting of the "use Euler angles" flag in the supplied <em>state</em>, and the types of mobilizers in the multibody tree.  <a href="#a6e504f192dc23ed1ba8493c2e10ff487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#addf67b644769842ff2ffea1c917ed149">isUsingQuaternion</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mobodIx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given mobilizer is currently using quaternions, based on the type of mobilizer and the setting of the "use Euler angles" flag in the supplied <em>state</em>.  <a href="#addf67b644769842ff2ffea1c917ed149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QuaternionPoolIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a133d88d5d60d466e8aea3d57a581d868">getQuaternionPoolIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mobodIx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given mobilizer is currently using a quaternion to represent orientation, return the QuaternionPoolIndex (a small integer) assigned to that quaternion.  <a href="#a133d88d5d60d466e8aea3d57a581d868"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a425f5ec3ca2e4e6aec7e03868acd5212">setConstraintIsDisabled</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a> constraintIx, bool shouldDisableConstraint) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or enable the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> whose <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a> is supplied within the supplied <em>state</em>.  <a href="#a425f5ec3ca2e4e6aec7e03868acd5212"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa38fc5183b998cff87a6b1c1060a98e8">isConstraintDisabled</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, <a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a> constraint) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a particular <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> is currently disabled in the given <em>state</em>.  <a href="#aa38fc5183b998cff87a6b1c1060a98e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a17c421e1c7e852aaac1ae445aab5254c">convertToEulerAngles</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;inputState, <a class="el" href="classSimTK_1_1State.html">State</a> &amp;outputState) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> which may be modeled using quaternions, copy it to another <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> which represents the same configuration using Euler angles instead.  <a href="#a17c421e1c7e852aaac1ae445aab5254c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a315ae4d417d5ae95329a80f089402f25">convertToQuaternions</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;inputState, <a class="el" href="classSimTK_1_1State.html">State</a> &amp;outputState) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> which may be modeled using Euler angles, copy it to another <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> which represents the same configuration using quaternions instead.  <a href="#a315ae4d417d5ae95329a80f089402f25"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Calculate whole-system properties</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods perform calculations that yield properties of the system as a whole.</p>
<p>These are <em>operators</em>, meaning that they make use of the supplied <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> but do not modify the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. They simply calculate a result and return it to you without storing it internally. Each method requires that the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> has already been realized to at least a particular stage which is documented with the method. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa469a927676fdb154d90534b853691b6">calcSystemMass</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total system mass.  <a href="#aa469a927676fdb154d90534b853691b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab46d1cd48be3eaaf4b4643d0bcdc1875">calcSystemMassCenterLocationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the position vector p_GC of the system mass center C, measured from the Ground origin, and expressed in Ground.  <a href="#ab46d1cd48be3eaaf4b4643d0bcdc1875"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abe382caff073488febe9e9a92cdfbb2f">calcSystemMassPropertiesInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return total system mass, mass center location measured from the Ground origin, and system inertia taken about the Ground origin, expressed in Ground.  <a href="#abe382caff073488febe9e9a92cdfbb2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0443924d9306417cac771ca85430d1f3">calcSystemCentralInertiaInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system inertia matrix taken about the system center of mass, expressed in Ground.  <a href="#a0443924d9306417cac771ca85430d1f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4d37fb1df3570860249e62310570e386">calcSystemMassCenterVelocityInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the velocity v_GC = d/dt p_GC of the system mass center C in the Ground frame G, measured from Ground origin and expressed in G.  <a href="#a4d37fb1df3570860249e62310570e386"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae1d4611733f4b7dc9573cff5fb30c01b">calcSystemMassCenterAccelerationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the acceleration a_GC = d/dt p_GC of the system mass center C in the Ground frame G, measured from Ground origin and expressed in G.  <a href="#ae1d4611733f4b7dc9573cff5fb30c01b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6c5186727032683ee1c53fae6487c151">calcSystemMomentumAboutGroundOrigin</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the momentum of the system as a whole (angular, linear) measured in the Ground frame, taken about the Ground origin and expressed in Ground.  <a href="#a6c5186727032683ee1c53fae6487c151"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a63fcc8c4579ddd5860c16a27d2e88322">calcSystemCentralMomentum</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the momentum of the system as a whole (angular, linear) measured in the Ground frame, taken about the current system center of mass location C and expressed in Ground.  <a href="#a63fcc8c4579ddd5860c16a27d2e88322"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a31b65eb7fe180fd0904eae57d476f35e">calcKineticEnergy</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total kinetic energy of all the mobilized bodies in this matter subsystem, given the configuration and velocities in <em>state</em>.  <a href="#a31b65eb7fe180fd0904eae57d476f35e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">System and Task Space Kinematic Jacobian Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The system kinematic Jacobian maps between mobility space (generalized speeds and generalized forces) and Cartesian body space (mobilized body frame spatial velocities and spatial forces).</p>
<p>A task space Jacobian maps between mobility space and a specified set of task points or frames fixed to a subset of the bodies, and generally located away from the body frame. A task space Jacobian J can be used to construct various task space matrices such as the task space compliance matrix J M^-1 ~J or its inverse, the task space (or operational space) inertia matrix.</p>
<p>The system Jacobian J(q) maps n generalized speeds u to spatial velocities V of each of the nb mobilized bodies (including Ground), measured at the body frame origin relative to Ground, and expressed in the Ground frame. The transpose ~J of this matrix maps nb spatial forces to n generalized forces, where the spatial forces are applied at the body frame origin and expressed in Ground. Similarly, task space Jacobians map from n generalized speeds to nt task frame spatial velocities (expressed in Ground), and transposed task space Jacobians map between task frame spatial forces (or impulses), expressed in Ground, and generalized forces (or generalized impulses).</p>
<p>Simbody provides fast O(n) methods ("operators") that can form matrix-vector products like J*u or ~J*F without forming J. The "bias" term Jdot*u (also known as the Coriolis acceleration) is also available; this arises when working at the acceleration level because d/dt J*u = J*udot+Jdot*u (where dot means time derivative). The computational cost of these operators is O(n+nt) so it is <em>much</em> more efficient to work with a group of tasks simultaneously than to process one at a time, which would have complexity O(n*nt). Alternatively, we provide methods that will return all or part of J explicitly; in general it is <em>much</em> more efficient computationally to work with the O(n) matrix-vector multiply operators rather than to form explicit matrices and then perform O(n^2) matrix-vector products. Performance estimates are given with each method so that you can determine which methods to use. If you can, you should use the O(n) methods -- it is a good habit to get into when using an O(n) multibody code like Simbody!</p>
<p>Note that the Jacobian is associated with an expressed-in frame for the velocity or force vector and a designated station (point) on each body. We always use the Ground frame for Jacobians. For the system Jacobian, the body origin is always the designated station; for task Jacobians different stations may be specified. We provide three different sets of methods for working with</p>
<ul>
<li>the full System Jacobian: J, nb X n 6-vectors (or 6*nb X n scalars)</li>
<li>the Station Jacobian for a set of nt task stations (points): JS, nt rows of n 3-vectors (or a 3*nt X n Matrix of scalars)</li>
<li>the Frame Jacobian for a set of nt task frames fixed to a body: JF, nt rows of n 6-vectors (or a 6*nt X n Matrix of scalars)</li>
</ul>
<p>The rotational part of a Jacobian is the same for any frame fixed to the same body. So for Frame Jacobians you need specify only a station on the body (the frame's origin point). That means if you want a 3*nt X n Orientation Jacobian, you can obtain it from alternate rows of a Frame Jacobian. Using the above terminology, the complete System Jacobian is a Frame Jacobian for which the task frames are the body frames, with each <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> appearing only once and in order of <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> (starting with Ground).</p>
<p>It is acceptable for the same body to appear more than once in a list of tasks; these are likely to conflict but that can be dealt with elsewhere. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33">multiplyBySystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;Ju) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) and a mobility-space vector u in O(n) time.  <a href="#a3722e55e7b5923558bd3f1a0cf4a5f33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a43d9b54ce86f55165488b2dd270d5995">calcBiasForSystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JDotu) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration bias term for the System Jacobian, that is, the part of the acceleration that is due only to velocities.  <a href="#a43d9b54ce86f55165488b2dd270d5995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6bb52c632fcccf14d051ff1be99cdb66">calcBiasForSystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;JDotu) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns the bias as a 6*nb-vector of scalars rather than as an nb-vector of 2x3 spatial vectors.  <a href="#a6bb52c632fcccf14d051ff1be99cdb66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342">multiplyBySystemJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;F_G, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial force-like elements, one per body, in O(n) time to produce a generalized force-like result f=~J*F.  <a href="#ae2900f9febb57ef8deab114f37cb2342"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5563ca485168cb1c25d7ae34e27e8f2f">calcSystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;J_G) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a 2x3 spatial vector (SpatialVec).  <a href="#a5563ca485168cb1c25d7ae34e27e8f2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a26549e7484bfbe6eb8d7bc123e66259d">calcSystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;J_G) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns a system Jacobian as a 6*nb X n Matrix of scalars rather than as an nb X n matrix of 2x3 spatial vectors.  <a href="#a26549e7484bfbe6eb8d7bc123e66259d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9b9920681595a75c69e2ba77c25cb934">multiplyByStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;JSu) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) that results from a particular set of generalized speeds u.  <a href="#a9b9920681595a75c69e2ba77c25cb934"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9c7930b8c008e0699398a05e8fc6cb62">multiplyByStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#a9c7930b8c008e0699398a05e8fc6cb62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a314427ba46921a0f31787bf1278e6a9e">multiplyByStationJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;f_GP, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (points fixed to bodies) P.  <a href="#a314427ba46921a0f31787bf1278e6a9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a423ed4c2c53722921594aa7c4fc6ce17">multiplyByStationJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;f_GP, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#a423ed4c2c53722921594aa7c4fc6ce17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a84cc002312ec1dda2a7382a214253095">calcStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, <a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;JS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a station is a point fixed on a particular mobilized body).  <a href="#a84cc002312ec1dda2a7382a214253095"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0f8546ca7e873b1d4377dd4b779f32ea">calcStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB, <a class="el" href="classSimTK_1_1RowVector__.html">RowVector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;JS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#a0f8546ca7e873b1d4377dd4b779f32ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7b5db37321e8a62ff542bfb822668f4e">calcStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;JS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns a station Jacobian as a 3*nt x n Matrix rather than as a Matrix of Vec3 elements.  <a href="#a7b5db37321e8a62ff542bfb822668f4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a32199636039f7a63a6b4270b0f6a26be">calcStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;JS) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#a32199636039f7a63a6b4270b0f6a26be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a86f1d50eba0046eeb21f7df2e5c933cc">calcBiasForStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;JSDotu) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration bias term for a station Jacobian, that is, the part of the station's acceleration that is due only to velocities.  <a href="#a86f1d50eba0046eeb21f7df2e5c933cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a423d7d33800cb6b62509dd15abbdc1f2">calcBiasForStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;JSDotu) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns the bias as a 3*nt-vector of scalars rather than as an nt-vector of Vec3s.  <a href="#a423d7d33800cb6b62509dd15abbdc1f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aff992b923c429d78a922d71d15b8f491">calcBiasForStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#aff992b923c429d78a922d71d15b8f491"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b7b4e350aabedbef00ff1ec35e81d3b">multiplyByFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JFu) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}, that result from a particular set of n generalized speeds u.  <a href="#a4b7b4e350aabedbef00ff1ec35e81d3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8b20283e113f7a36eba47b25c80f9cb8">multiplyByFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task; see the main signature for documentation.  <a href="#a8b20283e113f7a36eba47b25c80f9cb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7c49a55eba4badde996dd789bad1a8a">multiplyByFrameJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;F_GAo, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi.  <a href="#ad7c49a55eba4badde996dd789bad1a8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a19548c59a4769a51109ec7c57e65fd08">multiplyByFrameJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;F_GAo, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task.  <a href="#a19548c59a4769a51109ec7c57e65fd08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657">calcFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, <a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JF) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai} fixed to nt bodies B={Bi}.  <a href="#a741150aaf33c1b667067b11f3cb59657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9502959cb6062ea34dfff2bdcba570fc">calcFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB, <a class="el" href="classSimTK_1_1RowVector__.html">RowVector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JF) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task.  <a href="#a9502959cb6062ea34dfff2bdcba570fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9e5e88fa9c29c900d479bc52cd7fe659">calcFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;JF) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns a frame Jacobian as a 6*nt X n Matrix rather than as an nt X n Matrix of SpatialVecs.  <a href="#a9e5e88fa9c29c900d479bc52cd7fe659"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeace3f635f35b438f32b217a4fd85b75">calcFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;JF) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task.  <a href="#aeace3f635f35b438f32b217a4fd85b75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8cc4e782538d519014c70b83d4a6e984">calcBiasForFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JFDotu) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration bias term for a task frame Jacobian, that is, the parts of the frames' accelerations that are due only to velocities.  <a href="#a8cc4e782538d519014c70b83d4a6e984"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a242d51ecff031b7b74e9beada96be6f7">calcBiasForFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;JFDotu) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns the bias as a 6*nt-vector of scalars rather than as an nt-vector of SpatialVec elements.  <a href="#a242d51ecff031b7b74e9beada96be6f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a180d39d0a828fd7dcaf39581fd2ed309">calcBiasForFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task.  <a href="#a180d39d0a828fd7dcaf39581fd2ed309"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">System matrix manipulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The documentation for the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a> describes the system equations in matrix notion, although internal computations are generally matrix-free.</p>
<p>The operators in this section provide the ability to perform fast operations that can be described in terms of those matrices (e.g., multiply by the mass matrix) but are actually done using O(n), matrix-free algorithms. There are also routines here for obtaining the matrices explicitly, although working with explicit matrices should be avoided whenever performance is an issue.</p>
<p>The mass matrix M and constraint matrix G are the most significant. G=[P;V;A] is composed of submatrices P for position (holonomic), V for velocity (nonholonomic), and A for acceleration-only constraints. These matrices are sometimes needed separately. Also, these matrices are all in mobility space (generalized speeds u). When qdot != u, the matrix N in the equation qdot = N*u becomes important and operators for working with it efficiently are also provided here. In that case, the position constraint matrix in generalized coordinate q space, Pq, can also be accessed. (In terms of the other matrices, Pq=P*N^-1.) </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a343dc68594d7afe04762db67a3ca68a9">multiplyByM</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;a, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;Ma) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a supplied mobility-space vector (that is, it has one entry for each of the n mobilities).  <a href="#a343dc68594d7afe04762db67a3ca68a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeb30ad8dd2dfd5981de9681fa8ac7f43">multiplyByMInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;v, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;MinvV) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a supplied vector with one entry per u-space mobility.  <a href="#aeb30ad8dd2dfd5981de9681fa8ac7f43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af297a2c82bb19a9deae10bb8f873f9f9">calcM</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;M) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator explicitly calculates the n X n mass matrix M.  <a href="#af297a2c82bb19a9deae10bb8f873f9f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a564e87359d2689137a43f85c3e861690">calcMInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;MInv) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix corresponding to free (non-prescribed) mobilities.  <a href="#a564e87359d2689137a43f85c3e861690"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af567d109f8e6705eaa9835b9309c6f03">calcProjectedMInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;GMInvGt) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator calculates in O(m*n) time the m X m "projected inverse mass 
matrix" or "constraint compliance matrix" W=G*M^-1*~G, where G (mXn) is the acceleration-level constraint Jacobian mapped to generalized coordinates, and M (nXn) is the unconstrained system mass matrix.  <a href="#af567d109f8e6705eaa9835b9309c6f03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7316d38fe5ba9237cab137011b10c21">solveForConstraintImpulses</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;deltaV, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;impulse) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of desired constraint-space speed changes, calculate the corresponding constraint-space impulses that would cause those changes.  <a href="#ad7316d38fe5ba9237cab137011b10c21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e">multiplyByG</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;ulike, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;Gulike) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a "u-like" (mobility space) vector of length n.  <a href="#a90a34ce745cbf5a0bf34f4a62d9ddb2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae939c33c0491867cecc55d0c0748441b">multiplyByG</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;ulike, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;bias, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;Gulike) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Gulike=G*ulike using the supplied precalculated bias vector to improve performance (approximately 2X) over the other signature.  <a href="#ae939c33c0491867cecc55d0c0748441b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9d7d060109d5f1ca2090d23e2d40db57">calcBiasForMultiplyByG</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;bias) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the bias vector needed for the higher-performance signature of the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a> method above.  <a href="#a9d7d060109d5f1ca2090d23e2d40db57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9ccc3ce0e76fbc65aeb480ef73d603db">calcG</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;G) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which appears in the system equations of motion.  <a href="#a9ccc3ce0e76fbc65aeb480ef73d603db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a070ff72001adf5714ec1e55851404f1b">calcBiasForAccelerationConstraints</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;bias) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration constraint bias vector, that is, the terms in the acceleration constraints that are independent of the accelerations.  <a href="#a070ff72001adf5714ec1e55851404f1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d2451d87d7cae837062cd9a036bf698">multiplyByGTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;lambda, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (=[P;V;A]) and a multiplier-like vector <em>lambda</em> of length m, returning a generalized-force like quantity <em>f</em> of length n.  <a href="#a3d2451d87d7cae837062cd9a036bf698"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0f04f21d4d1fe85c830f71d60995a799">calcGTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;Gt) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This O(nm) operator explicitly calculates the n X m transpose of the acceleration-level constraint Jacobian G = [P;V;A] which appears in the system equations of motion.  <a href="#a0f04f21d4d1fe85c830f71d60995a799"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc">multiplyByPq</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qlike, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;PqXqlike) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint Jacobian and <em>qlike</em> is a "q-like" (generalized coordinate space) vector of length nq.  <a href="#aea5e1f8641e547ae8bd317202236bfdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa88a493efe683e24eb5bfeb2aca32bf3">multiplyByPq</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qlike, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;biasp, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;PqXqlike) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Pq*qlike using the supplied precalculated bias vector to improve performance (approximately 2X) over the other signature.  <a href="#aa88a493efe683e24eb5bfeb2aca32bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ace41900bbf22180dc66b632db4198af2">calcBiasForMultiplyByPq</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;biasp) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the bias vector needed for the higher-performance signature of the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> method above.  <a href="#ace41900bbf22180dc66b632db4198af2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afee56d346a7f0adeffe19b5b951d51b5">calcPq</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;Pq) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This O(m*n) operator explicitly calculates the mp X nq position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the position error equations with respect to q.  <a href="#afee56d346a7f0adeffe19b5b951d51b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8e1f93e8ed0f1366cb24adc34ecc2b5c">multiplyByPqTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;lambdap, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint Jacobian Pq (=P*N^-1) and a multiplier-like vector <em>lambdap</em> of length mp, returning a generalized-force like quantity <em>f</em> of length n.  <a href="#a8e1f93e8ed0f1366cb24adc34ecc2b5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abf054922c552ad0182c6fce5839473a4">calcPqTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;Pqt) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This O(m*n) operator explicitly calculates the nq X mp transpose of the position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the position error equations with respect to q.  <a href="#abf054922c552ad0182c6fce5839473a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a67ee9e954c61bb99aab23a8a2e32f17c">calcP</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mp X nu matrix P which is the Jacobian of the first time derivative of the holonomic (position) constraint errors with respect to the generalized speeds u; that is, P = partial( dperr/dt )/partial(u).  <a href="#a67ee9e954c61bb99aab23a8a2e32f17c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aef93085ae7c818d764d8d756a46aa578">calcPt</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;Pt) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nu X mp matrix ~P - see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a67ee9e954c61bb99aab23a8a2e32f17c" title="Returns the mp X nu matrix P which is the Jacobian of the first time derivative of the holonomic (pos...">calcP()</a> for a description.  <a href="#aef93085ae7c818d764d8d756a46aa578"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8717059cf2dcdcc7686b74d0f98aa3d7">multiplyByN</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool <a class="el" href="namespaceSimTK.html#a8279fd7a157b0f4078ea245377484d82">transpose</a>, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;in, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_q = N(q)*in_u (like qdot=N*u) or out_u = ~N*in_q.  <a href="#a8717059cf2dcdcc7686b74d0f98aa3d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6005e93b49eea745739c9df64cab7223">multiplyByNInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool <a class="el" href="namespaceSimTK.html#a8279fd7a157b0f4078ea245377484d82">transpose</a>, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;in, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_u = NInv(q)*in_q (like u=NInv*qdot) or out_q = ~NInv*in_u.  <a href="#a6005e93b49eea745739c9df64cab7223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2ca55c9a4bd3d333ca6759af882f38a1">multiplyByNDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool <a class="el" href="namespaceSimTK.html#a8279fd7a157b0f4078ea245377484d82">transpose</a>, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;in, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_q = NDot(q,u)*in_u or out_u = ~NDot(q,u)*in_q.  <a href="#a2ca55c9a4bd3d333ca6759af882f38a1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Operators make use of the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> but do not write their results back into the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>, not even into the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> cache.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#acaa2e2826c3aa20edd38ef295619f219">calcAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;appliedMobilityForces, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;appliedBodyForces, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;udot, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;A_GB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the primary forward dynamics operator.  <a href="#acaa2e2826c3aa20edd38ef295619f219"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90bb781704ba58833f69bb86432339a7">calcAccelerationIgnoringConstraints</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;appliedMobilityForces, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;appliedBodyForces, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;udot, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;A_GB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator is similar to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#acaa2e2826c3aa20edd38ef295619f219" title="This is the primary forward dynamics operator.">calcAcceleration()</a> but ignores the effects of acceleration constraints although it obeys prescribed accelerations.  <a href="#a90bb781704ba58833f69bb86432339a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9402191ff489fae227969ed43db05df0">calcResidualForceIgnoringConstraints</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;appliedMobilityForces, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;appliedBodyForces, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownUdot, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;residualMobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the inverse dynamics operator for the tree system; if there are any constraints or prescribed motion they are ignored.  <a href="#a9402191ff489fae227969ed43db05df0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adbefe95f61bdad30776f742345fa1fce">calcResidualForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;appliedMobilityForces, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;appliedBodyForces, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownUdot, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownLambda, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;residualMobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the inverse dynamics operator for when you know both the accelerations and Lagrange multipliers for a constrained system.  <a href="#adbefe95f61bdad30776f742345fa1fce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7b1da0e232e11cadd1bf32d4f94035df">calcCompositeBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a>, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;R) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator calculates the composite body inertias R given a <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> realized to Position stage.  <a href="#a7b1da0e232e11cadd1bf32d4f94035df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a94d275630d490646b6eed0c1ed392c6d">calcBodyAccelerationFromUDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownUDot, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;A_GB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a complete set of n generalized accelerations udot, this kinematic operator calculates in O(n) time the resulting body accelerations, including velocity-dependent terms taken from the supplied <em>state</em>.  <a href="#a94d275630d490646b6eed0c1ed392c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cae3da23f051dc8116fbf0e054dd302">calcConstraintForcesFromMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;multipliers, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Treating all Constraints together, given a comprehensive set of m Lagrange multipliers <em>lambda</em>, generate the complete set of body spatial forces and mobility (generalized) forces applied by all the Constraints.  <a href="#a6cae3da23f051dc8116fbf0e054dd302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af">calcMobilizerReactionForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;forcesAtMInG) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the mobilizer reaction force generated at each <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>, as felt at the mobilizer's outboard frame M, and expressed in Ground.  <a href="#adc629077769b8c767bd1bc160787d4af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa4d35b2738498ac63c76961af27b9881">getMotionMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the prescribed motion multipliers tau that have already been calculated in the given <em>state</em>, which must have been realized through Acceleration stage.  <a href="#aa4d35b2738498ac63c76961af27b9881"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af80a52a3ac50dced558fe486cd3a4db2">calcMotionErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Stage.html">Stage</a> &amp;stage) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the degree to which the supplied <em>state</em> does not satisfy the prescribed motion requirements at a particular <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>.  <a href="#af80a52a3ac50dced558fe486cd3a4db2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adf85cff428267680387a3a61e178ddbf">findMotionForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the generalized mobility space forces produced by all the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects active in this system.  <a href="#adf85cff428267680387a3a61e178ddbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae6c2def3b10fe13eef67d374db29b3e1">getConstraintMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the constraint multipliers lambda that have already been calculated in the given <em>state</em>, which must have been realized through Acceleration stage.  <a href="#ae6c2def3b10fe13eef67d374db29b3e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a977620eb35c8e3ac371f1ede3d257f">findConstraintForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the forces produced by all the active <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects in this system.  <a href="#a2a977620eb35c8e3ac371f1ede3d257f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1e4a10a720a71b3c0eff679ef566569e">calcMotionPower</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the power being generated or dissipated by all the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects currently active in this system.  <a href="#a1e4a10a720a71b3c0eff679ef566569e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0663411853688e1a14beb0713f8e8de4">calcConstraintPower</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the power begin generated or dissipated by all the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects currently active in this system.  <a href="#a0663411853688e1a14beb0713f8e8de4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1e9a32a3ff754e9d7b75644deeb5c818">calcTreeEquivalentMobilityForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForces, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accounts for applied forces and inertial forces produced by non-zero velocities in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>.  <a href="#a1e9a32a3ff754e9d7b75644deeb5c818"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6afc8df58f92fc6dd15658b8a735c830">calcQDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qdot) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate qdot = N(q)*u in O(n) time (very fast).  <a href="#a6afc8df58f92fc6dd15658b8a735c830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a45137921388b175b5a17330bef09b599">calcQDotDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;udot, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qdotdot) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate qdotdot = N(q)*udot + Ndot(q,u)*u in O(n) time (very fast).  <a href="#a45137921388b175b5a17330bef09b599"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3202bd0a85f219c8475a427533cce9b2">addInStationForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;forceInG, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in to the given body forces vector a force applied to a station (fixed point) S on a body B.  <a href="#a3202bd0a85f219c8475a427533cce9b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aafee133053a0230fd545f90793acea4d">addInBodyTorque</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mobodIx, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;torqueInG, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in to the given body forces vector a torque applied to a body B.  <a href="#aafee133053a0230fd545f90793acea4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a69b7d894990d382a20bd1820618ea261">addInMobilityForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mobodIx, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> which, Real f, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in to the given mobility forces vector a scalar generalized force, that is a force or torque applied to a mobilizer generalized speed.  <a href="#a69b7d894990d382a20bd1820618ea261"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Realization and response methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Realization methods request that some calculation be performed ("realized") if it has not already been done since the last change to one of the state variables on which the result depends, with the result being placed in the state cache.</p>
<p>Methods beginning with "get" are called <em>responses</em> and are used to extract pre-calculated information that has been realized into the cache.</p>
<p>Realization is normally initiated at the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> level. However, there are some "lazy" calculations in the SimbodyMatterSubsystem whose computations are delayed until needed; you can cause those calculations to be performed explicitly here if you want. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0467f617de57e966bc3c141094037ff4">realizeCompositeBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#a0467f617de57e966bc3c141094037ff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab91faf31bae6a4bea3ae495b887a473d">realizeArticulatedBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether articulated body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates the relatively expensive computation of articulated body inertias for all of the mobilized bodies.  <a href="#ab91faf31bae6a4bea3ae495b887a473d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1QIndex.html">QIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9c9ead398fe406f45fae30e6ab2e61ce">getFreeQIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#a9c9ead398fe406f45fae30e6ab2e61ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1UIndex.html">UIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a11061f1dccb350c19cb0c5ea37e834bb">getFreeUIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#a11061f1dccb350c19cb0c5ea37e834bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1UIndex.html">UIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9a3c42b7bc0d03be0b76bdccb8d603d2">getFreeUDotIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#a9a3c42b7bc0d03be0b76bdccb8d603d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1UIndex.html">UIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a79597b03f1bd6a4c5224f0d28d6970f4">getKnownUDotIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#a79597b03f1bd6a4c5224f0d28d6970f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a315a7440c705f22c00172bb29cac7ff6">packFreeQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;allQ, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;packedFreeQ) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#a315a7440c705f22c00172bb29cac7ff6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afcee048d2447180e24fb95db49da4871">unpackFreeQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;packedFreeQ, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;unpackedFreeQ) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#afcee048d2447180e24fb95db49da4871"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4cdaf133ed39188b6cfcfe3ab787bbaf">packFreeU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;allU, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;packedFreeU) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#a4cdaf133ed39188b6cfcfe3ab787bbaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af35844913602b0b4c99b0dd0e9f8ea60">unpackFreeU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;packedFreeU, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;unpackedFreeU) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#af35844913602b0b4c99b0dd0e9f8ea60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aae984d90b307ca3dbbcd98feba14e429">getCompositeBodyInertia</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the composite body inertia for a particular mobilized body.  <a href="#aae984d90b307ca3dbbcd98feba14e429"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ab1473db0cef6d6f29b827de9f1b3cb9f">ArticulatedInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae7c76cf4f87af5661178f67cfdaa987a">getArticulatedBodyInertia</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the articulated body inertia for a particular mobilized body.  <a href="#ae7c76cf4f87af5661178f67cfdaa987a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0fd2f8985d689b25c5b8bbc8e6c66d1c">getGyroscopicForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the angular velocity-dependent force on the body due to rotational inertia.  <a href="#a0fd2f8985d689b25c5b8bbc8e6c66d1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8eb9d41d15bf1c36dfae3abf64d03cc6">getMobilizerCoriolisAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the cross-mobilizer incremental contribution to coriolis (angular velocity dependent) acceleration; not too useful, see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcf1b13d1c0b400dd41a77a80c840d30" title="This is the total coriolis acceleration including the effect of the parent&#39;s angular velocity as well...">getTotalCoriolisAcceleration()</a> instead.  <a href="#a8eb9d41d15bf1c36dfae3abf64d03cc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcf1b13d1c0b400dd41a77a80c840d30">getTotalCoriolisAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the total coriolis acceleration including the effect of the parent's angular velocity as well as the joint's.  <a href="#abcf1b13d1c0b400dd41a77a80c840d30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a980895e021f861e730f6c1021581c498">getMobilizerCentrifugalForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the angular velocity-dependent force accounting for gyroscopic forces plus coriolis forces due only to the cross-mobilizer velocity; this ignores the parent's velocity and is not too useful -- see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a98b55fad58c0968702ae7c1d92238bcc" title="This is the total angular velocity-dependent force acting on this body, including forces due to corio...">getTotalCentrifugalForces()</a> instead.  <a href="#a980895e021f861e730f6c1021581c498"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a98b55fad58c0968702ae7c1d92238bcc">getTotalCentrifugalForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the total angular velocity-dependent force acting on this body, including forces due to coriolis acceleration and forces due to rotational inertia.  <a href="#a98b55fad58c0968702ae7c1d92238bcc"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Testing and debugging utilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section provide alternate ways of calculating quantities for which we provide more efficient methods above.</p>
<p>You should use the better methods normally, but these can be very useful for regression testing and Simbody development because the answers are obtained differently. Numerical results should agree with the faster methods to within numerical precision. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a47d5161f2fe40dbb8f10efa00af7dac9">calcMobilizerReactionForcesUsingFreebodyMethod</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;forcesAtMInG) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a slower alternative to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">calcMobilizerReactionForces()</a>, for use in regression testing and Simbody development.  <a href="#a47d5161f2fe40dbb8f10efa00af7dac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615">invalidateCompositeBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0467f617de57e966bc3c141094037ff4" title="This method checks whether composite body inertias have already been computed since the last change t...">realizeCompositeBodyInertias()</a>, which otherwise will not recalculate them if called repeatedly.  <a href="#abbc7059ae4e3f28a79ff3827a6f62615"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af86d27998b2b85e3ff1ede658d8ad459">invalidateArticulatedBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab91faf31bae6a4bea3ae495b887a473d" title="This method checks whether articulated body inertias have already been computed since the last change...">realizeArticulatedBodyInertias()</a>, which otherwise will not recalculate them if called repeatedly.  <a href="#af86d27998b2b85e3ff1ede658d8ad459"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Proposed particle API</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>(NOT IMPLEMENTED YET) These methods are a proposed API for explicit handling of particles.</p>
<p>Currently a particle should be implemented as point mass with a Cartesian (translation) mobilizer to Ground instead. The idea here would be to special-case particles to make them faster; there would be no additional functionality. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05e7167b00a9570218e3b45a03e558e5">getNumParticles</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a05e7167b00a9570218e3b45a03e558e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7486d4d34ef0982ec41a690b6ed69407">getAllParticleLocations</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a7486d4d34ef0982ec41a690b6ed69407"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae381fcbc2bfd0abe2423a312412569c7">getAllParticleVelocities</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#ae381fcbc2bfd0abe2423a312412569c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#affe6bd028e997de598d994f5b982b969">getParticleLocation</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#affe6bd028e997de598d994f5b982b969"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a50c78ab6c6491600feec4368ec72ef05">getParticleVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a50c78ab6c6491600feec4368ec72ef05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a21c21918140352352f314410065463ee">updAllParticleMasses</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a21c21918140352352f314410065463ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a049f0dca3c1e1bc3d1dff875232d480f">setAllParticleMasses</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;masses) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a049f0dca3c1e1bc3d1dff875232d480f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6fd4a9b89ec9b84d471a2ec5522d9884">updAllParticleLocations</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a6fd4a9b89ec9b84d471a2ec5522d9884"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a24d88498b6264888cd1a96e35c06c06a">updAllParticleVelocities</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a24d88498b6264888cd1a96e35c06c06a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90ee991274e97d76f1ab1d9f4e5e8e57">updParticleLocation</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a90ee991274e97d76f1ab1d9f4e5e8e57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac0d79e2ae7f878ad8cbe95c34fc1c9e0">updParticleVelocity</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#ac0d79e2ae7f878ad8cbe95c34fc1c9e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab25e295b1ce7f7a3cac8464f612ae4e1">setParticleLocation</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;r) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#ab25e295b1ce7f7a3cac8464f612ae4e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5bd7fd868b468dc276778b6151198f0a">setParticleVelocity</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a5bd7fd868b468dc276778b6151198f0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a323defc86dc3b64003ebc5f30e6adbea">setAllParticleLocations</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;r) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a323defc86dc3b64003ebc5f30e6adbea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aae6a6215af63f530fa402596ef2b268f">setAllParticleVelocities</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#aae6a6215af63f530fa402596ef2b268f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac57c2b4575f9fe88698d1dfcbf991e41">getAllParticleMasses</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#ac57c2b4575f9fe88698d1dfcbf991e41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4d079d6d020dbfd06e74625bae0c28ba">getAllParticleAccelerations</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a4d079d6d020dbfd06e74625bae0c28ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a24aa7dd470a3f94f88f90369698f5ff7">getParticleAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a24aa7dd470a3f94f88f90369698f5ff7"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ada91148391d89bcdcfd812c91cf16fbb">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump some debug information about the given subsystem to the given output stream; this is <em>not</em> for serialization.  <a href="#ada91148391d89bcdcfd812c91cf16fbb"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This subsystem contains the bodies ("matter") in the multibody system, the mobilizers (joints) that define the generalized coordinates used to represent the motion of those bodies, and constraints that must be satisfied by the values of those coordinates. </p>
<p>There are many methods in the API for this class. For whole-system information and calculations, the methods here are the right ones to use. For information associated with individual objects contained in the subsystem, such as <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> and <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects, it is generally easier to obtain the information through the contained objects' APIs instead.</p>
<p>This class is is a "handle" containing only an opaque reference to the underlying implementation class.</p>
<h3>Theory discussion</h3>
<p>The bodies, mobilizers, and constraints are represented mathematically with the following set of equations: </p>
<pre>
                     qdot = N u                 Kinematic differential eqns.
                     zdot = zdot(t,q,u,z)       Auxiliary states</pre><pre>         M udot + ~G mult = f(t,q,u,z)          Equations of motion
         G udot           = b(t,q,u)</pre><pre>                 where</pre><pre>          [P]    [bp]
        G=[V]  b=[bv]  f = T + ~J*(F-C)
          [A]    [ba]</pre><pre>          pdotdot = P udot - bp(t,q,u) = 0      Acceleration constraints
             vdot = V udot - bv(t,q,u) = 0
    a(t,q,u,udot) = A udot - ba(t,q,u) = 0</pre><pre>                   pdot = P u - c(t,q) = 0      Velocity constraints
                              v(t,q,u) = 0</pre><pre>                                p(t,q) = 0      Position constraints
                                  n(q) = 0      Normalization constraints
</pre><p> where M(q) is the mass matrix, G(t,q,u) the acceleration constraint matrix, C(q,u) the coriolis and gyroscopic forces, T is user-applied joint mobility forces, F is user-applied body forces and torques and gravity. J(q) is the System Jacobian (partial velocity matrix) whose transpose ~J maps spatial forces to joint mobility forces. p(t,q) are the holonomic (position) constraints, v(t,q,u) the non-holonomic (velocity) constraints, and a(t,q,u,udot) the acceleration-only constraints, which must be linear in udot, with A(t,q,u) the coefficient matrix for a(). pdot, pdotdot are obtained by differentiation of p(), vdot by differentiation of v(). P(t,q)=Dpdot/Du (yes, that's u, not q -- we can get Pq=Dp/Dq when we need it as Pq=P*N^-1) and V(t,q,u)=Dv/Du. (We use capital "D" to indicate partial derivative.) n(q) is the set of quaternion normalization constraints, which exist only at the position level and are uncoupled from everything else.</p>
<p>We calculate the constraint multipliers like this: </p>
<pre>
          G M^-1 ~G mult = G udot0 - b
          where    udot0 = M^-1 f
</pre><p> using the pseudo inverse of G M^-1 ~G to give a least squares solution for mult: mult = pinv(G M^-1 ~G)(G M^-1 f - b). Then the real udot is udot = udot0 - udotC, with udotC = M^-1 ~G mult. Note: M^-1* is an O(n) operator that provides the desired result; it <em>does not</em> require forming or factoring M.</p>
<p>NOTE: only the following constraint matrices have to be formed and factored: </p>
<pre>
   [G M^-1 ~G]   to calculate multipliers</pre><pre>   [P N^-1]      for projection onto position manifold (a.k.a. Pq)</pre><pre>   [ P ]         for projection onto velocity manifold
   [ V ]  
</pre><p>When working in a weighted norm with weights W on the state variables and weights T (1/tolerance) on the constraint errors, the matrices we need are actually [Tp Pq Wq^-1], [Tpv [P;V] Wu^-1], etc. with T and W diagonal weighting matrices. These can then be used to find least squares solutions in the weighted norms.</p>
<p>In many cases these matrices consist of decoupled blocks which can be solved independently. (TODO: take advantage of that whenever possible to solve a set of smaller systems rather than one large one.) Also, in the majority of biosimulation applications we are likely to have only holonomic (position) constraints, so there is no V or A and G=P is the whole story. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1b1f2127fdc50c1c92b5a20db22cd43f"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem" ref="a1b1f2127fdc50c1c92b5a20db22cd43f" args="(MultibodySystem &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1b1f2127fdc50c1c92b5a20db22cd43f">SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MultibodySystem.html">MultibodySystem</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>
<p>The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> takes over ownership of the subsystem, which is not copied. The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> and this subsystem handle both refer to the same subsystem after this call. </p>

</div>
</div>
<a class="anchor" id="a4b5ec5c33a93af6d9e3a8ebc6bf37b51"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem" ref="a4b5ec5c33a93af6d9e3a8ebc6bf37b51" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1b1f2127fdc50c1c92b5a20db22cd43f">SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an orphan matter subsystem containing only the Ground body (mobilized body 0); normally use the other constructor to place the subsystem in a <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>

</div>
</div>
<a class="anchor" id="ac49f39cefdaee87456ea572c72e1f1a1"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::~SimbodyMatterSubsystem" ref="ac49f39cefdaee87456ea572c72e1f1a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac49f39cefdaee87456ea572c72e1f1a1">SimTK::SimbodyMatterSubsystem::~SimbodyMatterSubsystem</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The destructor destroys the subsystem implementation object only if this handle is the last reference. </p>
<p>Normally, there is a <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> that holds a reference to the subsystem implementation, so this destruction will do nothing. </p>

</div>
</div>
<a class="anchor" id="af874cd8e7ca24c492042a0eef52ec9e8"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem" ref="af874cd8e7ca24c492042a0eef52ec9e8" args="(const SimbodyMatterSubsystem &amp;ss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1b1f2127fdc50c1c92b5a20db22cd43f">SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor is not very useful. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abca73afd312fc4fb59e912b35c928287"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getMobilizedBody" ref="abca73afd312fc4fb59e912b35c928287" args="(MobilizedBodyIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abca73afd312fc4fb59e912b35c928287">SimTK::SimbodyMatterSubsystem::getMobilizedBody</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>, return a read-only (const) reference to the corresponding <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem. </p>
<p>This method will fail if the index is invalid or out of range. MobilizedBodyIndex(0) selects the Ground mobilized body. </p>

</div>
</div>
<a class="anchor" id="a5142442d0d59524a47f604584040fdc1"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::updMobilizedBody" ref="a5142442d0d59524a47f604584040fdc1" args="(MobilizedBodyIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5142442d0d59524a47f604584040fdc1">SimTK::SimbodyMatterSubsystem::updMobilizedBody</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>, return a writable reference to the corresponding <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem. </p>
<p>This method will fail if the index is invalid or out of range. MobilizedBodyIndex(0) selects the Ground mobilized body. </p>

</div>
</div>
<a class="anchor" id="a20c4cdac747e672314c6aeda0a59e876"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getGround" ref="a20c4cdac747e672314c6aeda0a59e876" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a20c4cdac747e672314c6aeda0a59e876">SimTK::SimbodyMatterSubsystem::getGround</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a read-only (const) reference to the Ground <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem. </p>

</div>
</div>
<a class="anchor" id="a0851b330170f8e5a0700382ddf58bd22"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::updGround" ref="a0851b330170f8e5a0700382ddf58bd22" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22">SimTK::SimbodyMatterSubsystem::updGround</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a writable reference to the Ground <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem; you need a writable reference if you're adding a mobilized body that is directly connected to Ground. </p>

</div>
</div>
<a class="anchor" id="a7776baa71fc6d342f3140284b56553fb"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::Ground" ref="a7776baa71fc6d342f3140284b56553fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7776baa71fc6d342f3140284b56553fb">SimTK::SimbodyMatterSubsystem::Ground</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a synonym for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22" title="Return a writable reference to the Ground MobilizedBody within this matter subsystem; you need a writ...">updGround()</a> that makes for nicer-looking examples. </p>
<p>Note: topology is not marked invalid upon returning a writable reference here; that will be done only if a non-const method of the returned <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> is called. That means it is OK to use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7776baa71fc6d342f3140284b56553fb" title="This is a synonym for updGround() that makes for nicer-looking examples.">Ground()</a> to satisfy a const argument; it won't have an "invalidate topology" side effect. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22" title="Return a writable reference to the Ground MobilizedBody within this matter subsystem; you need a writ...">updGround()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8c97c52cb41b5be3aa6afe3915f9a331"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getConstraint" ref="a8c97c52cb41b5be3aa6afe3915f9a331" args="(ConstraintIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Constraint.html">Constraint</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8c97c52cb41b5be3aa6afe3915f9a331">SimTK::SimbodyMatterSubsystem::getConstraint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a>, return a read-only (const) reference to the corresponding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> within this matter subsystem. </p>
<p>This method will fail if the index is invalid or out of range. </p>

</div>
</div>
<a class="anchor" id="a85ca8b7eb162893128a6abc69d522e62"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::updConstraint" ref="a85ca8b7eb162893128a6abc69d522e62" args="(ConstraintIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Constraint.html">Constraint</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a85ca8b7eb162893128a6abc69d522e62">SimTK::SimbodyMatterSubsystem::updConstraint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a>, return a writable reference to the corresponding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> within this matter subsystem. </p>
<p>This method will fail if the index is invalid or out of range. </p>

</div>
</div>
<a class="anchor" id="a19657abf3c40de3bc74bede59f8b1f7d"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::setShowDefaultGeometry" ref="a19657abf3c40de3bc74bede59f8b1f7d" args="(bool show)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a19657abf3c40de3bc74bede59f8b1f7d">SimTK::SimbodyMatterSubsystem::setShowDefaultGeometry</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normally the matter subsystem will attempt to generate some decorative geometry as a sketch of the defined multibody system; you can disable that with this method. </p>

</div>
</div>
<a class="anchor" id="af29ad8515731d75d3e039b6d381ae860"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getShowDefaultGeometry" ref="af29ad8515731d75d3e039b6d381ae860" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af29ad8515731d75d3e039b6d381ae860">SimTK::SimbodyMatterSubsystem::getShowDefaultGeometry</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get whether this matter subsystem is set to generate default decorative geometry that can be used to visualize this multibody system. </p>

</div>
</div>
<a class="anchor" id="abd2d153469caadabcc34fcf60eb5e8c1"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getNumBodies" ref="abd2d153469caadabcc34fcf60eb5e8c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abd2d153469caadabcc34fcf60eb5e8c1">SimTK::SimbodyMatterSubsystem::getNumBodies</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of bodies includes all mobilized bodies <em>including</em> Ground, which is the 0th mobilized body. </p>
<p>(Note: if special particle handling were implmemented, the count here would <em>not</em> include particles.) Bodies and their inboard mobilizers have the same index since they are grouped together as a <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> numbering (using unique integer type <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>) starts with Ground at MobilizedBodyIndex(0) with a regular labeling such that children have higher indices than their parents. Ground does not have a mobilizer (or I suppose you could think of its mobilizer as the Weld joint that attaches it to the universe), but otherwise every mobilized body has a unique body and mobilizer. </p>

</div>
</div>
<a class="anchor" id="ad9348689e264c77ede60d222c7af8e00"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getNumConstraints" ref="ad9348689e264c77ede60d222c7af8e00" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad9348689e264c77ede60d222c7af8e00">SimTK::SimbodyMatterSubsystem::getNumConstraints</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the total number of defined constraints, each of which may generate more than one constraint equation. </p>
<p>This is the number of <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects that were defined; in a given <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> some of these may be disabled. </p>

</div>
</div>
<a class="anchor" id="a9e27f2490487cb16c8aaf09f20fea70b"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getNumMobilities" ref="a9e27f2490487cb16c8aaf09f20fea70b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9e27f2490487cb16c8aaf09f20fea70b">SimTK::SimbodyMatterSubsystem::getNumMobilities</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sum of all the mobilizer degrees of freedom. </p>
<p>This is also the length of the state variable vector u and the mobility forces array. </p>

</div>
</div>
<a class="anchor" id="ad52e47b213f5b60130fd13b6d154a9a3"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getTotalQAlloc" ref="ad52e47b213f5b60130fd13b6d154a9a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad52e47b213f5b60130fd13b6d154a9a3">SimTK::SimbodyMatterSubsystem::getTotalQAlloc</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sum of all the q vector allocations for each joint. </p>
<p>There may be some that are not in use for particular modeling options. </p>

</div>
</div>
<a class="anchor" id="a68644d94051594f5593a94936cad5f49"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getTotalMultAlloc" ref="a68644d94051594f5593a94936cad5f49" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a68644d94051594f5593a94936cad5f49">SimTK::SimbodyMatterSubsystem::getTotalMultAlloc</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the sum of all the allocations for constraint multipliers, one per acceleration constraint equation. </p>
<p>There may be some that are not in use due to the corresonding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> elements being disabled in a given <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. </p>

</div>
</div>
<a class="anchor" id="a59d3e416b8263877d3e599774554f78d"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::adoptMobilizedBody" ref="a59d3e416b8263877d3e599774554f78d" args="(MobilizedBodyIndex parent, MobilizedBody &amp;child)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a59d3e416b8263877d3e599774554f78d">SimTK::SimbodyMatterSubsystem::adoptMobilizedBody</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach new matter by attaching it to the indicated parent body (not normally called by users -- see <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>). </p>
<p>The mobilizer and mass properties are provided by <em>child</em>. A new <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> is assigned for the child; it is guaranteed to be numerically larger than the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of the parent. We take over ownership of <em>child's</em> implementation object from the given <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> handle, leaving that handle as a reference to the implementation object now owned by the matter subsystem. It is an error if the given <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> handle wasn't the owner of the implementation object to which it refers. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is usually called by concrete <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> constructors; it does not normally need to be called by end users. </dd></dl>

</div>
</div>
<a class="anchor" id="adf98f3426a2778ba1db81c5d76bccce2"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::adoptConstraint" ref="adf98f3426a2778ba1db81c5d76bccce2" args="(Constraint &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adf98f3426a2778ba1db81c5d76bccce2">SimTK::SimbodyMatterSubsystem::adoptConstraint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> object to the matter subsystem (not normally called by users -- see <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>). </p>
<p>The details of the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> are opaque here. A new <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a> is assigned. We take over ownership of the implementation object from the given <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> handle, leaving that handle as a reference to the implementation object now owned by the matter subsystem. It is an error if the given <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> handle wasn't the owner of the implementation object to which it refers. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is usually called by concrete <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> constructors; it does not normally need to be called by end users. </dd></dl>

</div>
</div>
<a class="anchor" id="a29e07d273b578e2d1ae9935de12da608"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::operator=" ref="a29e07d273b578e2d1ae9935de12da608" args="(const SimbodyMatterSubsystem &amp;ss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a>&amp; SimTK::SimbodyMatterSubsystem::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment is not very useful. </p>

</div>
</div>
<a class="anchor" id="a41930208004e6b3561c723c3cb5c3e47"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::setUseEulerAngles" ref="a41930208004e6b3561c723c3cb5c3e47" args="(State &amp;state, bool useEulerAngles) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a41930208004e6b3561c723c3cb5c3e47">SimTK::SimbodyMatterSubsystem::setUseEulerAngles</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useEulerAngles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For all mobilizers offering unrestricted orientation, decide what method we should use to model their orientations. </p>
<p>Choices are: quaternions (best for dynamics), or rotation angles (1-2-3 Euler sequence, good for optimization). Changing this flag invalidates Model stage and above in the supplied <em>state</em>, leaving it realized only through Topology stage, so you must call realizeModel() on the containing <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> prior to using this <em>state</em> in further calculations. </p>

</div>
</div>
<a class="anchor" id="af6a58f0c8f05f8f4416f78f9155ad726"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getUseEulerAngles" ref="af6a58f0c8f05f8f4416f78f9155ad726" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6a58f0c8f05f8f4416f78f9155ad726">SimTK::SimbodyMatterSubsystem::getUseEulerAngles</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current setting of the "use Euler angles" model variable as set in the supplied <em>state</em>. </p>

</div>
</div>
<a class="anchor" id="a6e504f192dc23ed1ba8493c2e10ff487"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getNumQuaternionsInUse" ref="a6e504f192dc23ed1ba8493c2e10ff487" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6e504f192dc23ed1ba8493c2e10ff487">SimTK::SimbodyMatterSubsystem::getNumQuaternionsInUse</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of quaternions in use by the mobilizers of this system, given the current setting of the "use Euler angles" flag in the supplied <em>state</em>, and the types of mobilizers in the multibody tree. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#addf67b644769842ff2ffea1c917ed149" title="Check whether a given mobilizer is currently using quaternions, based on the type of mobilizer and th...">isUsingQuaternion()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a133d88d5d60d466e8aea3d57a581d868" title="If the given mobilizer is currently using a quaternion to represent orientation, return the Quaternio...">getQuaternionPoolIndex()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="addf67b644769842ff2ffea1c917ed149"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::isUsingQuaternion" ref="addf67b644769842ff2ffea1c917ed149" args="(const State &amp;state, MobilizedBodyIndex mobodIx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#addf67b644769842ff2ffea1c917ed149">SimTK::SimbodyMatterSubsystem::isUsingQuaternion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mobodIx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether a given mobilizer is currently using quaternions, based on the type of mobilizer and the setting of the "use Euler angles" flag in the supplied <em>state</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6e504f192dc23ed1ba8493c2e10ff487" title="Return the number of quaternions in use by the mobilizers of this system, given the current setting o...">getNumQuaternionsInUse()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a133d88d5d60d466e8aea3d57a581d868" title="If the given mobilizer is currently using a quaternion to represent orientation, return the Quaternio...">getQuaternionPoolIndex()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a133d88d5d60d466e8aea3d57a581d868"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getQuaternionPoolIndex" ref="a133d88d5d60d466e8aea3d57a581d868" args="(const State &amp;state, MobilizedBodyIndex mobodIx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuaternionPoolIndex <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a133d88d5d60d466e8aea3d57a581d868">SimTK::SimbodyMatterSubsystem::getQuaternionPoolIndex</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mobodIx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the given mobilizer is currently using a quaternion to represent orientation, return the QuaternionPoolIndex (a small integer) assigned to that quaternion. </p>
<p>This is used, for example, to find which normalization constraint error is associated with which quaternion. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#addf67b644769842ff2ffea1c917ed149" title="Check whether a given mobilizer is currently using quaternions, based on the type of mobilizer and th...">isUsingQuaternion()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6e504f192dc23ed1ba8493c2e10ff487" title="Return the number of quaternions in use by the mobilizers of this system, given the current setting o...">getNumQuaternionsInUse()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a425f5ec3ca2e4e6aec7e03868acd5212"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::setConstraintIsDisabled" ref="a425f5ec3ca2e4e6aec7e03868acd5212" args="(State &amp;state, ConstraintIndex constraintIx, bool shouldDisableConstraint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a425f5ec3ca2e4e6aec7e03868acd5212">SimTK::SimbodyMatterSubsystem::setConstraintIsDisabled</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td>
          <td class="paramname"><em>constraintIx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldDisableConstraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable or enable the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> whose <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a> is supplied within the supplied <em>state</em>. </p>
<p>Whether a <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> is disabled is an Instance-stage state variable so enabling or disabling invalidates Instance stage and higher in the given <em>state</em>, leaving the <em>state</em> realized no higher than Model stage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa38fc5183b998cff87a6b1c1060a98e8" title="Determine whether a particular Constraint is currently disabled in the given state.">isConstraintDisabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa38fc5183b998cff87a6b1c1060a98e8"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::isConstraintDisabled" ref="aa38fc5183b998cff87a6b1c1060a98e8" args="(const State &amp;, ConstraintIndex constraint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa38fc5183b998cff87a6b1c1060a98e8">SimTK::SimbodyMatterSubsystem::isConstraintDisabled</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether a particular <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> is currently disabled in the given <em>state</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a425f5ec3ca2e4e6aec7e03868acd5212" title="Disable or enable the Constraint whose ConstraintIndex is supplied within the supplied state...">setConstraintIsDisabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a17c421e1c7e852aaac1ae445aab5254c"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::convertToEulerAngles" ref="a17c421e1c7e852aaac1ae445aab5254c" args="(const State &amp;inputState, State &amp;outputState) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a17c421e1c7e852aaac1ae445aab5254c">SimTK::SimbodyMatterSubsystem::convertToEulerAngles</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>inputState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>outputState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> which may be modeled using quaternions, copy it to another <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> which represents the same configuration using Euler angles instead. </p>
<p>If the <em>inputState</em> already uses Euler angles, the output will just be a duplicate. All continuous and discrete <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> variables will be copied to the <em>outputState</em> but they will not necessarily have been realized to the same level as the <em>inputState</em>. </p>

</div>
</div>
<a class="anchor" id="a315ae4d417d5ae95329a80f089402f25"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::convertToQuaternions" ref="a315ae4d417d5ae95329a80f089402f25" args="(const State &amp;inputState, State &amp;outputState) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a315ae4d417d5ae95329a80f089402f25">SimTK::SimbodyMatterSubsystem::convertToQuaternions</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>inputState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>outputState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> which may be modeled using Euler angles, copy it to another <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> which represents the same configuration using quaternions instead. </p>
<p>If the <em>inputState</em> already uses quaternions, the output will just be a duplicate. All continuous and discrete <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> variables will be copied to the <em>outputState</em> but they will not necessarily have been realized to the same level as the <em>inputState</em>. </p>

</div>
</div>
<a class="anchor" id="aa469a927676fdb154d90534b853691b6"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemMass" ref="aa469a927676fdb154d90534b853691b6" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa469a927676fdb154d90534b853691b6">SimTK::SimbodyMatterSubsystem::calcSystemMass</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the total system mass. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set.">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab46d1cd48be3eaaf4b4643d0bcdc1875"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemMassCenterLocationInGround" ref="ab46d1cd48be3eaaf4b4643d0bcdc1875" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab46d1cd48be3eaaf4b4643d0bcdc1875">SimTK::SimbodyMatterSubsystem::calcSystemMassCenterLocationInGround</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the position vector p_GC of the system mass center C, measured from the Ground origin, and expressed in Ground. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="abe382caff073488febe9e9a92cdfbb2f"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemMassPropertiesInGround" ref="abe382caff073488febe9e9a92cdfbb2f" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abe382caff073488febe9e9a92cdfbb2f">SimTK::SimbodyMatterSubsystem::calcSystemMassPropertiesInGround</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return total system mass, mass center location measured from the Ground origin, and system inertia taken about the Ground origin, expressed in Ground. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a0443924d9306417cac771ca85430d1f3"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemCentralInertiaInGround" ref="a0443924d9306417cac771ca85430d1f3" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0443924d9306417cac771ca85430d1f3">SimTK::SimbodyMatterSubsystem::calcSystemCentralInertiaInGround</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the system inertia matrix taken about the system center of mass, expressed in Ground. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a4d37fb1df3570860249e62310570e386"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemMassCenterVelocityInGround" ref="a4d37fb1df3570860249e62310570e386" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4d37fb1df3570860249e62310570e386">SimTK::SimbodyMatterSubsystem::calcSystemMassCenterVelocityInGround</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the velocity v_GC = d/dt p_GC of the system mass center C in the Ground frame G, measured from Ground origin and expressed in G. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae1d4611733f4b7dc9573cff5fb30c01b"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemMassCenterAccelerationInGround" ref="ae1d4611733f4b7dc9573cff5fb30c01b" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae1d4611733f4b7dc9573cff5fb30c01b">SimTK::SimbodyMatterSubsystem::calcSystemMassCenterAccelerationInGround</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the acceleration a_GC = d/dt p_GC of the system mass center C in the Ground frame G, measured from Ground origin and expressed in G. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated.">Stage::Acceleration</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6c5186727032683ee1c53fae6487c151"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemMomentumAboutGroundOrigin" ref="a6c5186727032683ee1c53fae6487c151" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6c5186727032683ee1c53fae6487c151">SimTK::SimbodyMatterSubsystem::calcSystemMomentumAboutGroundOrigin</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the momentum of the system as a whole (angular, linear) measured in the Ground frame, taken about the Ground origin and expressed in Ground. </p>
<p>(The linear component is independent of the "about" point.) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a63fcc8c4579ddd5860c16a27d2e88322" title="Return the momentum of the system as a whole (angular, linear) measured in the Ground frame...">calcSystemCentralMomentum()</a> </dd></dl>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a63fcc8c4579ddd5860c16a27d2e88322"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemCentralMomentum" ref="a63fcc8c4579ddd5860c16a27d2e88322" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a63fcc8c4579ddd5860c16a27d2e88322">SimTK::SimbodyMatterSubsystem::calcSystemCentralMomentum</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the momentum of the system as a whole (angular, linear) measured in the Ground frame, taken about the current system center of mass location C and expressed in Ground. </p>
<p>(The linear component is independent of the "about" point.) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6c5186727032683ee1c53fae6487c151" title="Return the momentum of the system as a whole (angular, linear) measured in the Ground frame...">calcSystemMomentumAboutGroundOrigin()</a> </dd></dl>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a31b65eb7fe180fd0904eae57d476f35e"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcKineticEnergy" ref="a31b65eb7fe180fd0904eae57d476f35e" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a31b65eb7fe180fd0904eae57d476f35e">SimTK::SimbodyMatterSubsystem::calcKineticEnergy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the total kinetic energy of all the mobilized bodies in this matter subsystem, given the configuration and velocities in <em>state</em>. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a3722e55e7b5923558bd3f1a0cf4a5f33"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyBySystemJacobian" ref="a3722e55e7b5923558bd3f1a0cf4a5f33" args="(const State &amp;state, const Vector &amp;u, Vector_&lt; SpatialVec &gt; &amp;Ju) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33">SimTK::SimbodyMatterSubsystem::multiplyBySystemJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ju</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) and a mobility-space vector u in O(n) time. </p>
<p>If the vector u is a set of generalized speeds, then this produces the body spatial velocities that result from those generalized speeds. That is, the result is V_GB = J*u where V_GB[i] is the spatial velocity of the i'th body's body frame origin (in Ground) that results from the given set of generalized speeds.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> compatible with this <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has already been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>A mobility-space Vector, such as a set of generalized speeds. The length and order must match the mobilities of this system (that is n, the number of generalized speeds u, <em>not</em> nq, the number of generalized coordinates q). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ju</td><td>This is the product V=J*u as described above. Each element is a spatial vector, one per mobilized body, to be indexed by <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>. If the input vector is a set of generalized speeds u, then the results are nb spatial velocities V_GBi (that is, a pair of vectors w_GBi and v_GBi giving angular and linear velocity). Note that Ground is body 0 so the 0th element V_GB0=V_GG=Ju[0] is always zero on return.</td></tr>
  </table>
  </dd>
</dl>
<p>The kinematic Jacobian (partial velocity matrix) J is defined as follows: </p>
<pre>
      partial(V)                                 T                        T
  J = ----------, V = [V_GB0 V_GB1 ... V_GB nb-1] ,  u = [u0 u1 ... u n-1]
      partial(u)
</pre><p> Thus the element J(i,j)=partial(V_GBi)/partial(uj) (each element of J is a spatial vector). The transpose of this matrix maps spatial forces to generalized forces; see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a>.</p>
<p>Note that we're using "monogram" notation for the spatial velocities, where </p>
<pre>
            G Bi
    V_GBi =  V
</pre><p> the spatial velocity of body i's body frame Bi (at its origin), measured and expressed in the Ground frame G.</p>
<h3>Performance discussion</h3>
<p>This is a very fast operator, costing about 12*(nb+n) flops, where nb is the number of bodies and n the number of mobilities (degrees of freedom) u. In contrast, even if you have already calculated the entire nbXnX6 matrix J, the multiplication J*u would cost 12*nb*n flops. As an example, for a 20 body system with a free flying base and 19 pin joints (25 dofs altogether), this method takes 12*(20+25)=540 flops while the explicit matrix-vector multiply would take 12*20*25=6000 flops. So this method is already &gt;10X faster for that small system; for larger systems the difference grows rapidly.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5563ca485168cb1c25d7ae34e27e8f2f" title="Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a ...">calcSystemJacobian()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43d9b54ce86f55165488b2dd270d5995"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForSystemJacobian" ref="a43d9b54ce86f55165488b2dd270d5995" args="(const State &amp;state, Vector_&lt; SpatialVec &gt; &amp;JDotu) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a43d9b54ce86f55165488b2dd270d5995">SimTK::SimbodyMatterSubsystem::calcBiasForSystemJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the acceleration bias term for the System Jacobian, that is, the part of the acceleration that is due only to velocities. </p>
<p>This term is also known as the Coriolis acceleration, and it is returned here as a spatial acceleration of each body frame in Ground.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has already been realized through Velocity stage. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JDotu</td><td>The product JDot*u where JDot = d/dt J, and u is the vector of generalized speeds taken from <em>state</em>. This is a Vector of nb SpatialVec elements.</td></tr>
  </table>
  </dd>
</dl>
<h3>Theory</h3>
<p>The spatial velocity V_GBi of each body i can be obtained from the generalized speeds u by V = {V_GBi} = J*u. Taking the time derivative in G gives </p>
<pre>
    A = d/dt V = {A_GBi} = J*udot + JDot*u
</pre><p> where JDot=JDot(q,u). This method returns JDot*u, which depends only on configuration q and speeds u. Note that the same u is used to calculate JDot, which is linear in u, so this term is quadratic in u.</p>
<h3>Implementation</h3>
<p>This method simply extracts the total Coriolis acceleration for each body that is already available in the <em>state</em> cache so there is no computation done here. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcf1b13d1c0b400dd41a77a80c840d30" title="This is the total coriolis acceleration including the effect of the parent&#39;s angular velocity as well...">getTotalCoriolisAcceleration()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6bb52c632fcccf14d051ff1be99cdb66"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForSystemJacobian" ref="a6bb52c632fcccf14d051ff1be99cdb66" args="(const State &amp;state, Vector &amp;JDotu) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a43d9b54ce86f55165488b2dd270d5995">SimTK::SimbodyMatterSubsystem::calcBiasForSystemJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>JDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature that returns the bias as a 6*nb-vector of scalars rather than as an nb-vector of 2x3 spatial vectors. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a class="anchor" id="ae2900f9febb57ef8deab114f37cb2342"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyBySystemJacobianTranspose" ref="ae2900f9febb57ef8deab114f37cb2342" args="(const State &amp;state, const Vector_&lt; SpatialVec &gt; &amp;F_G, Vector &amp;f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342">SimTK::SimbodyMatterSubsystem::multiplyBySystemJacobianTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial force-like elements, one per body, in O(n) time to produce a generalized force-like result f=~J*F. </p>
<p>If F_G is actually a set of spatial forces applied at the body frame origin of each body, and expressed in the Ground frame, then the result is the equivalent set of generalized forces f that would produce the same accelerations as F_G.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> compatible with this <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has already been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_G</td><td>This is a vector of SpatialVec elements, one per mobilized body and in order of <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> (with the 0th entry a force on Ground; hence ignored). Each SpatialVec is a spatial force-like pair of 3-vectors (torque,force) with the force applied at the body origin and the vectors expressed in Ground. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>This is the product f=~J*F_G as described above. This result is in the generalized force space, that is, it has one scalar entry for each of the n system mobilities (velocity degrees of freedom). Resized if necessary.</td></tr>
  </table>
  </dd>
</dl>
<p>The kinematic Jacobian (partial velocity matrix) J is defined as follows: </p>
<pre>
      partial(V)                                 T                        T
  J = ----------, V = [V_GB0 V_GB1 ... V_GB nb-1] ,  u = [u0 u1 ... u n-1]
      partial(u)
</pre><p> Thus the element J(i,j)=partial(V_GBi)/partial(uj) (each element of J is a spatial vector). J maps generalized speeds to spatial velocities (see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a>); its transpose ~J maps spatial forces to generalized forces.</p>
<p>Note that we're using "monogram" notation for the spatial velocities, where </p>
<pre>
            G Bi
    V_GBi =  V
</pre><p> the spatial velocity of body i's body frame Bi (at its origin), measured and expressed in the Ground frame G.</p>
<h3>Performance discussion</h3>
<p>This is a very fast operator, costing about 18*nb+11*n flops, where nb is the number of bodies and n the number of mobilities (degrees of freedom) u. In contrast, even if you have already calculated the entire 6*nbXnu matrix J, the multiplication ~J*F would cost 12*nb*n flops. As an example, for a 20 body system with a free flying base and 19 pin joints (25 dofs altogether), this method takes 18*20+11*25=635 flops while the explicit matrix-vector multiply would take 12*20*25=6000 flops. So this method is already &gt;9X faster for that small system; for larger systems the difference grows rapidly.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5563ca485168cb1c25d7ae34e27e8f2f" title="Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a ...">calcSystemJacobian()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5563ca485168cb1c25d7ae34e27e8f2f"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemJacobian" ref="a5563ca485168cb1c25d7ae34e27e8f2f" args="(const State &amp;state, Matrix_&lt; SpatialVec &gt; &amp;J_G) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5563ca485168cb1c25d7ae34e27e8f2f">SimTK::SimbodyMatterSubsystem::calcSystemJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>J_G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a 2x3 spatial vector (SpatialVec). </p>
<p>This matrix maps generalized speeds to the spatial velocities of all the bodies, which will be at the body origins, measured and expressed in Ground. That is, if you have a set of n generalized speeds u, you can find the spatial velocities of all nb bodies as V_G = J_G*u. The transpose of this matrix maps a set of spatial forces F_G, applied at the body frame origins and expressed in Ground, to the equivalent set of n generalized forces f: f = ~J_G*F_G.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The 0th row of the returned Jacobian is always zero since it represents the spatial velocity of Ground.</dd></dl>
<h3>Performance discussion</h3>
<p>Before using this method, consider whether you really need to form this very large matrix which necessarily will take O(n^2) space and time; it will almost always be <em>much</em> faster to use the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> method that directly calculate the matrix-vector product in O(n) time without explictly forming the matrix. Here are the details:</p>
<p>As currently implemented, forming the full Jacobian J costs about 12*n*(nb+n) flops. Assuming nb ~= n, this is about 24*n^2 flops. Then if you want to form a product J*u explicitly, the matrix-vector multiply will cost about 12*n^2 flops each time you do it. In contrast the J*u product is calculated using <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> in about 24*n flops. Even for very small systems it is cheaper to make repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> than to form J explicitly and multiply by it. See the Performance section for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> for more comparisons.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5563ca485168cb1c25d7ae34e27e8f2f" title="Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a ...">calcSystemJacobian()</a> alternate signature using scalar elements </dd></dl>

</div>
</div>
<a class="anchor" id="a26549e7484bfbe6eb8d7bc123e66259d"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcSystemJacobian" ref="a26549e7484bfbe6eb8d7bc123e66259d" args="(const State &amp;state, Matrix &amp;J_G) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5563ca485168cb1c25d7ae34e27e8f2f">SimTK::SimbodyMatterSubsystem::calcSystemJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>J_G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature that returns a system Jacobian as a 6*nb X n Matrix of scalars rather than as an nb X n matrix of 2x3 spatial vectors. </p>
<p>See the other signature for documentation and important performance considerations. </p>

</div>
</div>
<a class="anchor" id="a9b9920681595a75c69e2ba77c25cb934"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByStationJacobian" ref="a9b9920681595a75c69e2ba77c25cb934" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;stationPInB, const Vector &amp;u, Vector_&lt; Vec3 &gt; &amp;JSu) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9b9920681595a75c69e2ba77c25cb934">SimTK::SimbodyMatterSubsystem::multiplyByStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JSu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) that results from a particular set of generalized speeds u. </p>
<p>The result is the station velocities measured and expressed in Ground.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the stations of interest are fixed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stationPInB</td><td>The array of nt station points P of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its station P, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>A mobility-space Vector, such as a set of generalized speeds. The length and order must match the mobilities of this system (that is n, the number of generalized speeds u, <em>not</em> nq, the number of generalized coordinates q). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JSu</td><td>The resulting product JS*u, where JS is the station task Jacobian. Resized to nt if needed.</td></tr>
  </table>
  </dd>
</dl>
<h3>Performance discussion</h3>
<p>It is almost always better to use this method than to form an explicit 3*nt X n station task Jacobian explicitly and then multiply by it. If you have only one or two tasks, so that the matrix is only 3xn or 6xn, and then perform many multiplies with that matrix, it might be slightly cheaper to form it. For example, it is about 4X cheaper to use this method than to form a one-task Station Jacobian JS explicitly and use it once. However, because this would be such a skinny matrix (3 X n) explicit multiplication is cheap so if you will re-use this same Jacobian repeatedly before recalculating (at least 6 times) then it may be worth calculating and saving it. Here are the details:</p>
<p>A call to this method costs 27*nt + 12*(nb+n) flops. If you assume that nb ~= n &gt;&gt; 1, you could say this is about 27*nt + 24*n flops. In contrast, assuming you already have the 3*nt X n station Jacobian JS available, you can compute the JS*u product in about 6*nt*n flops, 3X faster for one task, about even for three tasks, and slower for more than three tasks. However forming JS costs about 40*nt+90*n flops (see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a84cc002312ec1dda2a7382a214253095" title="Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a...">calcStationJacobian()</a>). So to form a one-task Jacobian and use it once is 4X more expensive (96*n vs 24*n), but if you use it more than 5 times it is cheaper to do it explicitly. Forming a one-task JS and using it 100 times costs about 690*n flops while calling this method 100 times would cost about 2400*n flops.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a314427ba46921a0f31787bf1278e6a9e" title="Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (...">multiplyByStationJacobianTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a84cc002312ec1dda2a7382a214253095" title="Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a...">calcStationJacobian()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c7930b8c008e0699398a05e8fc6cb62"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByStationJacobian" ref="a9c7930b8c008e0699398a05e8fc6cb62" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;stationPInB, const Vector &amp;u) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9b9920681595a75c69e2ba77c25cb934">SimTK::SimbodyMatterSubsystem::multiplyByStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>JS*u, where JS is the station task Jacobian. </dd></dl>

</div>
</div>
<a class="anchor" id="a314427ba46921a0f31787bf1278e6a9e"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByStationJacobianTranspose" ref="a314427ba46921a0f31787bf1278e6a9e" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;stationPInB, const Vector_&lt; Vec3 &gt; &amp;f_GP, Vector &amp;f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a314427ba46921a0f31787bf1278e6a9e">SimTK::SimbodyMatterSubsystem::multiplyByStationJacobianTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_GP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (points fixed to bodies) P. </p>
<p>The applied forces f_GP should be 3-vectors expressed in Ground. This is considerably faster than forming the Jacobian explicitly and then performing the matrix-vector multiply.</p>
<h3>Performance discussion</h3>
<p>Cost is about 30*nt + 18*nb + 11*n. Assuming nb ~= n, this is roughly 30*(n+nt). In contrast, forming the complete 3*nt X n matrix would cost about 90*(n+nt/2), and subsequent explicit matrix-vector multiplies would cost about 6*nt*n each.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9b9920681595a75c69e2ba77c25cb934" title="Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) th...">multiplyByStationJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a84cc002312ec1dda2a7382a214253095" title="Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a...">calcStationJacobian()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a423ed4c2c53722921594aa7c4fc6ce17"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByStationJacobianTranspose" ref="a423ed4c2c53722921594aa7c4fc6ce17" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;stationPInB, const Vec3 &amp;f_GP, Vector &amp;f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a314427ba46921a0f31787bf1278e6a9e">SimTK::SimbodyMatterSubsystem::multiplyByStationJacobianTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>f_GP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>

</div>
</div>
<a class="anchor" id="a84cc002312ec1dda2a7382a214253095"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcStationJacobian" ref="a84cc002312ec1dda2a7382a214253095" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;stationPInB, Matrix_&lt; Vec3 &gt; &amp;JS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a84cc002312ec1dda2a7382a214253095">SimTK::SimbodyMatterSubsystem::calcStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a station is a point fixed on a particular mobilized body). </p>
<p>This matrix maps generalized speeds to the Cartesian velocity of each station, measured and expressed in Ground. That is, if you have a set of n generalized speeds u, you can find the Cartesian velocities of stations P as v_GP = JS*u, where v_GP is a 3*nt column vector. The transpose of this matrix maps a 3*nt vector of forces f_GP (expressed in Ground and applied to P) to the equivalent set of n generalized forces f: f = ~JS*f_GP.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is almost always far more efficient to use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9b9920681595a75c69e2ba77c25cb934" title="Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) th...">multiplyByStationJacobian()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a314427ba46921a0f31787bf1278e6a9e" title="Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (...">multiplyByStationJacobianTranspose()</a> to form matrix-vector products rather than to use this method to form the Jacobian explicitly. See the performance discussions there.</dd></dl>
<p>Overloaded signatures of this method are available to allow you to obtain the Jacobian either as an nt X n Matrix with Vec3 elements, or as 3*nt X n Matrix with scalar elements.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the stations of interest are fixed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stationPInB</td><td>The array of nt station points P of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its station P, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JS</td><td>The resulting nt X n station task Jacobian. Resized if necessary.</td></tr>
  </table>
  </dd>
</dl>
<h3>Performance discussion</h3>
<p>The cost of a call to this method is about 42*nt + 54*nb + 33*n flops. If we assume that nb ~= n &gt;&gt; 1, this is roughly 90*(n+nt/2) flops. Then once the Station Jacobian JS has been formed, each JS*u matrix-vector product costs 6*nt*n flops to form. When nt is small enough (say one or two tasks), and you plan to re-use it a lot, this can be computationally efficient; but for single use or more than a few tasks you can do much better with <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9b9920681595a75c69e2ba77c25cb934" title="Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) th...">multiplyByStationJacobian()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a314427ba46921a0f31787bf1278e6a9e" title="Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (...">multiplyByStationJacobianTranspose()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9b9920681595a75c69e2ba77c25cb934" title="Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) th...">multiplyByStationJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a314427ba46921a0f31787bf1278e6a9e" title="Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (...">multiplyByStationJacobianTranspose()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0f8546ca7e873b1d4377dd4b779f32ea"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcStationJacobian" ref="a0f8546ca7e873b1d4377dd4b779f32ea" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;stationPInB, RowVector_&lt; Vec3 &gt; &amp;JS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a84cc002312ec1dda2a7382a214253095">SimTK::SimbodyMatterSubsystem::calcStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1RowVector__.html">RowVector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>

</div>
</div>
<a class="anchor" id="a7b5db37321e8a62ff542bfb822668f4e"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcStationJacobian" ref="a7b5db37321e8a62ff542bfb822668f4e" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;stationPInB, Matrix &amp;JS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a84cc002312ec1dda2a7382a214253095">SimTK::SimbodyMatterSubsystem::calcStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>JS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature that returns a station Jacobian as a 3*nt x n Matrix rather than as a Matrix of Vec3 elements. </p>
<p>See the other signature for documentation and important performance considerations. </p>

</div>
</div>
<a class="anchor" id="a32199636039f7a63a6b4270b0f6a26be"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcStationJacobian" ref="a32199636039f7a63a6b4270b0f6a26be" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;stationPInB, Matrix &amp;JS) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a84cc002312ec1dda2a7382a214253095">SimTK::SimbodyMatterSubsystem::calcStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>JS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>

</div>
</div>
<a class="anchor" id="a86f1d50eba0046eeb21f7df2e5c933cc"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian" ref="a86f1d50eba0046eeb21f7df2e5c933cc" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;stationPInB, Vector_&lt; Vec3 &gt; &amp;JSDotu) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a86f1d50eba0046eeb21f7df2e5c933cc">SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JSDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the acceleration bias term for a station Jacobian, that is, the part of the station's acceleration that is due only to velocities. </p>
<p>This term is also known as the Coriolis acceleration, and it is returned here as a linear acceleration of the station in Ground.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has already been realized through Velocity stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the stations of interest are fixed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stationPInB</td><td>The array of nt station points P of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its station P, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JSDotu</td><td>The resulting product JSDot*u, where JSDot is the time derivative of JS, the station task Jacobian. Resized to nt if needed.</td></tr>
  </table>
  </dd>
</dl>
<h3>Theory</h3>
<p>The velocity v_GP of a station point P in the Ground frame G can be obtained from the generalized speeds u using the station Jacobian for P, as </p>
<pre>
    v_GP = JS_P*u
</pre><p> Taking the time derivative in G gives </p>
<pre>
    a_GP = JS_P*udot + JSDot_P*u
</pre><p> This method returns JSDot_P*u, which depends only on configuration and velocities. We allow for a set of task points P so that all their bias terms can be calculated in a single sweep of the multibody tree. Note that u is taken from the <em>state</em> and that the same u shown above is also used to calculate JSDot_P, which is linear in u, so the bias term is quadratic in u.</p>
<h3>Implementation</h3>
<p>This method just obtains body B's total Coriolis acceleration already available in the <em>state</em> cache and shifts it to station point P. Cost is 48*nt flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcf1b13d1c0b400dd41a77a80c840d30" title="This is the total coriolis acceleration including the effect of the parent&#39;s angular velocity as well...">getTotalCoriolisAcceleration()</a>, <a class="el" href="group__SpatialAlgebraUtilities.html#ga4cd275315e4cfd899f739fad664c1720" title="Shift a relative spatial acceleration measured at some point to that same relative spatial quantity b...">shiftAccelerationBy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a423d7d33800cb6b62509dd15abbdc1f2"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian" ref="a423d7d33800cb6b62509dd15abbdc1f2" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;stationPInB, Vector &amp;JSDotu) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a86f1d50eba0046eeb21f7df2e5c933cc">SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>JSDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature that returns the bias as a 3*nt-vector of scalars rather than as an nt-vector of Vec3s. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a class="anchor" id="aff992b923c429d78a922d71d15b8f491"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian" ref="aff992b923c429d78a922d71d15b8f491" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;stationPInB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a86f1d50eba0046eeb21f7df2e5c933cc">SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>JSDot*u, where JSDot is the station Jacobian time derivative. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b7b4e350aabedbef00ff1ec35e81d3b"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobian" ref="a4b7b4e350aabedbef00ff1ec35e81d3b" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;originAoInB, const Vector &amp;u, Vector_&lt; SpatialVec &gt; &amp;JFu) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b7b4e350aabedbef00ff1ec35e81d3b">SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JFu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}, that result from a particular set of n generalized speeds u. </p>
<p>The result is each task frame's angular and linear velocity measured and expressed in Ground. Using this method is considerably faster than forming the 6*nt X n Frame Jacobian explicitly and then performing the matrix-vector multiply. See the performance analysis below for details.</p>
<p>There is a simplified signature of this method available if you have only a single frame task.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the task frames of interest are fixed. These may be in any order and the same body may appear more than once if there are multiple task frames on it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">originAoInB</td><td>An array of nt frame origin points Ao for the task frames interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its task frame origin Ao, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>A mobility-space Vector, such as a set of generalized speeds. The length and order must match the mobilities of this system (that is n, the number of generalized speeds u, <em>not</em> nq, the number of generalized coordinates q). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JFu</td><td>The resulting product JF*u, where JF is the frame task Jacobian. Resized if needed to a Vector of nt SpatialVec entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>All frames A fixed to a given body B have the same angular velocity so we do not actually need to know the task frames' orientations here, just the location on B of their origin points Ao. If you have a Transform X_BA giving the pose of frame A in the body frame B, you can extract the position vector for the origin point Ao using X_BA.p() and pass that as the <em>originAoInB</em> parameter here.</dd></dl>
<h3>Performance discussion</h3>
<p>A call to this method costs 27*nt + 12*(nb+n) flops. If you assume that nb ~= n &gt;&gt; 1, you could say this is about 25*(nt+n) flops. In contrast, assuming you already have the 6*nt X n Frame Jacobian JF available, you can compute the JF*u product in about 12*nt*n flops. If you have just one task (nt==1) this explicit multiplication is about twice as fast; at two tasks it is about even and for more than two it is more expensive. However forming JF costs about 180*(n+nt/4) flops (see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657" title="Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai...">calcFrameJacobian()</a>). So to form a one-task Jacobian and use it once is almost 8X more expensive (192*n vs 25*n), but if you use it more than 16 times it is (marginally) cheaper to do it explicitly (for one task). For example, forming a one-task JF and using it 100 times costs 1392*n flops while calling this method 100 times would cost about 2500*n flops.</p>
<p>Conclusion: in almost all practical cases you are better off using this operator rather than forming JF, even if you have only a single frame task and certainly if you have more than two tasks.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7c49a55eba4badde996dd789bad1a8a" title="Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi.">multiplyByFrameJacobianTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657" title="Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai...">calcFrameJacobian()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b20283e113f7a36eba47b25c80f9cb8"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobian" ref="a8b20283e113f7a36eba47b25c80f9cb8" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;originAoInB, const Vector &amp;u) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b7b4e350aabedbef00ff1ec35e81d3b">SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplified signature for when you just have a single frame task; see the main signature for documentation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>JF*u, where JF is the single frame task Jacobian. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7c49a55eba4badde996dd789bad1a8a"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobianTranspose" ref="ad7c49a55eba4badde996dd789bad1a8a" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;originAoInB, const Vector_&lt; SpatialVec &gt; &amp;F_GAo, Vector &amp;f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7c49a55eba4badde996dd789bad1a8a">SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobianTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_GAo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi. </p>
<p>The applied forces are spatial vectors (pairs of 3-vectors) expressed in Ground. Use of this O(n) method is considerably faster than forming the 6*nt X n Jacobian explicitly and then performing an O(n^2) matrix-vector multiply.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the task frames of interest are fixed. These may be in any order and the same body may appear more than once if there are multiple task frames on it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">originAoInB</td><td>An array of nt frame origin points Ao for the task frames interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its task frame origin Ao, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_GAo</td><td>A Vector of nt spatial forces, each applied one of the task frames. These are expressed in Ground. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>The Vector of n generalized forces that results from applying the forces <em>F_GAo</em> to the task frames. Resized if necessary.</td></tr>
  </table>
  </dd>
</dl>
<h3>Performance discussion</h3>
<p>A call to this method costs 33*nt + 18*nb + 11*n flops. If you assume that nb ~= n &gt;&gt; 1, you could say this is about 30*(n+nt) flops. In contrast, assuming you already have the 6*nt X n Frame Jacobian JF available, you can compute the ~JF*F product in about 12*nt*n flops. For one or two tasks that would be faster than applying the operator. However forming JF costs about 180*(n+nt/4) flops (see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657" title="Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai...">calcFrameJacobian()</a>). So to form even a one-task Frame Jacobian and use it once is about 6X more expensive than using the operator (192*n vs 30*n), but if you use it more than 10 times it is (marginally) cheaper to do it explicitly. For example, forming a one-task JF and using it 100 times costs around 1392*n flops while calling this method 100 times would cost about 3000*n flops.</p>
<p>Conclusion: in almost all practical cases you are better off using this operator rather than forming JF, even if you have only a single frame task and certainly if you have more than two tasks.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b7b4e350aabedbef00ff1ec35e81d3b" title="Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}...">multiplyByFrameJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657" title="Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai...">calcFrameJacobian()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a19548c59a4769a51109ec7c57e65fd08"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobianTranspose" ref="a19548c59a4769a51109ec7c57e65fd08" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;originAoInB, const SpatialVec &amp;F_GAo, Vector &amp;f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7c49a55eba4badde996dd789bad1a8a">SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobianTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>F_GAo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplified signature for when you just have a single frame task. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a class="anchor" id="a741150aaf33c1b667067b11f3cb59657"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcFrameJacobian" ref="a741150aaf33c1b667067b11f3cb59657" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;originAoInB, Matrix_&lt; SpatialVec &gt; &amp;JF) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657">SimTK::SimbodyMatterSubsystem::calcFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai} fixed to nt bodies B={Bi}. </p>
<p>This matrix maps generalized speeds to the Cartesian spatial velocity (angular and linear velocity) of each frame, measured and expressed in Ground. That is, if you have a set of n generalized speeds u, you can find the Cartesian spatial velocities of task frames A as V_GA = JF*u, where V_GA is a 6*nt column vector. The transpose of this matrix maps a 6*nt vector of spatial forces F_GA (expressed in Ground and applied to the origins of frames A) to the equivalent set of n generalized forces f: f = ~JF*F_GA.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is almost always far more efficient to use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b7b4e350aabedbef00ff1ec35e81d3b" title="Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}...">multiplyByFrameJacobian()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7c49a55eba4badde996dd789bad1a8a" title="Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi.">multiplyByFrameJacobianTranspose()</a> to form matrix-vector products rather than to use this method to form the Jacobian explicitly. See the performance discussion there.</dd></dl>
<p>Overloaded signatures of this method are available to allow you to obtain the Jacobian either as an nt X n Matrix with SpatialVec elements, or as 6*nt X n Matrix with scalar elements.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the task frames of interest are fixed. These may be in any order and the same body may appear more than once if there are multiple task frames on it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">originAoInB</td><td>An array of nt frame origin points Ao for the task frames of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its task frame origin Ao, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JF</td><td>The resulting nt X n frame task Jacobian, with each element a SpatialVec. Resized if necessary.</td></tr>
  </table>
  </dd>
</dl>
<h3>Performance discussion</h3>
<p>The cost of a call to this method is about 42*nt + 108*nb + 66*n flops. If we assume that nb ~= n &gt;&gt; 1, this is roughly 180*(n+nt/4) flops. Then once the Frame Jacobian JF has been formed, each JF*u matrix-vector product costs about 12*nt*n flops to form. When nt is small enough (say one or two tasks), and you plan to re-use it a lot, this can be computationally efficient; but for single use or more than a few tasks you can do much better with <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b7b4e350aabedbef00ff1ec35e81d3b" title="Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}...">multiplyByFrameJacobian()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7c49a55eba4badde996dd789bad1a8a" title="Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi.">multiplyByFrameJacobianTranspose()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b7b4e350aabedbef00ff1ec35e81d3b" title="Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}...">multiplyByFrameJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7c49a55eba4badde996dd789bad1a8a" title="Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi.">multiplyByFrameJacobianTranspose()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9502959cb6062ea34dfff2bdcba570fc"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcFrameJacobian" ref="a9502959cb6062ea34dfff2bdcba570fc" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;originAoInB, RowVector_&lt; SpatialVec &gt; &amp;JF) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657">SimTK::SimbodyMatterSubsystem::calcFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1RowVector__.html">RowVector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplified signature for when you just have a single frame task. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a class="anchor" id="a9e5e88fa9c29c900d479bc52cd7fe659"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcFrameJacobian" ref="a9e5e88fa9c29c900d479bc52cd7fe659" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;originAoInB, Matrix &amp;JF) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657">SimTK::SimbodyMatterSubsystem::calcFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>JF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature that returns a frame Jacobian as a 6*nt X n Matrix rather than as an nt X n Matrix of SpatialVecs. </p>
<p>See the other signature for documentation and important performance considerations. </p>

</div>
</div>
<a class="anchor" id="aeace3f635f35b438f32b217a4fd85b75"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcFrameJacobian" ref="aeace3f635f35b438f32b217a4fd85b75" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;originAoInB, Matrix &amp;JF) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a741150aaf33c1b667067b11f3cb59657">SimTK::SimbodyMatterSubsystem::calcFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>JF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplified signature for when you just have a single frame task. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a class="anchor" id="a8cc4e782538d519014c70b83d4a6e984"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian" ref="a8cc4e782538d519014c70b83d4a6e984" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;originAoInB, Vector_&lt; SpatialVec &gt; &amp;JFDotu) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8cc4e782538d519014c70b83d4a6e984">SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JFDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the acceleration bias term for a task frame Jacobian, that is, the parts of the frames' accelerations that are due only to velocities. </p>
<p>This term is also known as the Coriolis acceleration, and it is returned here as spatial accelerations of the frames in Ground.</p>
<p>There is a simplified signature of this method available if you have only a single frame task.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has already been realized through Velocity stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the task frames of interest are fixed. These may be in any order and the same body may appear more than once if there are multiple task frames on it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">originAoInB</td><td>An array of nt frame origin points Ao for the task frames interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its task frame origin Ao, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JFDotu</td><td>The result JFDot*u, where JF is the task frame Jacobian and JFDot its time derivative, and u is the set of generalized speeds taken from the the supplied <em>state</em>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Theory</h3>
<p>The spatial velocity V_GA of frame A can be obtained from the generalized speeds u using the frame Jacobian for A, as V_GA = JF*u. Taking the time derivative in G gives </p>
<pre>
    A_GA = JF*udot + JFDot*u
</pre><p> This method returns JFDot*u, which depends only on configuration and velocities. Note that the same u is used to calculate JFDot, which is linear in u, so the term JFDot*u is quadratic in u.</p>
<h3>Implementation</h3>
<p>This method just obtains body B's total Coriolis acceleration already available in the <em>state</em> cache and shifts it to the A frame's origin Ao, for each of the nt task frames. Cost is 48*nt flops.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcf1b13d1c0b400dd41a77a80c840d30" title="This is the total coriolis acceleration including the effect of the parent&#39;s angular velocity as well...">getTotalCoriolisAcceleration()</a>, <a class="el" href="group__SpatialAlgebraUtilities.html#ga4cd275315e4cfd899f739fad664c1720" title="Shift a relative spatial acceleration measured at some point to that same relative spatial quantity b...">shiftAccelerationBy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a242d51ecff031b7b74e9beada96be6f7"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian" ref="a242d51ecff031b7b74e9beada96be6f7" args="(const State &amp;state, const Array_&lt; MobilizedBodyIndex &gt; &amp;onBodyB, const Array_&lt; Vec3 &gt; &amp;originAoInB, Vector &amp;JFDotu) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8cc4e782538d519014c70b83d4a6e984">SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>JFDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate signature that returns the bias as a 6*nt-vector of scalars rather than as an nt-vector of SpatialVec elements. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a class="anchor" id="a180d39d0a828fd7dcaf39581fd2ed309"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian" ref="a180d39d0a828fd7dcaf39581fd2ed309" args="(const State &amp;state, MobilizedBodyIndex onBodyB, const Vec3 &amp;originAoInB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8cc4e782538d519014c70b83d4a6e984">SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplified signature for when you just have a single frame task. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>JFDot*u, where JFDot is the frame task Jacobian time derivative and u the generalized speeds taken from <em>state</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a343dc68594d7afe04762db67a3ca68a9"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByM" ref="a343dc68594d7afe04762db67a3ca68a9" args="(const State &amp;state, const Vector &amp;a, Vector &amp;Ma) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a343dc68594d7afe04762db67a3ca68a9">SimTK::SimbodyMatterSubsystem::multiplyByM</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a supplied mobility-space vector (that is, it has one entry for each of the n mobilities). </p>
<p>If v is a set of mobility accelerations (generalized accelerations udot), then the result is a generalized force (f=M*udot). Only the supplied vector is used, and M depends only on position states, so the result here is not affected by velocities in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. Constraints and prescribed motions are ignored.</p>
<p>The current implementation requires about 120*n flops and does not require realization of composite-body or articulated-body inertias. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="aeb30ad8dd2dfd5981de9681fa8ac7f43"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByMInv" ref="aeb30ad8dd2dfd5981de9681fa8ac7f43" args="(const State &amp;state, const Vector &amp;v, Vector &amp;MinvV) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeb30ad8dd2dfd5981de9681fa8ac7f43">SimTK::SimbodyMatterSubsystem::multiplyByMInv</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>MinvV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a supplied vector with one entry per u-space mobility. </p>
<p>If v is a set of generalized forces f, the result is a generalized acceleration (udot=M^-1*f). Only the supplied vector is used, and M depends only on position states, so the result here is not affected by velocities in <em>state</em>. In particular, you'll have to obtain your own inertial forces and put them in f if you want them included.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>This is a <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has been realized through Position stage, from which the current system configuration and articulated body inertias are obtained. If necessary, the articulated body inertias will be realized in the state the first time this is called. They will then be retained in the <em>state</em> cache for speed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>This is a generalized-force like vector in mobility space (u-space). If there is any prescribed motion specified using <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or mobilizer locking (see below), then only the entries of v corresponding to non-prescribed mobilities are examined by this method; the prescribed ones are not referenced at all. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MinvV</td><td>This is the result M^-1*v. If there is any prescribed motion specified using <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or mobilizer locks (see below), then only the non-prescribed entries in MinvV are calculated; the prescribed ones are set to zero.</td></tr>
  </table>
  </dd>
</dl>
<h3>Behavior with prescribed motion</h3>
<p>If you prescribe the motion of one or more mobilizers using <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or mobilizer locking, the behavior of this method is altered. (This does <em>not</em> apply if you use <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects to specify the motion.) With prescribed motion enabled, this method works only with the free (non-prescribed) mobilities. Only the entries in <em>v</em> corresponding to free mobilities are examined, and only the entries in the result <em>MinvV</em> corresponding to free mobilities are calculated; the others are set to zero.</p>
<h3>Theory</h3>
<p>View the unconstrained, prescribed zero-velocity equations of motion M udot + tau = f as partitioned into "free" and "prescribed" variables like this: </p>
<pre>
    [M_ff ~M_fp] [udot_f]   [ 0 ]   [f_f]
    [          ] [      ] + [   ] = [   ]
    [M_fp  M_pp] [udot_p]   [tau]   [f_p]
</pre><p> The free and prescribed variables have been grouped here for clarity but in general they are interspersed among the columns and rows of M.</p>
<p>Given that decomposition, this method returns </p>
<pre>
    [udot_f]   [udot_f]   [M_ff^-1  0  ][f_f]
    [      ] = [      ] = [            ][   ]
    [udot_p]   [  0   ]   [   0     0  ][f_p]
</pre><p> When there is no prescribed motion M_ff is the entire mass matrix, and the result is udot_f=udot=M^-1*f. When there is prescribed motion, M_ff is a submatrix of M, and the result is the nf elements of udot_f, with udot_p=0.</p>
<h3>Implementation</h3>
<p>This is a stripped-down version of forward dynamics. It requires the hybrid free/prescribed articulated body inertias to have been realized and will initiate that calculation if necessary the first time it is called for a given configuration q. The M^-1*f calculation requires two sweeps of the multibody tree, an inward sweep to accumulate forces, followed by an outward sweep to propagate accelerations.</p>
<h3>Performance</h3>
<p>If the supplied <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> does not already contain realized values for the articulated body inertias, then they will be realized when this operator is first called for a new set of positions. Calculating articulated body inertias is O(n) but relatively expensive. Once the appropriate articulated body inertias are available, repeated calls to this operator are very fast, with worst case around 80*n flops when all mobilizers have 1 dof. If you want to force realization of the articulated body inertias, call the method <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab91faf31bae6a4bea3ae495b887a473d" title="This method checks whether articulated body inertias have already been computed since the last change...">realizeArticulatedBodyInertias()</a>.</p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a343dc68594d7afe04762db67a3ca68a9" title="This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a su...">multiplyByM()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a564e87359d2689137a43f85c3e861690" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab91faf31bae6a4bea3ae495b887a473d" title="This method checks whether articulated body inertias have already been computed since the last change...">realizeArticulatedBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af297a2c82bb19a9deae10bb8f873f9f9"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcM" ref="af297a2c82bb19a9deae10bb8f873f9f9" args="(const State &amp;, Matrix &amp;M) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af297a2c82bb19a9deae10bb8f873f9f9">SimTK::SimbodyMatterSubsystem::calcM</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This operator explicitly calculates the n X n mass matrix M. </p>
<p>Note that this is inherently an O(n^2) operation since the mass matrix has n^2 elements (although only n(n+1)/2 are unique due to symmetry). <em>DO NOT USE THIS CALL DURING NORMAL DYNAMICS</em>. To do so would change an O(n) operation into an O(n^2) one. Instead, see if you can accomplish what you need with O(n) operators like <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a343dc68594d7afe04762db67a3ca68a9" title="This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a su...">multiplyByM()</a> which calculates the matrix-vector product M*v in O(n) without explicitly forming M. Also, don't invert this matrix numerically to get M^-1. Instead, call the method <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a564e87359d2689137a43f85c3e861690" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a> which can produce M^-1 directly. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a343dc68594d7afe04762db67a3ca68a9" title="This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a su...">multiplyByM()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a564e87359d2689137a43f85c3e861690" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a564e87359d2689137a43f85c3e861690"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcMInv" ref="a564e87359d2689137a43f85c3e861690" args="(const State &amp;, Matrix &amp;MInv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a564e87359d2689137a43f85c3e861690">SimTK::SimbodyMatterSubsystem::calcMInv</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>MInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix corresponding to free (non-prescribed) mobilities. </p>
<p>The returned matrix is always n X n, but rows and columns corresponding to prescribed mobilities are zero. This is an O(n^2) operation, which is of course within a constant factor of optimal for returning a matrix with n^2 elements explicitly. (There are actually only n(n+1)/2 unique elements since the matrix is symmetric.) <em>DO NOT USE THIS CALL DURING NORMAL DYNAMICS</em>. To do so would change an O(n) operation into an O(n^2) one. Instead, see if you can accomplish what you need with O(n) operators like <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeb30ad8dd2dfd5981de9681fa8ac7f43" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> which calculates the matrix-vector product M^-1*v in O(n) without explicitly forming M or M^-1. If you need M explicitly, you can get it with the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af297a2c82bb19a9deae10bb8f873f9f9" title="This operator explicitly calculates the n X n mass matrix M.">calcM()</a> method. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeb30ad8dd2dfd5981de9681fa8ac7f43" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af297a2c82bb19a9deae10bb8f873f9f9" title="This operator explicitly calculates the n X n mass matrix M.">calcM()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af567d109f8e6705eaa9835b9309c6f03"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcProjectedMInv" ref="af567d109f8e6705eaa9835b9309c6f03" args="(const State &amp;s, Matrix &amp;GMInvGt) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af567d109f8e6705eaa9835b9309c6f03">SimTK::SimbodyMatterSubsystem::calcProjectedMInv</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>GMInvGt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This operator calculates in O(m*n) time the m X m "projected inverse mass 
matrix" or "constraint compliance matrix" W=G*M^-1*~G, where G (mXn) is the acceleration-level constraint Jacobian mapped to generalized coordinates, and M (nXn) is the unconstrained system mass matrix. </p>
<p>In case there is prescribed motion specified with <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or mobilizer locking, M^-1 here is really M_ff^-1, that is, it is restricted to the free (non-prescribed) mobilities, but scattered into a full n X n matrix (conceptually). See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeb30ad8dd2dfd5981de9681fa8ac7f43" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> and <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a564e87359d2689137a43f85c3e861690" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a> for more information.</p>
<p>W is the projection of the inverse mass matrix into the constraint coordinate space (that is, the vector space of the multipliers lambda). It can be used to solve for the constraint forces that will eliminate a given constraint acceleration error: </p>
<pre>
    (1)     W * lambda = aerr
    (2)     aerr = G*udot - b(t,q,u)
</pre><p> where udot is an unconstrained generalized acceleration. Note that you can view equation (1) as a dynamic system in a reduced set of m generalized coordinates, with the caveat that W may be singular.</p>
<p>In general W is singular and does not uniquely determine lambda. Simbody normally calculates a least squares solution for lambda so that loads are distributed among redundant constraints.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you just need to multiply W by a vector or matrix, you do not need to form W explicitly. Instead you can use the method described in the Implementation section to produce a W*v product in the O(n) time it takes to compute a single column of W.</dd></dl>
<h3>Implementation</h3>
<p>We are able to form W without forming G or M^-1 and without performing any matrix-matrix multiplies. Instead, W is calculated using m applications of O(n) operators:</p>
<ul>
<li><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d2451d87d7cae837062cd9a036bf698" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a> by a unit vector to form a column of ~G</li>
<li><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeb30ad8dd2dfd5981de9681fa8ac7f43" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> to form a column of M^-1 ~G</li>
<li><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a> to form a column of W</li>
</ul>
<p>Even if G and M^-1 were already available, computing W by matrix multiplication would cost O(m^2*n + m*n^2) time and O(m*n) intermediate storage. Here we do it in O(m*n) time with O(n) intermediate storage, which is a <em>lot</em> better.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9ccc3ce0e76fbc65aeb480ef73d603db" title="This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which a...">calcG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d2451d87d7cae837062cd9a036bf698" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0f04f21d4d1fe85c830f71d60995a799" title="This O(nm) operator explicitly calculates the n X m transpose of the acceleration-level constraint Ja...">calcGTranspose()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeb30ad8dd2dfd5981de9681fa8ac7f43" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a564e87359d2689137a43f85c3e861690" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad7316d38fe5ba9237cab137011b10c21"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::solveForConstraintImpulses" ref="ad7316d38fe5ba9237cab137011b10c21" args="(const State &amp;state, const Vector &amp;deltaV, Vector &amp;impulse) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7316d38fe5ba9237cab137011b10c21">SimTK::SimbodyMatterSubsystem::solveForConstraintImpulses</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>deltaV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>impulse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of desired constraint-space speed changes, calculate the corresponding constraint-space impulses that would cause those changes. </p>
<p>Here we are solving the equation </p>
<pre>
    W * impulse = deltaV
</pre><p> for <em>impulse</em>, where W=G*M^-1*~G is the "projected inverse mass matrix" as described for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af567d109f8e6705eaa9835b9309c6f03" title="This operator calculates in O(m*n) time the m X m &quot;projected inverse mass  matrix&quot; or &quot;constraint com...">calcProjectedMInv()</a>. In general W is singular due to constraint redundancies, so the solution for <em>impulse</em> is not unique. Simbody handles redundant constraints by finding least squares solutions, and this operator method duplicates the method Simbody uses for determining the rank and performing the factorization of W.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> whose generalized coordinates and speeds define the matrix W. Must already be realized to Dynamics stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deltaV</td><td>The set of desired velocity changes to be produced by the impulse, in constraint space. These will consist of observed velocity constraint violations (-verr) and constraint violations that would be generated by impulsive applied forces (-G*M^-1*f). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">impulse</td><td>The set of constraint multiplier-space impulses that will produce the desired velocity changes without violating the constraints.</td></tr>
  </table>
  </dd>
</dl>
<p>To convert these constraint-space impulses into updates to the mobility-space generalized speeds u, use code like this: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">const</span> <a class="code" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b5ec5c33a93af6d9e3a8ebc6bf37b51" title="Create an orphan matter subsystem containing only the Ground body (mobilized body 0); normally use th...">SimbodyMatterSubsystem</a>&amp; matter=...;
    <a class="code" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f" title="Read fixed-size VectorView from input stream.">Vector</a> deltaV=...;  <span class="comment">// constraint space speed change desired; length m</span>
    <a class="code" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f" title="Read fixed-size VectorView from input stream.">Vector</a> impulse;     <span class="comment">// constraint space impulses; length m</span>
    <a class="code" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad7316d38fe5ba9237cab137011b10c21" title="Given a set of desired constraint-space speed changes, calculate the corresponding constraint-space i...">solveForConstraintImpulses</a>(state, deltaV, impulse);
    <a class="code" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f" title="Read fixed-size VectorView from input stream.">Vector</a> f;           <span class="comment">// mobility space impulses; length n</span>
    <a class="code" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f" title="Read fixed-size VectorView from input stream.">Vector</a> du;          <span class="comment">// change to generalized speeds u; length n</span>
    matter.multiplyByGTranspose(s,impulse,f);
    matter.multiplyByMInv(s,f,du);
    state.updU() += du; <span class="comment">// update generalized speeds</span>
</pre></div><p>Note that the length of the constraint-space vectors is m=mp+mv+ma, the total number of acceleration-level constraints including the second time derivatives of the position (holonomic) constraints, the first time derivatives of the velocity (nonholonomic) constraints, and the acceleration-only constraints. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af567d109f8e6705eaa9835b9309c6f03" title="This operator calculates in O(m*n) time the m X m &quot;projected inverse mass  matrix&quot; or &quot;constraint com...">calcProjectedMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d2451d87d7cae837062cd9a036bf698" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aeb30ad8dd2dfd5981de9681fa8ac7f43" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a90a34ce745cbf5a0bf34f4a62d9ddb2e"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByG" ref="a90a34ce745cbf5a0bf34f4a62d9ddb2e" args="(const State &amp;state, const Vector &amp;ulike, Vector &amp;Gulike) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e">SimTK::SimbodyMatterSubsystem::multiplyByG</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>ulike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Gulike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a "u-like" (mobility space) vector of length n. </p>
<p>m is the number of active acceleration-level constraint equations, n is the number of mobilities. This is an O(m+n) operation.</p>
<p>If you are going to call this method repeatedly at the same time, positions and velocities, you should precalculate the bias term once and supply it to the alternate signature of this method. See the Implementation section for more information.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> realized to Velocity stage </dd></dl>
<dl class="user"><dt><b>Implementation</b></dt><dd>This is accomplished by treating the input vector <em>ulike</em> as though it were a set of generalized accelerations (for nonholonomic and acceleration-only constraints) or generalized speeds (for holonomic constraints). These are mapped to body accelerations (or velocities) in O(n) time. See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a94d275630d490646b6eed0c1ed392c6d" title="Given a complete set of n generalized accelerations udot, this kinematic operator calculates in O(n) ...">calcBodyAccelerationFromUDot()</a> for more information (converting from generalized speeds to velocities is just multiplying by the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> Jacobian). The method <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9d7d060109d5f1ca2090d23e2d40db57" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByG() method abo...">calcBiasForMultiplyByG()</a> is used to determine the state-dependent term of the constraint error equations. Then a second call is made to evaluate the bias term aerr(t,q,u;0)=-b(t,q,u). We then calculate Gulike = aerr(t,q,u;ulike)-aerr(t,q,u;0) in O(m) time. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9d7d060109d5f1ca2090d23e2d40db57" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByG() method abo...">calcBiasForMultiplyByG()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae939c33c0491867cecc55d0c0748441b"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByG" ref="ae939c33c0491867cecc55d0c0748441b" args="(const State &amp;state, const Vector &amp;ulike, const Vector &amp;bias, Vector &amp;Gulike) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e">SimTK::SimbodyMatterSubsystem::multiplyByG</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>ulike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Gulike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply Gulike=G*ulike using the supplied precalculated bias vector to improve performance (approximately 2X) over the other signature. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9d7d060109d5f1ca2090d23e2d40db57" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByG() method abo...">calcBiasForMultiplyByG()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9d7d060109d5f1ca2090d23e2d40db57"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForMultiplyByG" ref="a9d7d060109d5f1ca2090d23e2d40db57" args="(const State &amp;state, Vector &amp;bias) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9d7d060109d5f1ca2090d23e2d40db57">SimTK::SimbodyMatterSubsystem::calcBiasForMultiplyByG</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the bias vector needed for the higher-performance signature of the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a> method above. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Provides time t, positions q, and speeds u; must be realized through Velocity stage so that all body spatial velocities are known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bias</td><td>This is the bias vector for use in repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>. It will be resized if necessary to length m=mp+mv+ma, the total number of active acceleration-level constraint equations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> realized to Velocity stage </dd></dl>
<dl class="user"><dt><b>Implementation</b></dt><dd>This method uses either velocity- or acceleration- level constraint error functions with zero input to determine the bias term for use in <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>. <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> quantities and generalized quantities are supplied to each of the m active constraints' (constant time) error methods to calculate <pre>
   pverr(t,q,u;ulike)=G*ulike - c(t,q)    (holonomic) 
or aerr(t,q,u;ulike)=G*ulike - b(t,q,u)   (nonholonomic or acceleration-only)
</pre> with ulike=0, giving the bias term in O(m) time.</dd></dl>
<p>If you want the acceleration-level bias terms b for all the constraints, even if they are holonomic, use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a070ff72001adf5714ec1e55851404f1b" title="Calculate the acceleration constraint bias vector, that is, the terms in the acceleration constraints...">calcBiasForAccelerationConstraints()</a>. </p>

</div>
</div>
<a class="anchor" id="a9ccc3ce0e76fbc65aeb480ef73d603db"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcG" ref="a9ccc3ce0e76fbc65aeb480ef73d603db" args="(const State &amp;state, Matrix &amp;G) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9ccc3ce0e76fbc65aeb480ef73d603db">SimTK::SimbodyMatterSubsystem::calcG</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which appears in the system equations of motion. </p>
<p>Consider using the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a> method instead of this one, which forms the matrix-vector product G*v in O(m+n) time without explicitly forming G.</p>
<dl class="user"><dt><b>Implementation</b></dt><dd>This method generates G columnwise using repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>, which makes use of the constraint error methods to perform a G*v product in O(m+n) time. To within numerical error, for non-working constraints this should be identical to the transpose of the matrix returned by calcGt() which uses the constraint force methods instead. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>, calcGt(), <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afee56d346a7f0adeffe19b5b951d51b5" title="This O(m*n) operator explicitly calculates the mp X nq position-level (holonomic) constraint Jacobian...">calcPq()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a070ff72001adf5714ec1e55851404f1b"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForAccelerationConstraints" ref="a070ff72001adf5714ec1e55851404f1b" args="(const State &amp;state, Vector &amp;bias) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a070ff72001adf5714ec1e55851404f1b">SimTK::SimbodyMatterSubsystem::calcBiasForAccelerationConstraints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the acceleration constraint bias vector, that is, the terms in the acceleration constraints that are independent of the accelerations. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Provides time t, positions q, and speeds u; must be realized through Velocity stage so that all body spatial velocities are known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bias</td><td>This is the bias vector for all the acceleration constraint equations together. It will be resized if necessary to length m=mp+mv+ma, the total number of active acceleration-level constraint equations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> realized to Velocity stage </dd></dl>
<dl class="user"><dt><b>Implementation</b></dt><dd>We have constant-time constraint acceleration error methods <pre>   
paerr(t,q,u;udot)=P*udot - b_p(t,q,u) 
vaerr(t,q,u;udot)=V*udot - b_v(t,q,u) 
 aerr(t,q,u;udot)=A*udot - b_a(t,q,u)   
</pre> that together define the acceleration constraint equation G*udot-b=0 where G=[P;V;A] and b=[b_p b_v b_a]. There is one of these error functions for each Constraint, with paerr() the twice-differentiated position (holonomic) constraints, vaerr() the once-differentiated velocity (nonholonomic) constraints, and aerr() the acceleration-only constraints. This method sets <code>udot</code> = 0 and invokes each of those methods to obtain bias = -[b_p b_v b_a].</dd></dl>
<h3>Performance note</h3>
<p>The actual acceleration constraint functions require both udot and body accelerations for the constrained bodies; even with udot==0 body accelerations may have a non-zero velocity-dependent component (the coriolis accelerations). Those are already available in the state, but only as accelerations in Ground. For constraints that have a non-Ground Ancestor, we have to convert the accelerations to A at a cost of 105 flops/constrained body. </p>

</div>
</div>
<a class="anchor" id="a3d2451d87d7cae837062cd9a036bf698"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByGTranspose" ref="a3d2451d87d7cae837062cd9a036bf698" args="(const State &amp;state, const Vector &amp;lambda, Vector &amp;f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d2451d87d7cae837062cd9a036bf698">SimTK::SimbodyMatterSubsystem::multiplyByGTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (=[P;V;A]) and a multiplier-like vector <em>lambda</em> of length m, returning a generalized-force like quantity <em>f</em> of length n. </p>
<p>m=mp+mv+ma is the total number of active constraint equations, n (==nu) is the number of mobilities (generalized speeds u). If lambda is a set of constraint multipliers, then f=~G*lambda is the set of forces generated by the constraints, mapped into generalized forces. This is an O(m+n) operation.</p>
<p>Because the velocity (non-holonomic) or acceleration-only constraint Jacobians V and A can have velocity dependence, the <em>state</em> supplied here must generally be realized through Velocity stage. If the system has only position (holonomic) constraints then the <em>state</em> need be realized only through Position stage.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has been realized through Velocity stage (or Position stage if the system has only position constraints). Time, configuration, and velocities if needed are taken from <em>state</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>A multiplier-like vector to be multiplied by ~G. Its length must be the same as the total number of active constraint equations m. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>This is the generalized force-like output. It will be resized if necessary to length equal to the number of mobilities (generalized speeds) n (==nu).</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Implementation</b></dt><dd>This is accomplished by treating the input vector <em>lambda</em> as though it were a set of Lagrange multipliers, then calling each of the active Constraints' (constant time) force generation methods, providing the appropriate subset of the multipliers each time. That gives body forces F0 and mobility forces f0 in O(m) time. We then use the equivalent of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> to convert the returned body spatial forces to generalized forces in O(n) time, and finally return the generalized force-like result f = ~J*F0 + f0. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90a34ce745cbf5a0bf34f4a62d9ddb2e" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0f04f21d4d1fe85c830f71d60995a799"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcGTranspose" ref="a0f04f21d4d1fe85c830f71d60995a799" args="(const State &amp;, Matrix &amp;Gt) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0f04f21d4d1fe85c830f71d60995a799">SimTK::SimbodyMatterSubsystem::calcGTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Gt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This O(nm) operator explicitly calculates the n X m transpose of the acceleration-level constraint Jacobian G = [P;V;A] which appears in the system equations of motion. </p>
<p>This method generates ~G columnwise use the constraint force generating methods which map constraint multipliers to constraint forces. To within numerical error, this should be identical to the transpose of the matrix returned by <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9ccc3ce0e76fbc65aeb480ef73d603db" title="This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which a...">calcG()</a> which uses a different method. Consider using the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d2451d87d7cae837062cd9a036bf698" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a> method instead of this one, which forms the matrix-vector product ~G*v in O(n) time without explicitly forming ~G. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9ccc3ce0e76fbc65aeb480ef73d603db" title="This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which a...">calcG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d2451d87d7cae837062cd9a036bf698" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aea5e1f8641e547ae8bd317202236bfdc"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByPq" ref="aea5e1f8641e547ae8bd317202236bfdc" args="(const State &amp;state, const Vector &amp;qlike, Vector &amp;PqXqlike) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc">SimTK::SimbodyMatterSubsystem::multiplyByPq</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qlike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>PqXqlike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint Jacobian and <em>qlike</em> is a "q-like" (generalized coordinate space) vector of length nq. </p>
<p>Here mp is the number of active position-level constraint equations in this system.</p>
<p>If you are going to call this method repeatedly at the same time t and configuration q and want maximum efficiency, you can gain a factor of almost 2X by precalculating a bias term once using <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ace41900bbf22180dc66b632db4198af2" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByPq() method ab...">calcBiasForMultiplyByPq()</a> and supplying it to the alternate signature of this method. See the Theory section below for an explanation of the bias term.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> realized to Position stage</dd></dl>
<h3>Theory</h3>
<p>Simbody's position (holonomic) constraints are defined by the constraint error equation </p>
<pre>
    (1)    perr(t;q) = p(t,q)
</pre><p> where we try to maintain perr=0 at all times. We also have available time derivatives of equation (1); the first time derivative is relevant here: </p>
<pre>
    (2)    pverr(t,q;qdot) = dperr/dt = Pq * qdot + Pt
</pre><p> where Pq=Dperr/Dq and Pt=Dperr/Dt (capital "D" means partial derivative). Pt=Pt(t,q) is called the "bias" term. (Note that because u=N^-1*qdot we also have Pq=P*N^-1, where P=Dpverr/Du is the very useful mobility-space holonomic constraint Jacobian.) Eq. (2) can be used to perform efficient multiplication by Pq, since it can be used to calculate Pq*qlike+Pt, and a second evaluation at qlike=0 can be used to calculate the unwanted bias term for removal: </p>
<pre>
    (3)    Pq*qlike = pverr(t,q;qlike) - pverr(t,q;0)  
</pre><p> Despite appearances, eq. (2) calculates its result in constant time per constraint equation, for a total cost that is O(n) or more strictly O(mp+nq). The matrix Pq is never actually formed; instead the matrix-vector product is calculated directly.</p>
<h3>Implementation</h3>
<p>We treat the input vector <em>qlike</em> as though it were a set of generalized coordinate derivatives qdot. These are mapped to body velocities V in O(n) time, using V=Jq*qdot, where Jq is the coordinate space system Jacobian (partial velocity matrix), with Jq=J*N^-1. Then the body velocities and qdots are supplied to each of the mp active position constraints' (constant time) velocity error methods to get pverr(t,q;qlike)=Pq*qlike-Pt in O(n) time. A second call is made to evaluate the bias term pverr(t,q;0)=-Pt. We then calculate the result <em>PqXqlike</em> = pverr(t,q;qlike)-pverr(t,q;0) in O(n) time using equation (3).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ace41900bbf22180dc66b632db4198af2" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByPq() method ab...">calcBiasForMultiplyByPq()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa88a493efe683e24eb5bfeb2aca32bf3"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByPq" ref="aa88a493efe683e24eb5bfeb2aca32bf3" args="(const State &amp;state, const Vector &amp;qlike, const Vector &amp;biasp, Vector &amp;PqXqlike) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc">SimTK::SimbodyMatterSubsystem::multiplyByPq</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qlike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>biasp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>PqXqlike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply Pq*qlike using the supplied precalculated bias vector to improve performance (approximately 2X) over the other signature. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ace41900bbf22180dc66b632db4198af2" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByPq() method ab...">calcBiasForMultiplyByPq()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ace41900bbf22180dc66b632db4198af2"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBiasForMultiplyByPq" ref="ace41900bbf22180dc66b632db4198af2" args="(const State &amp;state, Vector &amp;biasp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ace41900bbf22180dc66b632db4198af2">SimTK::SimbodyMatterSubsystem::calcBiasForMultiplyByPq</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>biasp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the bias vector needed for the higher-performance signature of the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> method above. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Provides time t, and positions q; must be realized through Position stage so that all body spatial poses are known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">biasp</td><td>This is the bias vector for use in repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a>. It will be resized if necessary to length mp, the total number of active position-level (holonomic) constraint equations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> realized to Position stage</dd></dl>
<p>See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> for theory and implementation; this method is just performing the qlike=0 case described there for calculating the bias term Pt. </p>

</div>
</div>
<a class="anchor" id="afee56d346a7f0adeffe19b5b951d51b5"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcPq" ref="afee56d346a7f0adeffe19b5b951d51b5" args="(const State &amp;state, Matrix &amp;Pq) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afee56d346a7f0adeffe19b5b951d51b5">SimTK::SimbodyMatterSubsystem::calcPq</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Pq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This O(m*n) operator explicitly calculates the mp X nq position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the position error equations with respect to q. </p>
<p>Consider using the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> method instead of this one, which forms the matrix-vector product Pq*v in O(m+n) time without explicitly forming Pq.</p>
<p>Note that quaternion normalization constraints are <em>not</em> included in mp; we do not consider those holonomic constraints.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> realized to Position stage</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> realized through Position stage so that time and the pose (configuration) of each body is known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Pq</td><td>The position constraint Jacobian Dperr/Dq. This will be resized to mp X nq if necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Implementation</b></dt><dd>This method generates Pq columnwise using repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a>, which makes use of the position constraint velocity-level error methods to perrform a Pq*v product in O(m+n) time. See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> for a more detailed explanation. If Pq's columns are in contiguous memory we'll work in place, otherwise columns are generated into a contiguous temporary and then copied into Pq.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8e1f93e8ed0f1366cb24adc34ecc2b5c"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByPqTranspose" ref="a8e1f93e8ed0f1366cb24adc34ecc2b5c" args="(const State &amp;state, const Vector &amp;lambdap, Vector &amp;f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8e1f93e8ed0f1366cb24adc34ecc2b5c">SimTK::SimbodyMatterSubsystem::multiplyByPqTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lambdap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint Jacobian Pq (=P*N^-1) and a multiplier-like vector <em>lambdap</em> of length mp, returning a generalized-force like quantity <em>f</em> of length n. </p>
<p>mp is the number of active position constraint equations, n (==nu) is the number of mobilities (generalized speeds u). If lambdap is a set of mp constraint multipliers, then f=~G*lambdap is the set of forces generated by the position constraints, mapped into generalized forces. This is an O(mp+n) operation.</p>
<p>A holonomic constraint Jacobian cannot have a velocity dependence, so the <em>state</em> need be realized only to Position stage here.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> that has been realized through Position stage. Time and configuration are taken from <em>state</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambdap</td><td>A multiplier-like vector to be multiplied by ~Pq. Its length must be the same as the number of active position constraint equations mp. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>This is the generalized force-like output. It will be resized if necessary to length equal to the number of mobilities (generalized speeds) n (==nu).</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Implementation</b></dt><dd>This is accomplished by treating the input vector <em>lambdap</em> as though it were a set of Lagrange multipliers, then calling each of the active holonomic Constraints' (constant time) force generation methods, providing the appropriate subset of the multipliers each time. That gives body forces F0 and mobility forces f0 in O(mp) time. We then use the equivalent of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> to convert the returned body spatial forces to generalized forces in O(n) time, and finally return the generalized force-like result f = ~J*F0 + f0. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea5e1f8641e547ae8bd317202236bfdc" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae2900f9febb57ef8deab114f37cb2342" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf054922c552ad0182c6fce5839473a4"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcPqTranspose" ref="abf054922c552ad0182c6fce5839473a4" args="(const State &amp;state, Matrix &amp;Pqt) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abf054922c552ad0182c6fce5839473a4">SimTK::SimbodyMatterSubsystem::calcPqTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Pqt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This O(m*n) operator explicitly calculates the nq X mp transpose of the position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the position error equations with respect to q. </p>
<p>Consider using the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8e1f93e8ed0f1366cb24adc34ecc2b5c" title="Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint J...">multiplyByPqTranspose()</a> method instead of this one, which forms the matrix-vector product ~Pq*v in O(m+n) time without explicitly forming ~Pq.</p>
<p>Note that quaternion normalization constraints are <em>not</em> included in mp; we do not consider those holonomic constraints.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> realized to Position stage</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> realized through Position stage so that time and the pose (configuration) of each body is known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Pqt</td><td>The transposed position constraint Jacobian ~Pq=(Dperr/Dq)^T. This will be resized to nq X mp if necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Implementation</b></dt><dd>This method generates <em>Pqt</em> columnwise using repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8e1f93e8ed0f1366cb24adc34ecc2b5c" title="Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint J...">multiplyByPqTranspose()</a>, which makes use of the position constraint force generating methods to perform a ~Pq*v product in O(m+n) time. See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8e1f93e8ed0f1366cb24adc34ecc2b5c" title="Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint J...">multiplyByPqTranspose()</a> for a more detailed explanation. If Pqt's columns are in contiguous memory we'll work in place, otherwise columns are generated into a contiguous temporary and then copied into Pqt.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8e1f93e8ed0f1366cb24adc34ecc2b5c" title="Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint J...">multiplyByPqTranspose()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a67ee9e954c61bb99aab23a8a2e32f17c"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcP" ref="a67ee9e954c61bb99aab23a8a2e32f17c" args="(const State &amp;state, Matrix &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a67ee9e954c61bb99aab23a8a2e32f17c">SimTK::SimbodyMatterSubsystem::calcP</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the mp X nu matrix P which is the Jacobian of the first time derivative of the holonomic (position) constraint errors with respect to the generalized speeds u; that is, P = partial( dperr/dt )/partial(u). </p>
<p>Here mp is the number of holonomic constraint equations (not including quaternion normalization constraints) and nu is the total number of generalized speeds as found in the supplied <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. P is resized if necessary; an error will be thrown if the Matrix is not the right size and not resizeable.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> is realized to Position stage </dd></dl>
<dl class="user"><dt><b>Complexity:</b></dt><dd>Calculates the m X n matrix in O(m*n) time, which is good if you really need this matrix. However, in many cases what is really needed is the product of this matrix with a vector which can be done in O(n) time; consider whether you really need the whole matrix explicitly. </dd></dl>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="aef93085ae7c818d764d8d756a46aa578"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcPt" ref="aef93085ae7c818d764d8d756a46aa578" args="(const State &amp;state, Matrix &amp;Pt) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aef93085ae7c818d764d8d756a46aa578">SimTK::SimbodyMatterSubsystem::calcPt</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the nu X mp matrix ~P - see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a67ee9e954c61bb99aab23a8a2e32f17c" title="Returns the mp X nu matrix P which is the Jacobian of the first time derivative of the holonomic (pos...">calcP()</a> for a description. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a8717059cf2dcdcc7686b74d0f98aa3d7"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByN" ref="a8717059cf2dcdcc7686b74d0f98aa3d7" args="(const State &amp;s, bool transpose, const Vector &amp;in, Vector &amp;out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8717059cf2dcdcc7686b74d0f98aa3d7">SimTK::SimbodyMatterSubsystem::multiplyByN</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate out_q = N(q)*in_u (like qdot=N*u) or out_u = ~N*in_q. </p>
<p>Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by N on the right, with the Vectors viewed as RowVectors instead. This is an O(n) operator since N is block diagonal. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6005e93b49eea745739c9df64cab7223"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByNInv" ref="a6005e93b49eea745739c9df64cab7223" args="(const State &amp;s, bool transpose, const Vector &amp;in, Vector &amp;out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6005e93b49eea745739c9df64cab7223">SimTK::SimbodyMatterSubsystem::multiplyByNInv</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate out_u = NInv(q)*in_q (like u=NInv*qdot) or out_q = ~NInv*in_u. </p>
<p>Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by NInv on the right, with the Vectors viewed as RowVectors instead. This is an O(N) operator since NInv is block diagonal. The configuration q is taken from the supplied state. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca55c9a4bd3d333ca6759af882f38a1"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::multiplyByNDot" ref="a2ca55c9a4bd3d333ca6759af882f38a1" args="(const State &amp;s, bool transpose, const Vector &amp;in, Vector &amp;out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2ca55c9a4bd3d333ca6759af882f38a1">SimTK::SimbodyMatterSubsystem::multiplyByNDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate out_q = NDot(q,u)*in_u or out_u = ~NDot(q,u)*in_q. </p>
<p>This is used, for example, as part of the conversion between udot and qdotdot. Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by NDot on the right, with the Vectors viewed as RowVectors instead. This is an O(N) operator since NDot is block diagonal. Configuration q and generalized speeds u are taken from the supplied state. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="acaa2e2826c3aa20edd38ef295619f219"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcAcceleration" ref="acaa2e2826c3aa20edd38ef295619f219" args="(const State &amp;state, const Vector &amp;appliedMobilityForces, const Vector_&lt; SpatialVec &gt; &amp;appliedBodyForces, Vector &amp;udot, Vector_&lt; SpatialVec &gt; &amp;A_GB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#acaa2e2826c3aa20edd38ef295619f219">SimTK::SimbodyMatterSubsystem::calcAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedMobilityForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>appliedBodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>udot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_GB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the primary forward dynamics operator. </p>
<p>It takes a state which has been realized to the Dynamics stage, a complete set of forces to apply, and returns the accelerations that result. Only the forces supplied here, and those calculated internally from prescribed motion, constraints, and centrifugal effects, affect the results. Acceleration constraints are always satisfied on return as long as the constraints are consistent. If the position and velocity constraints aren't already satisified in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>, results are harder to interpret physically, but they will still be calculated and the acceleration constraints will still be satisfied. No attempt will be made to satisfy position and velocity constraints, or to set prescribed positions and velocities, nor even to check whether these are satisfied; position and velocity constraint and prescribed positions and velocities are simply irrelevant here.</p>
<p>Given applied forces f_applied, this operator solves this set of equations: </p>
<pre>
     M udot + tau + ~G lambda + f_inertial = f_applied       (1)
                                  G udot   = b               (2)
                                    udot_p = udot_p(t,q,u,z) (3)
</pre><p> where udot={udot_f,udot_p}, tau={0,tau_p}. The unknowns are: the free generalized accelerations udot_f, the constraint multipliers lambda, and the prescribed motion generalized forces tau_p. A subset udot_p of udot may have been prescribed as a known function of state via <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or locks associated with the mobilized bodies. On return all the entries in udot will have been set to their calculated or prescribed values, and body spatial accelerations A_GB (that is, measured and expressed in Ground) are also returned. Lambda and tau_p are necessarily calculated but are not returned here.</p>
<p>f_applied is the set of generalized (mobility) forces equivalent to the <em>appliedMobilityForces</em> and <em>appliedBodyForces</em> arguments supplied here. That is, </p>
<pre>
    f_applied = appliedMobilityForces + ~J * appliedBodyForces
</pre><p> where J is the system Jacobian mapping between spatial and generalized coordinates. Typically these forces will have been calculated as a function of state so we will have f_applied(t,q,u,z).</p>
<p>M(t,q), G(t,q,u), and b(t,q,u) are defined by the mobilized bodies and constraints present in the system. f_inertial(q,u) includes the velocity-dependent gyroscopic and coriolis forces due to rigid body rotations and is extracted internally from the already-realized state.</p>
<p>Note that this method does not allow you to specify your own prescribed udots; those are calculated from the mobilizers' state-dependent <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> specifications (or are zero due to mobilizer locks) that are already part of the system.</p>
<p>This is an O(n*m + m^3) operator where n is the number of generalized speeds and m the number of constraint equations (mobilities with prescribed motion are counted in n, not m).</p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13ab0a24de476c174b03fc0dc8d463a3563" title="Forces calculated.">Stage::Dynamics</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a90bb781704ba58833f69bb86432339a7"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcAccelerationIgnoringConstraints" ref="a90bb781704ba58833f69bb86432339a7" args="(const State &amp;state, const Vector &amp;appliedMobilityForces, const Vector_&lt; SpatialVec &gt; &amp;appliedBodyForces, Vector &amp;udot, Vector_&lt; SpatialVec &gt; &amp;A_GB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90bb781704ba58833f69bb86432339a7">SimTK::SimbodyMatterSubsystem::calcAccelerationIgnoringConstraints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedMobilityForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>appliedBodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>udot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_GB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This operator is similar to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#acaa2e2826c3aa20edd38ef295619f219" title="This is the primary forward dynamics operator.">calcAcceleration()</a> but ignores the effects of acceleration constraints although it obeys prescribed accelerations. </p>
<p>The supplied forces, prescribed motion forces, and velocity-induced centrifugal and gyroscopic effects are properly accounted for, but any forces that would have resulted from enforcing the contraints are not present. This operator solves the equations </p>
<pre>
            M udot + tau + f_inertial = f_applied           (1)
                               udot_p = udot_p(t,q,u,z)     (2)
</pre><p> where udot={udot_f,udot_p}, tau={0,tau_p}. The unknowns are the free generalized accelerations udot_f and the prescribed motion generalized forces tau_p. f_inertial contains the velocity-dependent gyroscopic and coriolis forces due to rigid body rotations. No constraint forces are included.</p>
<p>On return all the entries in udot will have been set to their calculated or prescribed values, and body spatial accelerations A_GB (that is, measured and expressed in Ground) are also returned. tau_p is not returned.</p>
<p>This is an O(n) operator.</p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13ab0a24de476c174b03fc0dc8d463a3563" title="Forces calculated.">Stage::Dynamics</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a9402191ff489fae227969ed43db05df0"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcResidualForceIgnoringConstraints" ref="a9402191ff489fae227969ed43db05df0" args="(const State &amp;state, const Vector &amp;appliedMobilityForces, const Vector_&lt; SpatialVec &gt; &amp;appliedBodyForces, const Vector &amp;knownUdot, Vector &amp;residualMobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9402191ff489fae227969ed43db05df0">SimTK::SimbodyMatterSubsystem::calcResidualForceIgnoringConstraints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedMobilityForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>appliedBodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownUdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>residualMobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the inverse dynamics operator for the tree system; if there are any constraints or prescribed motion they are ignored. </p>
<p>This method solves </p>
<pre>
     f_residual = M udot + f_inertial - f_applied
</pre><p> for f_residual in O(n) time, meaning that the mass matrix M is never formed. Inverse dynamics is considerably faster than forward dynamics, even though both are O(n) in Simbody.</p>
<p>In the above equation we solve for the residual forces <code>f_residual</code> given desired accelerations and (optionally) a set of applied forces. Here <code>f_applied</code> is the mobility-space equivalent of all the applied forces (including mobility and body forces), <code>f_inertial</code> is the mobility-space equivalent of the velocity-dependent inertial forces due to rigid body rotations (coriolis and gyroscopic forces), and <code>udot</code> is the given set of values for the desired generalized accelerations. The returned <code>f_residual</code> is the additional generalized force (that is, mobility force) that would have to be applied at each mobility to give the desired <code>udot</code>. The inertial forces depend on the velocities <code>u</code> already realized in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. Otherwise, only the explicitly-supplied forces affect the results of this operator; any forces that may be present elsewhere in the system are ignored.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> valid for the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>, already realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appliedMobilityForces</td><td>One scalar generalized force applied per mobility. Can be zero length if there are no mobility forces; otherwise must have exactly one entry per mobility in the matter subsystem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appliedBodyForces</td><td>One spatial force for each body. A spatial force is a force applied to the body origin and a torque on the body, each expressed in the Ground frame. Gravity, if present, is specified here as a body force. The supplied Vector must be either zero length (interpreted as all-zero) or have exactly one entry per body in the matter subsystem, starting with Ground as body zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownUdot</td><td>These are the desired generalized accelerations, one per mobility. If this is zero length it will be treated as all-zero; otherwise it must have exactly one entry per mobility in the matter subsystem. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">residualMobilityForces</td><td>These are the residual generalized forces which, if added to the applied forces, would produce the given <em>knownUdot</em> in forward dynamics (assuming the system is unconstrained). This will be resized if necessary to have length nu; that is, one scalar entry per mobility. You can view this as a measure of how much the given <em>knownUdot</em> fails to satisfy the equations of motion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adbefe95f61bdad30776f742345fa1fce" title="This is the inverse dynamics operator for when you know both the accelerations and Lagrange multiplie...">calcResidualForce()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a343dc68594d7afe04762db67a3ca68a9" title="This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a su...">multiplyByM()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#acaa2e2826c3aa20edd38ef295619f219" title="This is the primary forward dynamics operator.">calcAcceleration()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90bb781704ba58833f69bb86432339a7" title="This operator is similar to calcAcceleration() but ignores the effects of acceleration constraints al...">calcAccelerationIgnoringConstraints()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbefe95f61bdad30776f742345fa1fce"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcResidualForce" ref="adbefe95f61bdad30776f742345fa1fce" args="(const State &amp;state, const Vector &amp;appliedMobilityForces, const Vector_&lt; SpatialVec &gt; &amp;appliedBodyForces, const Vector &amp;knownUdot, const Vector &amp;knownLambda, Vector &amp;residualMobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adbefe95f61bdad30776f742345fa1fce">SimTK::SimbodyMatterSubsystem::calcResidualForce</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedMobilityForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>appliedBodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownUdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>residualMobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the inverse dynamics operator for when you know both the accelerations and Lagrange multipliers for a constrained system. </p>
<p>Prescribed motion is ignored. Using position and velocity from the given state, a set of applied forces, and a known set of generalized accelerations udot and constraint multipliers lambda, it calculates the additional generalized forces that would be required to satisfy Newton's 2nd law, f=Ma. That is, this operator returns </p>
<pre>
    f_residual = M udot + ~G lambda + f_inertial - f_applied
</pre><p> where f_applied is the mobility-space equivalent to all the applied forces (including mobility and body forces), f_inertial is the mobility-space equivalent of the velocity-dependent inertial forces due to rigid body rotations (coriolis and gyroscopic forces), and the udots and lambdas are given values of the generalized accelerations and constraint multipliers, resp.</p>
<p>Note that there is no requirement that the given udots satisfy the constraint equations; we simply solve the above equation for <code>f_residual</code>.</p>
<p>The inertial forces depend on the velocities <code>u</code> already realized in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. Otherwise, only the explicitly-supplied forces affect the results of this operator; any forces that may be defined elsewhere in the system are ignored here.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> valid for the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>, already realized to <code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appliedMobilityForces</td><td>One scalar generalized force applied per mobility. Can be zero length if there are no mobility forces; otherwise must have exactly one entry per mobility in the matter subsystem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appliedBodyForces</td><td>One spatial force for each body. A spatial force is a force applied to the body origin and a torque on the body, each expressed in the Ground frame. Gravity, if present, is specified here as a body force. The supplied Vector must be either zero length (interpreted as all-zero) or have exactly one entry per body in the matter subsystem, starting with Ground as body zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownUdot</td><td>These are the specified generalized accelerations, one per mobility so the length should be nu. If this is zero length it will be treated as all-zero of length nu; otherwise it must have exactly one entry per mobility in the matter subsystem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownLambda</td><td>These are the specified Lagrange multipliers, one per constraint equation. If this is zero length it will be treated as all-zero; otherwise it must have exactly m entries, where m=mp+mv+ma is the total number of position, velocity, and acceleration-only constraints. There are no entries here corresponding to quaternion constraints, which do not generate forces. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">residualMobilityForces</td><td>These are the residual generalized forces which, if added to the applied forces along with the constraint forces ~G*lambda, would produce the given <em>knownUdot</em> in unconstrained forward dynamics. This will be resized if necessary to have length nu; that is, one scalar entry per mobility. You can view this as a measure of how much the given udot and lambda fail to satisfy the equations of motion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9402191ff489fae227969ed43db05df0" title="This is the inverse dynamics operator for the tree system; if there are any constraints or prescribed...">calcResidualForceIgnoringConstraints()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b1da0e232e11cadd1bf32d4f94035df"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcCompositeBodyInertias" ref="a7b1da0e232e11cadd1bf32d4f94035df" args="(const State &amp;state, Array_&lt; SpatialInertia, MobilizedBodyIndex &gt; &amp;R) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7b1da0e232e11cadd1bf32d4f94035df">SimTK::SimbodyMatterSubsystem::calcCompositeBodyInertias</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a>, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This operator calculates the composite body inertias R given a <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> realized to Position stage. </p>
<p>Composite body inertias are the spatial mass properties of the rigid body formed by a particular body and all bodies outboard of that body as if all the outboard mobilizers were welded in their current orientations.</p>
<p>This is a very fast O(n) operator.</p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a94d275630d490646b6eed0c1ed392c6d"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcBodyAccelerationFromUDot" ref="a94d275630d490646b6eed0c1ed392c6d" args="(const State &amp;state, const Vector &amp;knownUDot, Vector_&lt; SpatialVec &gt; &amp;A_GB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a94d275630d490646b6eed0c1ed392c6d">SimTK::SimbodyMatterSubsystem::calcBodyAccelerationFromUDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownUDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_GB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a complete set of n generalized accelerations udot, this kinematic operator calculates in O(n) time the resulting body accelerations, including velocity-dependent terms taken from the supplied <em>state</em>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>state</em> must already be realized to Velocity stage </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> from which position- and velocity- related terms are taken; must already have been realized to Velocity stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownUDot</td><td>A complete set of generalized accelerations. Must have the same length as the number of mobilities nu, or if length zero the udots will be taken as all zero in which case only velocity-dependent (Coriolis) accelerations will be returned in <em>A_GB</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_GB</td><td>Spatial accelerations of all the body frames measured and expressed in the Ground frame, resulting from supplied generalized accelerations <em>knownUDot</em> and velocity-dependent acceleration terms taken from <em>state</em>. This will be resized if necessary to the number of bodies <em>including</em> Ground so that the returned array may be indexed by <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> with A_GB[0]==0 always. The angular acceleration vector for <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> i is A_GB[i][0]; linear acceleration of the body's origin is A_GB[i][1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Theory</b></dt><dd>The generalized speeds u and spatial velocities V are related by the system Jacobian J as V=J*u. Thus the spatial accelerations A=Vdot=J*udot+Jdot*u.</dd></dl>
<dl class="user"><dt><b>Implementation</b></dt><dd>The Coriolis accelerations Jdot*u are already available in a <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> realized to Velocity stage. The J*udot term is equivalent to an application of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> to the <em>knownUdot</em> vector. The current implementation uses 12*nu + 18*nb flops to produce nb body accelerations.</dd></dl>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3722e55e7b5923558bd3f1a0cf4a5f33" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcf1b13d1c0b400dd41a77a80c840d30" title="This is the total coriolis acceleration including the effect of the parent&#39;s angular velocity as well...">getTotalCoriolisAcceleration()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6cae3da23f051dc8116fbf0e054dd302"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcConstraintForcesFromMultipliers" ref="a6cae3da23f051dc8116fbf0e054dd302" args="(const State &amp;state, const Vector &amp;multipliers, Vector_&lt; SpatialVec &gt; &amp;bodyForcesInG, Vector &amp;mobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cae3da23f051dc8116fbf0e054dd302">SimTK::SimbodyMatterSubsystem::calcConstraintForcesFromMultipliers</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>multipliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Treating all Constraints together, given a comprehensive set of m Lagrange multipliers <em>lambda</em>, generate the complete set of body spatial forces and mobility (generalized) forces applied by all the Constraints. </p>
<p>Spatial forces are applied at each body's origin and the moment and force vectors therein are expressed in the Ground frame. Watch the sign -- normally constraint forces have opposite sign from applied forces, because our equations of motion are </p>
<pre>   M udot + ~G lambda = f_applied  </pre><p> If you want to take Simbody-calculated multipliers and use them to generate forces that look like applied forces, negate the multipliers in the argument passed to this call.</p>
<p><a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> must be realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a> to call this operator (although typically the multipliers are obtained by realizing to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated.">Stage::Acceleration</a>).</p>
<p>This is an O(m) operator. In particular it does <em>not</em> involve forming or multiplying by the constraint force matrix ~G. Instead, one constant-time call is made to each Constraint's calcConstraintForce methods.</p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="adc629077769b8c767bd1bc160787d4af"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForces" ref="adc629077769b8c767bd1bc160787d4af" args="(const State &amp;state, Vector_&lt; SpatialVec &gt; &amp;forcesAtMInG) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af">SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forcesAtMInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the mobilizer reaction force generated at each <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>, as felt at the mobilizer's outboard frame M, and expressed in Ground. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> compatible with this <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has already been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated.">Stage::Acceleration</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forcesAtMInG</td><td>A Vector of spatial force vectors, indexed by <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> (beginning with 0 for Ground), giving the reaction moment and force applied by each body's unique inboard mobilizer to that body. The force is returned as though it were applied at the origin of the body's mobilizer frame M. The returned force is expressed in the Ground frame. Applied mobility (generalized) forces are <em>included</em> in the returned reaction forces.</td></tr>
  </table>
  </dd>
</dl>
<p>A simple way to think of the reaction force is to think of cutting the mobilizer, then imagine the force required to make the system move in the same manner as when the mobilizer was present. This is what the reaction forces accomplish. With that definition, mobility forces (that is, generalized forces as opposed to body forces) are <em>included</em> in the reactions. Some conventions do not include the mobility forces in the definition of a reaction force. We chose to include them since this preserves Newton's 3rd law of equal and opposite reactions between bodies. Ours is the same convention as used in SD/FAST.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You can think of the Ground body being welded to the universe at the Ground origin. The reactions reported for Ground are the ones that would occur in that Weld mobilizer if it were really present. That is, it includes the effects of all the base bodies on Ground.</dd></dl>
<h3>How to find the reaction felt by the parent body</h3>
<p>A mobilizer connects a frame F fixed on the parent (inboard) body P to a frame M fixed on the child (outboard) body B. It exerts equal and opposite reaction forces on the two bodies, at a given location in space. This method reports the force on the child body, as though it were applied at the origin Mo of frame M, and expressed in the Ground frame. The force on the parent body <em>at Mo</em> is just the negative of the returned value. However, it is more likely that you would want it as felt <em>at Fo</em>, the origin of the F frame on the parent. Here is one way to calculate that from the returned quantities: </p>
<div class="fragment"><pre class="fragment">    matter.calcMobilizerReactionForces(state,forcesAtMInG); <span class="comment">// This method.</span>
    <span class="keyword">const</span> <span class="keywordtype">int</span> nb = matter.getNumBodies();
    Vector_&lt;SpatialVec&gt; forcesAtFInG(nb); <span class="comment">// to hold the result</span>
    forcesAtFInG[0] = -forcesAtMInG[0]; <span class="comment">// Ground is &quot;welded&quot; at origin</span>
    <span class="keywordflow">for</span> (MobilizedBodyIndex i(1); i &lt; nb; ++i) {
        <span class="keyword">const</span> MobilizedBody&amp; body   = matter.getMobilizedBody(i);
        <span class="keyword">const</span> MobilizedBody&amp; parent = body.getParentMobilizedBody();
        <span class="comment">// Want to shift reaction by p_MF, the vector from M to F across the</span>
        <span class="comment">// mobilizer, and negate. Can get p_FM; must reexpress in G.</span>
        <span class="keyword">const</span> <a class="code" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; p_FM = body.getMobilizerTransform(state).p();
        <span class="keyword">const</span> <a class="code" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a>&amp; R_PF = body.getInboardFrame(state).R(); <span class="comment">// In parent.</span>
        <span class="keyword">const</span> <a class="code" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a>&amp; R_GP = parent.getBodyTransform(state).R();
        <a class="code" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> R_GF   =   R_GP*R_PF;  <span class="comment">// F frame orientation in Ground.</span>
        <a class="code" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>     p_MF_G = -(R_GF*p_FM); <span class="comment">// Re-express and negate shift vector. </span>
        forcesAtFInG[i] = -<a class="code" href="group__SpatialAlgebraUtilities.html#ga2b44f1ea5624daf334b4aa6c0e07ea0e" title="Shift a spatial force applied at some point of a body to that same spatial force applied at a new poi...">shiftForceBy</a>(forcesAtMInG[i], p_MF_G);
    }
</pre></div><h3>Implementation</h3>
<p>This method combines already-calculated quantities to calculate the reactions. See Abhi Jain's 2011 book "Robot and Multibody Dynamics", Eq. 7.34 page 128: </p>
<pre>   F_reaction = PPlus*APlus + zPlus  </pre><p> where P is the articulated body inertia, A is the spatial acceleration, a the Coriolis acceleration and z the articulated body forces, and "Plus" indicates that we evaluate these on the inboard (parent) side of the mobilizer rather than on the body's side. (The alternative P(A-a)+z given there does not work for prescribed mobilizers unless you replace "a" with "a_underscore" from equation 16.14.) After calculating F_reaction at the body frame origin Bo, we shift it to M for reporting.</p>
<h3>Performance</h3>
<p>The cost of the above calculation is 114 flops/body. The code presented above for converting from M to F costs an additional 81 flops/body if you use it.</p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated.">Stage::Acceleration</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a4bc19dffd701936d44999571df13ba62" title="Return the spatial reaction force (moment and force) applied by the mobilizer to body B at the locati...">SimTK::MobilizedBody::findMobilizerReactionOnBodyAtMInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a47d5161f2fe40dbb8f10efa00af7dac9" title="This is a slower alternative to calcMobilizerReactionForces(), for use in regression testing and Simb...">calcMobilizerReactionForcesUsingFreebodyMethod()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa4d35b2738498ac63c76961af27b9881"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getMotionMultipliers" ref="aa4d35b2738498ac63c76961af27b9881" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa4d35b2738498ac63c76961af27b9881">SimTK::SimbodyMatterSubsystem::getMotionMultipliers</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the prescribed motion multipliers tau that have already been calculated in the given <em>state</em>, which must have been realized through Acceleration stage. </p>
<p>The result contains entries only for prescribed mobilities; if you want these unpacked into u-space mobility forces, use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adf85cff428267680387a3a61e178ddbf" title="Find the generalized mobility space forces produced by all the Motion objects active in this system...">findMotionForces()</a> instead. A mobilizer may follow prescribed motion either because of a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object or a call to <a class="el" href="classSimTK_1_1MobilizedBody.html#a7f7324c42a57beedd7c577dbf14e2531" title="Lock this mobilizer&#39;s position or velocity at its current value, or lock the acceleration to zero...">MobilizedBody::lock()</a>. </p>

</div>
</div>
<a class="anchor" id="af80a52a3ac50dced558fe486cd3a4db2"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcMotionErrors" ref="af80a52a3ac50dced558fe486cd3a4db2" args="(const State &amp;state, const Stage &amp;stage) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af80a52a3ac50dced558fe486cd3a4db2">SimTK::SimbodyMatterSubsystem::calcMotionErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Stage.html">Stage</a> &amp;&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the degree to which the supplied <em>state</em> does not satisfy the prescribed motion requirements at a particular <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>. </p>
<p>For Position and Velocity stage, a call to the prescribe() solver using the same stage will eliminate the error. Accelerations should have been calculated to satisfy all prescribed accelerations, so the returned value should be zero always. The returned Vector has one element per known (prescribed) q, known u, or known udot.</p>
<p>The <em>state</em> must be realized to Time stage to check Position errors, Position stage to check Velocity errors, and Acceleration stage to check Acceleration errors.</p>
<p>Errors are calculated actualValue - prescribedValue so a positive error indicates that the value in <em>state</em> is too large. </p>

</div>
</div>
<a class="anchor" id="adf85cff428267680387a3a61e178ddbf"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::findMotionForces" ref="adf85cff428267680387a3a61e178ddbf" args="(const State &amp;state, Vector &amp;mobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adf85cff428267680387a3a61e178ddbf">SimTK::SimbodyMatterSubsystem::findMotionForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the generalized mobility space forces produced by all the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects active in this system. </p>
<p>These are the same values as returned by <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa4d35b2738498ac63c76961af27b9881" title="Return a reference to the prescribed motion multipliers tau that have already been calculated in the ...">getMotionMultipliers()</a> but unpacked into u-space slots, with zeroes corresponding to any "free" mobilities, that is, those whose motion is not prescribed. </p>

</div>
</div>
<a class="anchor" id="ae6c2def3b10fe13eef67d374db29b3e1"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getConstraintMultipliers" ref="ae6c2def3b10fe13eef67d374db29b3e1" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae6c2def3b10fe13eef67d374db29b3e1">SimTK::SimbodyMatterSubsystem::getConstraintMultipliers</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the constraint multipliers lambda that have already been calculated in the given <em>state</em>, which must have been realized through Acceleration stage. </p>
<p><a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> multipliers are not directly interpretable as forces; if you want the actual forces use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a977620eb35c8e3ac371f1ede3d257f" title="Find the forces produced by all the active Constraint objects in this system.">findConstraintForces()</a> instead. If you want to know individual <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> contributions to these forces, ask the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects rather than this <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a> object. </p>

</div>
</div>
<a class="anchor" id="a2a977620eb35c8e3ac371f1ede3d257f"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::findConstraintForces" ref="a2a977620eb35c8e3ac371f1ede3d257f" args="(const State &amp;state, Vector_&lt; SpatialVec &gt; &amp;bodyForcesInG, Vector &amp;mobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a977620eb35c8e3ac371f1ede3d257f">SimTK::SimbodyMatterSubsystem::findConstraintForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the forces produced by all the active <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects in this system. </p>
<p>Constraints produce both body spatial forces and generalized mobility-space forces. The supplied <em>state</em> must have been realized through Acceleration stage. </p>

</div>
</div>
<a class="anchor" id="a1e4a10a720a71b3c0eff679ef566569e"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcMotionPower" ref="a1e4a10a720a71b3c0eff679ef566569e" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1e4a10a720a71b3c0eff679ef566569e">SimTK::SimbodyMatterSubsystem::calcMotionPower</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the power being generated or dissipated by all the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects currently active in this system. </p>
<p>The sign is chosen so that a positive value for power means the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> is adding energy to the system; negative means it is removing energy. The <em>state</em> must already have been realized through Acceleration stage so that the prescribed motion forces are available.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> realized through Acceleration stage from which we obtain the prescribed motion forces and the velocities needed to calculate power.</td></tr>
  </table>
  </dd>
</dl>
<h3>Implementation</h3>
<p>We calculate power=-dot(tau, u) where tau is the set of mobility reaction forces generated by <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects and mobilizer locks (tau[i]==0 if mobility i is free), and u is the set of all generalized speeds. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0663411853688e1a14beb0713f8e8de4" title="Return the power begin generated or dissipated by all the Constraint objects currently active in this...">calcConstraintPower()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0663411853688e1a14beb0713f8e8de4"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcConstraintPower" ref="a0663411853688e1a14beb0713f8e8de4" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0663411853688e1a14beb0713f8e8de4">SimTK::SimbodyMatterSubsystem::calcConstraintPower</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the power begin generated or dissipated by all the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects currently active in this system. </p>
<p>The sign is chosen so that a positive value for power means the Constraints (taken together) are adding energy to the system; negative means they are removing energy. The <em>state</em> must already have been realized through Acceleration stage so that the constraint forces are available.</p>
<p>Note that if you want to know the power output of an individual <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>, you should call that <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>'s calcPower() method; here they are all summed together.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> realized through Acceleration stage from which we obtain the constraint forces and the velocities needed to calculate power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The signed sum over all the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects of the power being generated or dissipated by each <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>. A positive value means that together the constraints are adding energy to the system; negative means they are removing energy.</dd></dl>
<h3>Implementation</h3>
<p>We calculate power=-(dot(F,V)+dot(f,u)) where F is the set of body spatial reaction forces produced by the Constraints, V is the body spatial velocities, f is the set of mobility reaction forces produced by the Constraints, and u is the set of generalized speeds. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1e4a10a720a71b3c0eff679ef566569e" title="Calculate the power being generated or dissipated by all the Motion objects currently active in this ...">calcMotionPower()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1e9a32a3ff754e9d7b75644deeb5c818"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcTreeEquivalentMobilityForces" ref="a1e9a32a3ff754e9d7b75644deeb5c818" args="(const State &amp;, const Vector_&lt; SpatialVec &gt; &amp;bodyForces, Vector &amp;mobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1e9a32a3ff754e9d7b75644deeb5c818">SimTK::SimbodyMatterSubsystem::calcTreeEquivalentMobilityForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accounts for applied forces and inertial forces produced by non-zero velocities in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. </p>
<p>Returns a set of mobility forces which replace both the applied bodyForces and the inertial forces. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13ab0a24de476c174b03fc0dc8d463a3563" title="Forces calculated.">Stage::Dynamics</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6afc8df58f92fc6dd15658b8a735c830"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcQDot" ref="a6afc8df58f92fc6dd15658b8a735c830" args="(const State &amp;s, const Vector &amp;u, Vector &amp;qdot) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6afc8df58f92fc6dd15658b8a735c830">SimTK::SimbodyMatterSubsystem::calcQDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate qdot = N(q)*u in O(n) time (very fast). </p>
<p>Note that q is taken from the supplied state while u is an argument to this operator method. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a45137921388b175b5a17330bef09b599"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcQDotDot" ref="a45137921388b175b5a17330bef09b599" args="(const State &amp;s, const Vector &amp;udot, Vector &amp;qdotdot) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a45137921388b175b5a17330bef09b599">SimTK::SimbodyMatterSubsystem::calcQDotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>udot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qdotdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate qdotdot = N(q)*udot + Ndot(q,u)*u in O(n) time (very fast). </p>
<p>Note that q and u are taken from the supplied state while udot is an argument to this operator method. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a3202bd0a85f219c8475a427533cce9b2"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::addInStationForce" ref="a3202bd0a85f219c8475a427533cce9b2" args="(const State &amp;state, MobilizedBodyIndex bodyB, const Vec3 &amp;stationOnB, const Vec3 &amp;forceInG, Vector_&lt; SpatialVec &gt; &amp;bodyForcesInG) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3202bd0a85f219c8475a427533cce9b2">SimTK::SimbodyMatterSubsystem::addInStationForce</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>forceInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add in to the given body forces vector a force applied to a station (fixed point) S on a body B. </p>
<p>The new force is added into the existing spatial force slot for the body. Note that this does not actually apply any forces to the multibody system! This is just a "helper" utility that makes it easier to fill in a body forces array. This has no effect on the system unless you later supply the body forces array for use.</p>
<p>Provide the station in the body frame, force in the Ground frame. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="aafee133053a0230fd545f90793acea4d"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::addInBodyTorque" ref="aafee133053a0230fd545f90793acea4d" args="(const State &amp;state, MobilizedBodyIndex mobodIx, const Vec3 &amp;torqueInG, Vector_&lt; SpatialVec &gt; &amp;bodyForcesInG) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aafee133053a0230fd545f90793acea4d">SimTK::SimbodyMatterSubsystem::addInBodyTorque</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mobodIx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>torqueInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add in to the given body forces vector a torque applied to a body B. </p>
<p>The new torque is added into the existing spatial force slot for the body. Note that this does not actually apply any torques to the multibody system! This is just a "helper" utility that makes it easier to fill in a body forces array. This has no effect on the system unless you later supply the body forces array for use. Provide the torque vector in the Ground frame. </p>

</div>
</div>
<a class="anchor" id="a69b7d894990d382a20bd1820618ea261"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::addInMobilityForce" ref="a69b7d894990d382a20bd1820618ea261" args="(const State &amp;state, MobilizedBodyIndex mobodIx, MobilizerUIndex which, Real f, Vector &amp;mobilityForces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a69b7d894990d382a20bd1820618ea261">SimTK::SimbodyMatterSubsystem::addInMobilityForce</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mobodIx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add in to the given mobility forces vector a scalar generalized force, that is a force or torque applied to a mobilizer generalized speed. </p>
<p>Note that this does not actually apply any forces to the multibody system! This is just a "helper" utility that makes it easier to fill in a mobility forces array. This has no effect on the system unless you later supply the mobility forces array for use. The meaning of a generalized force f is determined by the definition of the corresponding generalized speed u, so that f*u has physical units of power. </p>

</div>
</div>
<a class="anchor" id="a0467f617de57e966bc3c141094037ff4"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::realizeCompositeBodyInertias" ref="a0467f617de57e966bc3c141094037ff4" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0467f617de57e966bc3c141094037ff4">SimTK::SimbodyMatterSubsystem::realizeCompositeBodyInertias</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab91faf31bae6a4bea3ae495b887a473d"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::realizeArticulatedBodyInertias" ref="ab91faf31bae6a4bea3ae495b887a473d" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab91faf31bae6a4bea3ae495b887a473d">SimTK::SimbodyMatterSubsystem::realizeArticulatedBodyInertias</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether articulated body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates the relatively expensive computation of articulated body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed until they are needed at Dynamics stage. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af86d27998b2b85e3ff1ede658d8ad459" title="This is useful for timing computation time for realizeArticulatedBodyInertias(), which otherwise will...">invalidateArticulatedBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c9ead398fe406f45fae30e6ab2e61ce"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getFreeQIndex" ref="a9c9ead398fe406f45fae30e6ab2e61ce" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1QIndex.html">QIndex</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9c9ead398fe406f45fae30e6ab2e61ce">SimTK::SimbodyMatterSubsystem::getFreeQIndex</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a11061f1dccb350c19cb0c5ea37e834bb"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getFreeUIndex" ref="a11061f1dccb350c19cb0c5ea37e834bb" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a11061f1dccb350c19cb0c5ea37e834bb">SimTK::SimbodyMatterSubsystem::getFreeUIndex</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3c42b7bc0d03be0b76bdccb8d603d2"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getFreeUDotIndex" ref="a9a3c42b7bc0d03be0b76bdccb8d603d2" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9a3c42b7bc0d03be0b76bdccb8d603d2">SimTK::SimbodyMatterSubsystem::getFreeUDotIndex</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a79597b03f1bd6a4c5224f0d28d6970f4"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getKnownUDotIndex" ref="a79597b03f1bd6a4c5224f0d28d6970f4" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a79597b03f1bd6a4c5224f0d28d6970f4">SimTK::SimbodyMatterSubsystem::getKnownUDotIndex</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a315a7440c705f22c00172bb29cac7ff6"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::packFreeQ" ref="a315a7440c705f22c00172bb29cac7ff6" args="(const State &amp;s, const Vector &amp;allQ, Vector &amp;packedFreeQ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a315a7440c705f22c00172bb29cac7ff6">SimTK::SimbodyMatterSubsystem::packFreeQ</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>allQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>packedFreeQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afcee048d2447180e24fb95db49da4871"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::unpackFreeQ" ref="afcee048d2447180e24fb95db49da4871" args="(const State &amp;s, const Vector &amp;packedFreeQ, Vector &amp;unpackedFreeQ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afcee048d2447180e24fb95db49da4871">SimTK::SimbodyMatterSubsystem::unpackFreeQ</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>packedFreeQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>unpackedFreeQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4cdaf133ed39188b6cfcfe3ab787bbaf"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::packFreeU" ref="a4cdaf133ed39188b6cfcfe3ab787bbaf" args="(const State &amp;s, const Vector &amp;allU, Vector &amp;packedFreeU) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4cdaf133ed39188b6cfcfe3ab787bbaf">SimTK::SimbodyMatterSubsystem::packFreeU</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>allU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>packedFreeU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af35844913602b0b4c99b0dd0e9f8ea60"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::unpackFreeU" ref="af35844913602b0b4c99b0dd0e9f8ea60" args="(const State &amp;s, const Vector &amp;packedFreeU, Vector &amp;unpackedFreeU) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af35844913602b0b4c99b0dd0e9f8ea60">SimTK::SimbodyMatterSubsystem::unpackFreeU</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>packedFreeU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>unpackedFreeU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615" title="This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will n...">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aae984d90b307ca3dbbcd98feba14e429"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getCompositeBodyInertia" ref="aae984d90b307ca3dbbcd98feba14e429" args="(const State &amp;state, MobilizedBodyIndex mbx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aae984d90b307ca3dbbcd98feba14e429">SimTK::SimbodyMatterSubsystem::getCompositeBodyInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the composite body inertia for a particular mobilized body. </p>
<p>You can call this any time after the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> has been realized to Position stage, however it will first trigger realization of all the composite body inertias if they have not already been calculated. Ground is mobilized body zero; its composite body inertia has infinite mass and principle moments of inertia, and zero center of mass. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0467f617de57e966bc3c141094037ff4" title="This method checks whether composite body inertias have already been computed since the last change t...">realizeCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae7c76cf4f87af5661178f67cfdaa987a"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getArticulatedBodyInertia" ref="ae7c76cf4f87af5661178f67cfdaa987a" args="(const State &amp;state, MobilizedBodyIndex mbx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ab1473db0cef6d6f29b827de9f1b3cb9f">ArticulatedInertia</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae7c76cf4f87af5661178f67cfdaa987a">SimTK::SimbodyMatterSubsystem::getArticulatedBodyInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the articulated body inertia for a particular mobilized body. </p>
<p>You can call this any time after the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> has been realized to Position stage, however it will first trigger expensive realization of all the articulated body inertias if they have not already been calculated. Ground is mobilized body zero; its articulated body inertia is the same as its composite body inertia -- an ordinary Spatial Inertia but with infinite mass and principle moments of inertia, and zero center of mass. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available.">Stage::Position</a></code> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab91faf31bae6a4bea3ae495b887a473d" title="This method checks whether articulated body inertias have already been computed since the last change...">realizeArticulatedBodyInertias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0fd2f8985d689b25c5b8bbc8e6c66d1c"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getGyroscopicForce" ref="a0fd2f8985d689b25c5b8bbc8e6c66d1c" args="(const State &amp;state, MobilizedBodyIndex mbx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0fd2f8985d689b25c5b8bbc8e6c66d1c">SimTK::SimbodyMatterSubsystem::getGyroscopicForce</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the angular velocity-dependent force on the body due to rotational inertia. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a8eb9d41d15bf1c36dfae3abf64d03cc6"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getMobilizerCoriolisAcceleration" ref="a8eb9d41d15bf1c36dfae3abf64d03cc6" args="(const State &amp;state, MobilizedBodyIndex mbx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8eb9d41d15bf1c36dfae3abf64d03cc6">SimTK::SimbodyMatterSubsystem::getMobilizerCoriolisAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the cross-mobilizer incremental contribution to coriolis (angular velocity dependent) acceleration; not too useful, see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcf1b13d1c0b400dd41a77a80c840d30" title="This is the total coriolis acceleration including the effect of the parent&#39;s angular velocity as well...">getTotalCoriolisAcceleration()</a> instead. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="abcf1b13d1c0b400dd41a77a80c840d30"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getTotalCoriolisAcceleration" ref="abcf1b13d1c0b400dd41a77a80c840d30" args="(const State &amp;state, MobilizedBodyIndex mbx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcf1b13d1c0b400dd41a77a80c840d30">SimTK::SimbodyMatterSubsystem::getTotalCoriolisAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the total coriolis acceleration including the effect of the parent's angular velocity as well as the joint's. </p>
<p>This is Jdot*u where J is the system kinematic Jacobian and u is the current set of generalized speeds in the supplied state. It is thus the remainder term in calculation of body accelerations from generalized accelerations udot: since V=J*u, A=J*udot + Jdot*u. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available.">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a980895e021f861e730f6c1021581c498"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getMobilizerCentrifugalForces" ref="a980895e021f861e730f6c1021581c498" args="(const State &amp;state, MobilizedBodyIndex mbx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a980895e021f861e730f6c1021581c498">SimTK::SimbodyMatterSubsystem::getMobilizerCentrifugalForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the angular velocity-dependent force accounting for gyroscopic forces plus coriolis forces due only to the cross-mobilizer velocity; this ignores the parent's velocity and is not too useful -- see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a98b55fad58c0968702ae7c1d92238bcc" title="This is the total angular velocity-dependent force acting on this body, including forces due to corio...">getTotalCentrifugalForces()</a> instead. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13ab0a24de476c174b03fc0dc8d463a3563" title="Forces calculated.">Stage::Dynamics</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a98b55fad58c0968702ae7c1d92238bcc"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getTotalCentrifugalForces" ref="a98b55fad58c0968702ae7c1d92238bcc" args="(const State &amp;state, MobilizedBodyIndex mbx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a98b55fad58c0968702ae7c1d92238bcc">SimTK::SimbodyMatterSubsystem::getTotalCentrifugalForces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the total angular velocity-dependent force acting on this body, including forces due to coriolis acceleration and forces due to rotational inertia. </p>
<dl class="user"><dt><b>Required stage</b></dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13ab0a24de476c174b03fc0dc8d463a3563" title="Forces calculated.">Stage::Dynamics</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a47d5161f2fe40dbb8f10efa00af7dac9"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForcesUsingFreebodyMethod" ref="a47d5161f2fe40dbb8f10efa00af7dac9" args="(const State &amp;state, Vector_&lt; SpatialVec &gt; &amp;forcesAtMInG) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a47d5161f2fe40dbb8f10efa00af7dac9">SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForcesUsingFreebodyMethod</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forcesAtMInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a slower alternative to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">calcMobilizerReactionForces()</a>, for use in regression testing and Simbody development. </p>
<p>This method builds a freebody "diagram" for each body in turn to determine the unknown reaction force at its inboard mobilizer.</p>
<p>The given <em>state</em> must have been realized through Acceleration stage.</p>
<h3>Implementation</h3>
<p>We use a tip-to-base recursion in which we assemble all applied body forces from force elements, constraints, and gyroscopic effects and compare that with the apparent rigid body force determined from F=M*A where M is a body's spatial inertia (in G) and A its already-calculated spatial acceleration. The difference is the missing force applied by the body's mobilizer, i.e. the reaction force. That is shifted to the M frame and reported. Then the equal and opposite reaction is applied to the parent body and included in its collection of applied forces, which can be used to determine its reaction force and so on.</p>
<p>This is is about 3X slower than the method used by <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">calcMobilizerReactionForces()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">calcMobilizerReactionForces()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abbc7059ae4e3f28a79ff3827a6f62615"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::invalidateCompositeBodyInertias" ref="abbc7059ae4e3f28a79ff3827a6f62615" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbc7059ae4e3f28a79ff3827a6f62615">SimTK::SimbodyMatterSubsystem::invalidateCompositeBodyInertias</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0467f617de57e966bc3c141094037ff4" title="This method checks whether composite body inertias have already been computed since the last change t...">realizeCompositeBodyInertias()</a>, which otherwise will not recalculate them if called repeatedly. </p>

</div>
</div>
<a class="anchor" id="af86d27998b2b85e3ff1ede658d8ad459"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::invalidateArticulatedBodyInertias" ref="af86d27998b2b85e3ff1ede658d8ad459" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af86d27998b2b85e3ff1ede658d8ad459">SimTK::SimbodyMatterSubsystem::invalidateArticulatedBodyInertias</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab91faf31bae6a4bea3ae495b887a473d" title="This method checks whether articulated body inertias have already been computed since the last change...">realizeArticulatedBodyInertias()</a>, which otherwise will not recalculate them if called repeatedly. </p>
<p>Note that this also invalidates Dynamics stage and above in the <em>state</em> because articulated body inertias are assumed to be valid after Dynamics stage, regardless of lazy evaluation status. </p>

</div>
</div>
<a class="anchor" id="a05e7167b00a9570218e3b45a03e558e5"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getNumParticles" ref="a05e7167b00a9570218e3b45a03e558e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05e7167b00a9570218e3b45a03e558e5">SimTK::SimbodyMatterSubsystem::getNumParticles</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a7486d4d34ef0982ec41a690b6ed69407"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getAllParticleLocations" ref="a7486d4d34ef0982ec41a690b6ed69407" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7486d4d34ef0982ec41a690b6ed69407">SimTK::SimbodyMatterSubsystem::getAllParticleLocations</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="ae381fcbc2bfd0abe2423a312412569c7"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getAllParticleVelocities" ref="ae381fcbc2bfd0abe2423a312412569c7" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae381fcbc2bfd0abe2423a312412569c7">SimTK::SimbodyMatterSubsystem::getAllParticleVelocities</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="affe6bd028e997de598d994f5b982b969"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getParticleLocation" ref="affe6bd028e997de598d994f5b982b969" args="(const State &amp;s, ParticleIndex p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#affe6bd028e997de598d994f5b982b969">SimTK::SimbodyMatterSubsystem::getParticleLocation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a50c78ab6c6491600feec4368ec72ef05"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getParticleVelocity" ref="a50c78ab6c6491600feec4368ec72ef05" args="(const State &amp;s, ParticleIndex p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a50c78ab6c6491600feec4368ec72ef05">SimTK::SimbodyMatterSubsystem::getParticleVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a21c21918140352352f314410065463ee"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::updAllParticleMasses" ref="a21c21918140352352f314410065463ee" args="(State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a21c21918140352352f314410065463ee">SimTK::SimbodyMatterSubsystem::updAllParticleMasses</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a049f0dca3c1e1bc3d1dff875232d480f"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::setAllParticleMasses" ref="a049f0dca3c1e1bc3d1dff875232d480f" args="(State &amp;s, const Vector &amp;masses) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a049f0dca3c1e1bc3d1dff875232d480f">SimTK::SimbodyMatterSubsystem::setAllParticleMasses</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>masses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a6fd4a9b89ec9b84d471a2ec5522d9884"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::updAllParticleLocations" ref="a6fd4a9b89ec9b84d471a2ec5522d9884" args="(State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6fd4a9b89ec9b84d471a2ec5522d9884">SimTK::SimbodyMatterSubsystem::updAllParticleLocations</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a24d88498b6264888cd1a96e35c06c06a"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::updAllParticleVelocities" ref="a24d88498b6264888cd1a96e35c06c06a" args="(State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a24d88498b6264888cd1a96e35c06c06a">SimTK::SimbodyMatterSubsystem::updAllParticleVelocities</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a90ee991274e97d76f1ab1d9f4e5e8e57"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::updParticleLocation" ref="a90ee991274e97d76f1ab1d9f4e5e8e57" args="(State &amp;s, ParticleIndex p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a90ee991274e97d76f1ab1d9f4e5e8e57">SimTK::SimbodyMatterSubsystem::updParticleLocation</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="ac0d79e2ae7f878ad8cbe95c34fc1c9e0"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::updParticleVelocity" ref="ac0d79e2ae7f878ad8cbe95c34fc1c9e0" args="(State &amp;s, ParticleIndex p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac0d79e2ae7f878ad8cbe95c34fc1c9e0">SimTK::SimbodyMatterSubsystem::updParticleVelocity</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="ab25e295b1ce7f7a3cac8464f612ae4e1"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::setParticleLocation" ref="ab25e295b1ce7f7a3cac8464f612ae4e1" args="(State &amp;s, ParticleIndex p, const Vec3 &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab25e295b1ce7f7a3cac8464f612ae4e1">SimTK::SimbodyMatterSubsystem::setParticleLocation</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a5bd7fd868b468dc276778b6151198f0a"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::setParticleVelocity" ref="a5bd7fd868b468dc276778b6151198f0a" args="(State &amp;s, ParticleIndex p, const Vec3 &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5bd7fd868b468dc276778b6151198f0a">SimTK::SimbodyMatterSubsystem::setParticleVelocity</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a323defc86dc3b64003ebc5f30e6adbea"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::setAllParticleLocations" ref="a323defc86dc3b64003ebc5f30e6adbea" args="(State &amp;s, const Vector_&lt; Vec3 &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a323defc86dc3b64003ebc5f30e6adbea">SimTK::SimbodyMatterSubsystem::setAllParticleLocations</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="aae6a6215af63f530fa402596ef2b268f"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::setAllParticleVelocities" ref="aae6a6215af63f530fa402596ef2b268f" args="(State &amp;s, const Vector_&lt; Vec3 &gt; &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aae6a6215af63f530fa402596ef2b268f">SimTK::SimbodyMatterSubsystem::setAllParticleVelocities</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="ac57c2b4575f9fe88698d1dfcbf991e41"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getAllParticleMasses" ref="ac57c2b4575f9fe88698d1dfcbf991e41" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac57c2b4575f9fe88698d1dfcbf991e41">SimTK::SimbodyMatterSubsystem::getAllParticleMasses</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a4d079d6d020dbfd06e74625bae0c28ba"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getAllParticleAccelerations" ref="a4d079d6d020dbfd06e74625bae0c28ba" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4d079d6d020dbfd06e74625bae0c28ba">SimTK::SimbodyMatterSubsystem::getAllParticleAccelerations</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a class="anchor" id="a24aa7dd470a3f94f88f90369698f5ff7"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::getParticleAcceleration" ref="a24aa7dd470a3f94f88f90369698f5ff7" args="(const State &amp;s, ParticleIndex p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a24aa7dd470a3f94f88f90369698f5ff7">SimTK::SimbodyMatterSubsystem::getParticleAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ada91148391d89bcdcfd812c91cf16fbb"></a><!-- doxytag: member="SimTK::SimbodyMatterSubsystem::operator&lt;&lt;" ref="ada91148391d89bcdcfd812c91cf16fbb" args="(std::ostream &amp;, const SimbodyMatterSubsystem &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump some debug information about the given subsystem to the given output stream; this is <em>not</em> for serialization. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SimbodyMatterSubsystem_8h_source.html">SimbodyMatterSubsystem.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a>      </li>

    <li class="footer">Generated on Mon Jul 14 2014 23:26:05 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
