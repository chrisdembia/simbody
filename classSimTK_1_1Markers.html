<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::Markers Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1Markers.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Markers Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::Markers" --><!-- doxytag: inherits="SimTK::AssemblyCondition" -->
<p>This <a class="el" href="classSimTK_1_1AssemblyCondition.html" title="Define an assembly condition consisting of a scalar goal and/or a related set of assembly error equat...">AssemblyCondition</a> specifies a correspondence between stations on mobilized bodies ("markers") and fixed ground-frame locations ("observations").  
 <a href="classSimTK_1_1Markers.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Assembler_8h_source.html">Assembler.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Markers:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Markers.png" usemap="#SimTK::Markers_map" alt=""/>
  <map id="SimTK::Markers_map" name="SimTK::Markers_map">
<area href="classSimTK_1_1AssemblyCondition.html" title="Define an assembly condition consisting of a scalar goal and/or a related set of assembly error equat..." alt="SimTK::AssemblyCondition" shape="rect" coords="0,0,160,24"/>
</map>
 </div></div>

<p><a href="classSimTK_1_1Markers-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>Marker</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a1d51c07fde85f4c35986d83420b6daf6">SimTK_DEFINE_UNIQUE_LOCAL_INDEX_TYPE</a> (<a class="el" href="classSimTK_1_1Markers.html">Markers</a>, MarkerIx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the MarkerIx type which is just a uniquely-typed int.  <a href="#a1d51c07fde85f4c35986d83420b6daf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a58c7c1f0656b7337c9cc2d86ef93d1b4">SimTK_DEFINE_UNIQUE_LOCAL_INDEX_TYPE</a> (<a class="el" href="classSimTK_1_1Markers.html">Markers</a>, ObservationIx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the ObservationIx type which is just a uniquely-typed int.  <a href="#a58c7c1f0656b7337c9cc2d86ef93d1b4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction and setup</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are used as an extended construction phase for <a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> objects, defining the markers and observations that will be used in the subsequent tracking steps.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aa6e2abd47342cc19365ea0e4910cb62a">Markers</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor creates an empty <a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> <a class="el" href="classSimTK_1_1AssemblyCondition.html" title="Define an assembly condition consisting of a scalar goal and/or a related set of assembly error equat...">AssemblyCondition</a> object that should be filled in with calls to <a class="el" href="classSimTK_1_1Markers.html#abc0271d0b6ea2ae53245bdba97788699" title="Define a new marker attached to a particular MobilizedBody.">addMarker()</a> and optionally <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b" title="Define the meaning of the observation data by giving the MarkerIx associated with each observation...">defineObservationOrder()</a>.  <a href="#aa6e2abd47342cc19365ea0e4910cb62a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MarkerIx&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#abc0271d0b6ea2ae53245bdba97788699">addMarker</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;markerInB, Real weight=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new marker attached to a particular <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>.  <a href="#abc0271d0b6ea2ae53245bdba97788699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MarkerIx&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#ac1e802c74ee429fd9f05f37b18540918">addMarker</a> (<a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> bodyB, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;markerInB, Real weight=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an unnamed marker.  <a href="#ac1e802c74ee429fd9f05f37b18540918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b">defineObservationOrder</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; MarkerIx &gt; &amp;observationOrder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the meaning of the observation data by giving the MarkerIx associated with each observation.  <a href="#ac450d3e8a5ca9fc6f9ef517351a40b7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#adc0c3ddc3b1404a41d4cba4f8616b109">defineObservationOrder</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1String.html">String</a> &gt; &amp;observationOrder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the meaning of the observations by giving the marker name corresponding to each observation, as a SimTK::Array_&lt;String&gt;.  <a href="#adc0c3ddc3b1404a41d4cba4f8616b109"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#ac55f41ffdc54902a6b6ecab35923e9b3">defineObservationOrder</a> (const std::vector&lt; <a class="el" href="classSimTK_1_1String.html">String</a> &gt; &amp;observationOrder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define observation order using an std::vector of <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">SimTK::String</a>.  <a href="#ac55f41ffdc54902a6b6ecab35923e9b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a15b95eb1867c4f4aff89386f84dd3432">defineObservationOrder</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; std::string &gt; &amp;observationOrder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define observation order using an <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> of std::string.  <a href="#a15b95eb1867c4f4aff89386f84dd3432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a2c91f8ea14ab64af77c7e0e5ed0bae30">defineObservationOrder</a> (const std::vector&lt; std::string &gt; &amp;observationOrder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define observation order using an std::vector of std::string.  <a href="#a2c91f8ea14ab64af77c7e0e5ed0bae30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a40cb879b507ba1ca7ccfb2f9458d4d8b">defineObservationOrder</a> (int n, const char *const observationOrder[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define observation order using a C array of const char* names.  <a href="#a40cb879b507ba1ca7ccfb2f9458d4d8b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Retrieve setup information</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are used to query information associated with the construction and setup of this <a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> object.</p>
<p>This information does not normally change during a marker-tracking study, although marker weights may be changed by some inverse kinematics methods. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a766a25810e254d7b0702929469c1b0c7">getNumMarkers</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a count n of the number of currently-defined markers.  <a href="#a766a25810e254d7b0702929469c1b0c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a142f81a6c8a8a6d60b752449a1626c58">getMarkerName</a> (MarkerIx ix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unique marker name assigned to the marker whose index is provided.  <a href="#a142f81a6c8a8a6d60b752449a1626c58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const MarkerIx&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#ae9fd383e7ea769955491b472a30b5840">getMarkerIx</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the marker index associated with the given marker name.  <a href="#ae9fd383e7ea769955491b472a30b5840"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aee3cbc9dd57222daabd416d3d7835fba">getMarkerWeight</a> (MarkerIx mx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weight currently in use for the specified marker; this can be changed dynamically via <a class="el" href="classSimTK_1_1Markers.html#a2ac25a264d121e6cbd086dfc5c15b91e" title="Change the weight associated with a particular marker.">changeMarkerWeight()</a>.  <a href="#aee3cbc9dd57222daabd416d3d7835fba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#ab1af0ee241663449e463ac646d1522b9">getMarkerBody</a> (MarkerIx mx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of the body associated with this marker.  <a href="#ab1af0ee241663449e463ac646d1522b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a31f224abe215c3adb9a11c951067b548">getMarkerStation</a> (MarkerIx mx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the station (fixed location in its body frame) of the given marker.  <a href="#a31f224abe215c3adb9a11c951067b548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a495668c602d682856e77e985c7f39973">getNumObservations</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of observations that were defined via the last call to <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b" title="Define the meaning of the observation data by giving the MarkerIx associated with each observation...">defineObservationOrder()</a>.  <a href="#a495668c602d682856e77e985c7f39973"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ObservationIx&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aea11020fcfaa689b6aec7e3c09a440e1">getObservationIxForMarker</a> (MarkerIx mx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ObservationIx of the observation that is currently associated with the given marker, or an invalid index if the marker doesn't have any corresponding observation (in which case it is being ignored).  <a href="#aea11020fcfaa689b6aec7e3c09a440e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#ac4fdb5c76bfc5dbcb8987d18161aa60d">hasObservation</a> (MarkerIx mx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the supplied marker is currently associated with an observation.  <a href="#ac4fdb5c76bfc5dbcb8987d18161aa60d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MarkerIx&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aba7e5312de9497eca32af0b373da96df">getMarkerIxForObservation</a> (ObservationIx ox) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MarkerIx of the marker that is associated with the given observation, or an invalid index if the observation doesn't correspond to any marker (in which case it is being ignored).  <a href="#aba7e5312de9497eca32af0b373da96df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aeae66cd0ffdbc1921315fb91c0ec7e87">hasMarker</a> (ObservationIx ox) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the supplied observation is currently associated with a marker.  <a href="#aeae66cd0ffdbc1921315fb91c0ec7e87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; MarkerIx &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a18525539b6cf09457eee00a5d5fa1cc9">getMarkersOnBody</a> (<a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> assembly condition organizes the markers by body after initialization; call this to get the list of markers on any particular body.  <a href="#a18525539b6cf09457eee00a5d5fa1cc9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods can be called between tracking steps to make step-to-step changes without reinitialization, and to access the current values of step-to-step data including the resulting marker errors.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#ae3ae751ebb077500cbcb2f1a119f83a5">moveOneObservation</a> (ObservationIx ox, const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;observation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a single marker's observed location without moving any of the others.  <a href="#ae3ae751ebb077500cbcb2f1a119f83a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aaa0334d457a01f078a517824544415bc">moveAllObservations</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;observations)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the observed marker locations for a new observation frame.  <a href="#aaa0334d457a01f078a517824544415bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a2ac25a264d121e6cbd086dfc5c15b91e">changeMarkerWeight</a> (MarkerIx mx, Real weight)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the weight associated with a particular marker.  <a href="#a2ac25a264d121e6cbd086dfc5c15b91e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a97007bfaeb2d727d4827f32174b96441">getObservation</a> (ObservationIx ox) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current value of the location for this observation.  <a href="#a97007bfaeb2d727d4827f32174b96441"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>, <br class="typebreak"/>
ObservationIx &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a88c53b2ff899bd8c10a926ae78314886">getAllObservations</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current values of all the observed locations.  <a href="#a88c53b2ff899bd8c10a926ae78314886"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aa2557d3a435aa8f537db6e3ab3a3241e">findCurrentMarkerLocation</a> (MarkerIx mx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the current value of the internal state, calculate the ground frame location of a particular marker.  <a href="#aa2557d3a435aa8f537db6e3ab3a3241e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a738192d37cefa7f62a1a22f7b27e255f">findCurrentMarkerError</a> (MarkerIx mx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the current value of the internal state, calculate the distance between the given marker's current location and its corresponding observed location (unweighted).  <a href="#a738192d37cefa7f62a1a22f7b27e255f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a2f996fffa0879e42066e251a08ecfab8">findCurrentMarkerErrorSquared</a> (MarkerIx mx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the current value of the internal state, calculate the (unweighted) square of the distance between the given marker's current location and its corresponding observed location (the squared distance is less expensive to compute than the distance).  <a href="#a2f996fffa0879e42066e251a08ecfab8"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">AssemblyCondition virtuals</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are the implementations of the <a class="el" href="classSimTK_1_1AssemblyCondition.html" title="Define an assembly condition consisting of a scalar goal and/or a related set of assembly error equat...">AssemblyCondition</a> virtuals.</p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273">calcErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;err) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the amount by which this assembly condition is violated by the q values in the given state, with one scalar error per assembly equation returned in <em>err</em>.  <a href="#aa2b403b3918e31cab7bb4f9362170273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#aeff24d4b6f38111004a124ed6dac3819">calcErrorJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;jacobian) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Override to supply an analytic Jacobian for the assembly errors returned by <a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273" title="Calculate the amount by which this assembly condition is violated by the q values in the given state...">calcErrors()</a>.  <a href="#aeff24d4b6f38111004a124ed6dac3819"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a67979f7f2240c5f4283231a6785c6a98">getNumErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Override to supply an efficient method for determining how many errors will be returned by <a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273" title="Calculate the amount by which this assembly condition is violated by the q values in the given state...">calcErrors()</a>.  <a href="#a67979f7f2240c5f4283231a6785c6a98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#af9755ac3efc0ef4b91335f0c9dcdf6c2">calcGoal</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, Real &amp;goal) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the current contribution (&gt;= 0) of this assembly condition to the goal value that is being minimized.  <a href="#af9755ac3efc0ef4b91335f0c9dcdf6c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a25842c4fbae6f2b6813e78453ead0ab6">calcGoalGradient</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;grad) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Override to supply an analytic gradient for this assembly condition's goal.  <a href="#a25842c4fbae6f2b6813e78453ead0ab6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a362321f41dd568a89b6b7bddd0e6e1bf">initializeCondition</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called whenever the <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a> is initialized in case this assembly condition wants to do some internal work before getting started.  <a href="#a362321f41dd568a89b6b7bddd0e6e1bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Markers.html#a2db6bcfc6f539439e174bc16df7e7433">uninitializeCondition</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called whenever the containing <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a> is uninitialized in case this assembly condition has some cleanup to do.  <a href="#a2db6bcfc6f539439e174bc16df7e7433"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This <a class="el" href="classSimTK_1_1AssemblyCondition.html" title="Define an assembly condition consisting of a scalar goal and/or a related set of assembly error equat...">AssemblyCondition</a> specifies a correspondence between stations on mobilized bodies ("markers") and fixed ground-frame locations ("observations"). </p>
<p>The idea is to adjust the q's so that each marker is located close to its corresponding observation. This is normally used as a goal since we don't expect a perfect fit, but you can use these as a set of assembly error conditions if there are enough degrees of freedom to achieve a near-perfect solution.</p>
<p><a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> are defined one at a time and assigned sequential marker index values of type Markers::MarkerIx. They may optionally be given unique, case-sensitive names, and we will keep a map from name to MarkerIx. A default name will be assigned if none is given. A weight is assigned to every marker, with default weight=1. We do not expect that all the markers will be used; markers with weights of zero will not be included in the study, nor will markers for which no observation is given.</p>
<p>Once specified, the marker definitions do not change during a series of inverse kinematic (tracking) steps. The observations, on the other hand, are expected to come from a time series of experimental measurements of marker locations and will be different at every step. They typically come from a file organized by "frame", meaning an observation time and a set of observed locations, one per marker, corresponding to that time. During initial setup, the number of observations per frame and their correspondence to the defined markers is specified. They can be in any order, may skip some markers, and may include data for markers that are not defined. However, once initialized each frame must supply the same information in the same order. Data for an unobserved marker can be provided as NaN in which case it will be ignored in that frame. The frame time is supplied to the track() method which initiates assembly for a frame.</p>
<p>Observation-marker correspondence maps a ObservationIx to a unique MarkerIx. By default, we'll expect to get an observation for each marker and that the observation order and the marker order are the same, i.e. ObservationIx==MarkerIx for every marker. However, you can instead define observation/marker correspondence yourself, (<em>after</em> all markers have been defined), via one of the <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b" title="Define the meaning of the observation data by giving the MarkerIx associated with each observation...">defineObservationOrder()</a> methods. This is done by supplying an array of MarkerIx values, or an array of Marker names, with the array elements ordered by ObservationIx. Any invalid marker index or unrecognized marker name means we will ignore values provide for that observation; similarly, any markers whose index or name is not specified at all will be ignored. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa6e2abd47342cc19365ea0e4910cb62a"></a><!-- doxytag: member="SimTK::Markers::Markers" ref="aa6e2abd47342cc19365ea0e4910cb62a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Markers.html#aa6e2abd47342cc19365ea0e4910cb62a">SimTK::Markers::Markers</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default constructor creates an empty <a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> <a class="el" href="classSimTK_1_1AssemblyCondition.html" title="Define an assembly condition consisting of a scalar goal and/or a related set of assembly error equat...">AssemblyCondition</a> object that should be filled in with calls to <a class="el" href="classSimTK_1_1Markers.html#abc0271d0b6ea2ae53245bdba97788699" title="Define a new marker attached to a particular MobilizedBody.">addMarker()</a> and optionally <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b" title="Define the meaning of the observation data by giving the MarkerIx associated with each observation...">defineObservationOrder()</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1d51c07fde85f4c35986d83420b6daf6"></a><!-- doxytag: member="SimTK::Markers::SimTK_DEFINE_UNIQUE_LOCAL_INDEX_TYPE" ref="a1d51c07fde85f4c35986d83420b6daf6" args="(Markers, MarkerIx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Markers.html#a1d51c07fde85f4c35986d83420b6daf6">SimTK::Markers::SimTK_DEFINE_UNIQUE_LOCAL_INDEX_TYPE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Markers.html">Markers</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the MarkerIx type which is just a uniquely-typed int. </p>

</div>
</div>
<a class="anchor" id="a58c7c1f0656b7337c9cc2d86ef93d1b4"></a><!-- doxytag: member="SimTK::Markers::SimTK_DEFINE_UNIQUE_LOCAL_INDEX_TYPE" ref="a58c7c1f0656b7337c9cc2d86ef93d1b4" args="(Markers, ObservationIx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Markers.html#a1d51c07fde85f4c35986d83420b6daf6">SimTK::Markers::SimTK_DEFINE_UNIQUE_LOCAL_INDEX_TYPE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Markers.html">Markers</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObservationIx&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the ObservationIx type which is just a uniquely-typed int. </p>

</div>
</div>
<a class="anchor" id="abc0271d0b6ea2ae53245bdba97788699"></a><!-- doxytag: member="SimTK::Markers::addMarker" ref="abc0271d0b6ea2ae53245bdba97788699" args="(const String &amp;name, MobilizedBodyIndex bodyB, const Vec3 &amp;markerInB, Real weight=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MarkerIx <a class="el" href="classSimTK_1_1Markers.html#abc0271d0b6ea2ae53245bdba97788699">SimTK::Markers::addMarker</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>markerInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>weight</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define a new marker attached to a particular <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. </p>
<p>Note that a marker will be ignored unless an observation is provided for it. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A unique name to be used to identify this marker. If the name is empty or blank, a default name will be supplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bodyB</td><td>The <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> to which this marker is fixed. <a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> on Ground are allowed but will be ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">markerInB</td><td>This is the position vector of the marker in <em>bodyB's</em> local frame, also known as the marker's "station" on <em>bodyB</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>An optional weight for use in defining the objective function, which combines errors in this marker's position with errors in other markers' positions. If the weight is zero this marker is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unique marker index number assigned to this marker. These are assigned sequentially as the marker are added. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Adding a marker invalidates any observation/marker correspondence; be sure to call <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b" title="Define the meaning of the observation data by giving the MarkerIx associated with each observation...">defineObservationOrder()</a> <em>after</em> defining all your markers. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1e802c74ee429fd9f05f37b18540918"></a><!-- doxytag: member="SimTK::Markers::addMarker" ref="ac1e802c74ee429fd9f05f37b18540918" args="(MobilizedBodyIndex bodyB, const Vec3 &amp;markerInB, Real weight=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MarkerIx <a class="el" href="classSimTK_1_1Markers.html#abc0271d0b6ea2ae53245bdba97788699">SimTK::Markers::addMarker</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>markerInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>weight</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define an unnamed marker. </p>
<p>A default name will be assigned; that name will be "_UNNAMED_XX" where XX is the MarkerIx assigned to that marker (don't use names of that form yourself). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Markers.html#abc0271d0b6ea2ae53245bdba97788699" title="Define a new marker attached to a particular MobilizedBody.">addMarker</a>(name,...) for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="ac450d3e8a5ca9fc6f9ef517351a40b7b"></a><!-- doxytag: member="SimTK::Markers::defineObservationOrder" ref="ac450d3e8a5ca9fc6f9ef517351a40b7b" args="(const Array_&lt; MarkerIx &gt; &amp;observationOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b">SimTK::Markers::defineObservationOrder</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; MarkerIx &gt; &amp;&#160;</td>
          <td class="paramname"><em>observationOrder</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the meaning of the observation data by giving the MarkerIx associated with each observation. </p>
<p>The length of the array of marker indices defines the expected number of observations to be provided for each observation frame. Any marker index that is supplied with an invalid value means that the corresponding observation will be present in the supplied data but should be ignored. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">observationOrder</td><td>This is an array of marker index values, one per observation, that defines both the number of expected observations and the marker corresponding to each observation. <a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> can be in any order; an invalid marker index means that observation will be provided but should be ignored; markers whose indices are never listed are ignored. If <em>observationOrder</em> is supplied as a zero-length array, then we'll assume there are as many observations as markers and that their indices match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If you don't call this method at all, a default correspondence will be defined as described for a zero-length <em>observationOrder</em> array (that is, same number of observations and markers with matching indices). Whenever you add a new marker, any previously defined observation order is forgotten so the default correspondence will be used unless you call this again. </dd></dl>

</div>
</div>
<a class="anchor" id="adc0c3ddc3b1404a41d4cba4f8616b109"></a><!-- doxytag: member="SimTK::Markers::defineObservationOrder" ref="adc0c3ddc3b1404a41d4cba4f8616b109" args="(const Array_&lt; String &gt; &amp;observationOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b">SimTK::Markers::defineObservationOrder</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1String.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>observationOrder</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the meaning of the observations by giving the marker name corresponding to each observation, as a SimTK::Array_&lt;String&gt;. </p>
<p>The length of the array of marker indices defines the expected number of observations. Any marker name that is unrecognized or empty means that the corresponding observation will be present in the supplied data but should be ignored. </p>

</div>
</div>
<a class="anchor" id="ac55f41ffdc54902a6b6ecab35923e9b3"></a><!-- doxytag: member="SimTK::Markers::defineObservationOrder" ref="ac55f41ffdc54902a6b6ecab35923e9b3" args="(const std::vector&lt; String &gt; &amp;observationOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b">SimTK::Markers::defineObservationOrder</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSimTK_1_1String.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>observationOrder</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define observation order using an std::vector of <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">SimTK::String</a>. </p>

</div>
</div>
<a class="anchor" id="a15b95eb1867c4f4aff89386f84dd3432"></a><!-- doxytag: member="SimTK::Markers::defineObservationOrder" ref="a15b95eb1867c4f4aff89386f84dd3432" args="(const Array_&lt; std::string &gt; &amp;observationOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b">SimTK::Markers::defineObservationOrder</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>observationOrder</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define observation order using an <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> of std::string. </p>

</div>
</div>
<a class="anchor" id="a2c91f8ea14ab64af77c7e0e5ed0bae30"></a><!-- doxytag: member="SimTK::Markers::defineObservationOrder" ref="a2c91f8ea14ab64af77c7e0e5ed0bae30" args="(const std::vector&lt; std::string &gt; &amp;observationOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b">SimTK::Markers::defineObservationOrder</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>observationOrder</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define observation order using an std::vector of std::string. </p>

</div>
</div>
<a class="anchor" id="a40cb879b507ba1ca7ccfb2f9458d4d8b"></a><!-- doxytag: member="SimTK::Markers::defineObservationOrder" ref="a40cb879b507ba1ca7ccfb2f9458d4d8b" args="(int n, const char *const observationOrder[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b">SimTK::Markers::defineObservationOrder</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>observationOrder</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define observation order using a C array of const char* names. </p>

</div>
</div>
<a class="anchor" id="a766a25810e254d7b0702929469c1b0c7"></a><!-- doxytag: member="SimTK::Markers::getNumMarkers" ref="a766a25810e254d7b0702929469c1b0c7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Markers.html#a766a25810e254d7b0702929469c1b0c7">SimTK::Markers::getNumMarkers</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a count n of the number of currently-defined markers. </p>
<p>Valid marker index values (of type Markers::MarkerIx) are 0..n-1. </p>

</div>
</div>
<a class="anchor" id="a142f81a6c8a8a6d60b752449a1626c58"></a><!-- doxytag: member="SimTK::Markers::getMarkerName" ref="a142f81a6c8a8a6d60b752449a1626c58" args="(MarkerIx ix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; <a class="el" href="classSimTK_1_1Markers.html#a142f81a6c8a8a6d60b752449a1626c58">SimTK::Markers::getMarkerName</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the unique marker name assigned to the marker whose index is provided. </p>
<p>If the marker was defined without a name, this will return the default name that was assigned to it. </p>

</div>
</div>
<a class="anchor" id="ae9fd383e7ea769955491b472a30b5840"></a><!-- doxytag: member="SimTK::Markers::getMarkerIx" ref="ae9fd383e7ea769955491b472a30b5840" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const MarkerIx <a class="el" href="classSimTK_1_1Markers.html#ae9fd383e7ea769955491b472a30b5840">SimTK::Markers::getMarkerIx</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the marker index associated with the given marker name. </p>
<p>If the name is not recognized the returned index will be invalid (test with index.isValid()). </p>

</div>
</div>
<a class="anchor" id="aee3cbc9dd57222daabd416d3d7835fba"></a><!-- doxytag: member="SimTK::Markers::getMarkerWeight" ref="aee3cbc9dd57222daabd416d3d7835fba" args="(MarkerIx mx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Markers.html#aee3cbc9dd57222daabd416d3d7835fba">SimTK::Markers::getMarkerWeight</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the weight currently in use for the specified marker; this can be changed dynamically via <a class="el" href="classSimTK_1_1Markers.html#a2ac25a264d121e6cbd086dfc5c15b91e" title="Change the weight associated with a particular marker.">changeMarkerWeight()</a>. </p>

</div>
</div>
<a class="anchor" id="ab1af0ee241663449e463ac646d1522b9"></a><!-- doxytag: member="SimTK::Markers::getMarkerBody" ref="ab1af0ee241663449e463ac646d1522b9" args="(MarkerIx mx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> <a class="el" href="classSimTK_1_1Markers.html#ab1af0ee241663449e463ac646d1522b9">SimTK::Markers::getMarkerBody</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of the body associated with this marker. </p>

</div>
</div>
<a class="anchor" id="a31f224abe215c3adb9a11c951067b548"></a><!-- doxytag: member="SimTK::Markers::getMarkerStation" ref="a31f224abe215c3adb9a11c951067b548" args="(MarkerIx mx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Markers.html#a31f224abe215c3adb9a11c951067b548">SimTK::Markers::getMarkerStation</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the station (fixed location in its body frame) of the given marker. </p>

</div>
</div>
<a class="anchor" id="a495668c602d682856e77e985c7f39973"></a><!-- doxytag: member="SimTK::Markers::getNumObservations" ref="a495668c602d682856e77e985c7f39973" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Markers.html#a495668c602d682856e77e985c7f39973">SimTK::Markers::getNumObservations</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of observations that were defined via the last call to <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b" title="Define the meaning of the observation data by giving the MarkerIx associated with each observation...">defineObservationOrder()</a>. </p>
<p>These are not necessarily all being used. If <a class="el" href="classSimTK_1_1Markers.html#ac450d3e8a5ca9fc6f9ef517351a40b7b" title="Define the meaning of the observation data by giving the MarkerIx associated with each observation...">defineObservationOrder()</a> was never called, we'll expect the same number of observations as markers although that won't be set up until the <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a> has been initialized. </p>

</div>
</div>
<a class="anchor" id="aea11020fcfaa689b6aec7e3c09a440e1"></a><!-- doxytag: member="SimTK::Markers::getObservationIxForMarker" ref="aea11020fcfaa689b6aec7e3c09a440e1" args="(MarkerIx mx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObservationIx <a class="el" href="classSimTK_1_1Markers.html#aea11020fcfaa689b6aec7e3c09a440e1">SimTK::Markers::getObservationIxForMarker</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the ObservationIx of the observation that is currently associated with the given marker, or an invalid index if the marker doesn't have any corresponding observation (in which case it is being ignored). </p>
<p>An exception will be thrown if the given MarkerIx is not in the range 0..<a class="el" href="classSimTK_1_1Markers.html#a766a25810e254d7b0702929469c1b0c7" title="Return a count n of the number of currently-defined markers.">getNumMarkers()</a>-1. </p>

</div>
</div>
<a class="anchor" id="ac4fdb5c76bfc5dbcb8987d18161aa60d"></a><!-- doxytag: member="SimTK::Markers::hasObservation" ref="ac4fdb5c76bfc5dbcb8987d18161aa60d" args="(MarkerIx mx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Markers.html#ac4fdb5c76bfc5dbcb8987d18161aa60d">SimTK::Markers::hasObservation</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the supplied marker is currently associated with an observation. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Markers.html#aea11020fcfaa689b6aec7e3c09a440e1" title="Return the ObservationIx of the observation that is currently associated with the given marker...">getObservationIxForMarker()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aba7e5312de9497eca32af0b373da96df"></a><!-- doxytag: member="SimTK::Markers::getMarkerIxForObservation" ref="aba7e5312de9497eca32af0b373da96df" args="(ObservationIx ox) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MarkerIx <a class="el" href="classSimTK_1_1Markers.html#aba7e5312de9497eca32af0b373da96df">SimTK::Markers::getMarkerIxForObservation</a> </td>
          <td>(</td>
          <td class="paramtype">ObservationIx&#160;</td>
          <td class="paramname"><em>ox</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the MarkerIx of the marker that is associated with the given observation, or an invalid index if the observation doesn't correspond to any marker (in which case it is being ignored). </p>
<p>An exception will be thrown if the given ObservationIx is not in the range 0..<a class="el" href="classSimTK_1_1Markers.html#a495668c602d682856e77e985c7f39973" title="Return the number of observations that were defined via the last call to defineObservationOrder().">getNumObservations()</a>-1. </p>

</div>
</div>
<a class="anchor" id="aeae66cd0ffdbc1921315fb91c0ec7e87"></a><!-- doxytag: member="SimTK::Markers::hasMarker" ref="aeae66cd0ffdbc1921315fb91c0ec7e87" args="(ObservationIx ox) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Markers.html#aeae66cd0ffdbc1921315fb91c0ec7e87">SimTK::Markers::hasMarker</a> </td>
          <td>(</td>
          <td class="paramtype">ObservationIx&#160;</td>
          <td class="paramname"><em>ox</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the supplied observation is currently associated with a marker. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Markers.html#aba7e5312de9497eca32af0b373da96df" title="Return the MarkerIx of the marker that is associated with the given observation, or an invalid index ...">getMarkerIxForObservation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a18525539b6cf09457eee00a5d5fa1cc9"></a><!-- doxytag: member="SimTK::Markers::getMarkersOnBody" ref="a18525539b6cf09457eee00a5d5fa1cc9" args="(MobilizedBodyIndex mbx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;MarkerIx&gt;&amp; <a class="el" href="classSimTK_1_1Markers.html#a18525539b6cf09457eee00a5d5fa1cc9">SimTK::Markers::getMarkersOnBody</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="classSimTK_1_1Markers.html" title="This AssemblyCondition specifies a correspondence between stations on mobilized bodies (&quot;markers&quot;) an...">Markers</a> assembly condition organizes the markers by body after initialization; call this to get the list of markers on any particular body. </p>
<p>If necessary the <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a> will be initialized. It is an error if this assembly condition has not yet been adopted by an <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a>. </p>

</div>
</div>
<a class="anchor" id="ae3ae751ebb077500cbcb2f1a119f83a5"></a><!-- doxytag: member="SimTK::Markers::moveOneObservation" ref="ae3ae751ebb077500cbcb2f1a119f83a5" args="(ObservationIx ox, const Vec3 &amp;observation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#ae3ae751ebb077500cbcb2f1a119f83a5">SimTK::Markers::moveOneObservation</a> </td>
          <td>(</td>
          <td class="paramtype">ObservationIx&#160;</td>
          <td class="paramname"><em>ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>observation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move a single marker's observed location without moving any of the others. </p>
<p>If the value contains a NaN, this marker/observation pair will be ignored the next time the assembly goal cost function is calculated. </p>

</div>
</div>
<a class="anchor" id="aaa0334d457a01f078a517824544415bc"></a><!-- doxytag: member="SimTK::Markers::moveAllObservations" ref="aaa0334d457a01f078a517824544415bc" args="(const Array_&lt; Vec3 &gt; &amp;observations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#aaa0334d457a01f078a517824544415bc">SimTK::Markers::moveAllObservations</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>observations</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the observed marker locations for a new observation frame. </p>
<p>These are the locations to which we will next attempt to move all the corresponding markers. Note that not all observations necessarily have corresponding markers defined; locations of those markers must still be provided here but they will be ignored. The length of the <em>allObservations</em> array must be the same as the number of defined observations; you can obtain that using <a class="el" href="classSimTK_1_1Markers.html#a495668c602d682856e77e985c7f39973" title="Return the number of observations that were defined via the last call to defineObservationOrder().">getNumObservations()</a>. Any observations that contain a NaN will be ignored; that marker/observation pair will not be used in the next calculation of the assembly goal cost function. </p>

</div>
</div>
<a class="anchor" id="a2ac25a264d121e6cbd086dfc5c15b91e"></a><!-- doxytag: member="SimTK::Markers::changeMarkerWeight" ref="a2ac25a264d121e6cbd086dfc5c15b91e" args="(MarkerIx mx, Real weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#a2ac25a264d121e6cbd086dfc5c15b91e">SimTK::Markers::changeMarkerWeight</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the weight associated with a particular marker. </p>
<p>If this is just a quantitative change (e.g., weight was 0.3 now it is 0.4) then this does not require any reinitialization and will affect the goal calculation next time it is done. If the weight changes to or from zero (a qualitative change) then this will uninitialize the <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a> and all the internal data structures will be changed to remove or add this marker from the list of active markers. If you want to temporarily ignore a marker without reinitializing, you can set its corresponding observation to NaN in which case it will simply be skipped when the goal value is calculated. </p>

</div>
</div>
<a class="anchor" id="a97007bfaeb2d727d4827f32174b96441"></a><!-- doxytag: member="SimTK::Markers::getObservation" ref="a97007bfaeb2d727d4827f32174b96441" args="(ObservationIx ox) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; <a class="el" href="classSimTK_1_1Markers.html#a97007bfaeb2d727d4827f32174b96441">SimTK::Markers::getObservation</a> </td>
          <td>(</td>
          <td class="paramtype">ObservationIx&#160;</td>
          <td class="paramname"><em>ox</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current value of the location for this observation. </p>
<p>This is where we will try to move the corresponding marker if there is one. The result might be NaN if there is no current value for this observation; you can check using Vec3's <a class="el" href="group__isFinite.html#gaaefb475975dd2a35bf2248e16aadaf8d">isFinite()</a> method. </p>

</div>
</div>
<a class="anchor" id="a88c53b2ff899bd8c10a926ae78314886"></a><!-- doxytag: member="SimTK::Markers::getAllObservations" ref="a88c53b2ff899bd8c10a926ae78314886" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a>,ObservationIx&gt;&amp; <a class="el" href="classSimTK_1_1Markers.html#a88c53b2ff899bd8c10a926ae78314886">SimTK::Markers::getAllObservations</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current values of all the observed locations. </p>
<p>This is where we will try to move the corresponding markers, for those observations that have corresponding markers defined. Some of the values may be NaN if there is currently no corresponding observation. Note that these are indexed by ObservationIx; use <a class="el" href="classSimTK_1_1Markers.html#aea11020fcfaa689b6aec7e3c09a440e1" title="Return the ObservationIx of the observation that is currently associated with the given marker...">getObservationIxForMarker()</a> to map a MarkerIx to its corresponding ObservationIx. </p>

</div>
</div>
<a class="anchor" id="aa2557d3a435aa8f537db6e3ab3a3241e"></a><!-- doxytag: member="SimTK::Markers::findCurrentMarkerLocation" ref="aa2557d3a435aa8f537db6e3ab3a3241e" args="(MarkerIx mx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ae91357250892ce29d39ebf17e2aa85da">Vec3</a> <a class="el" href="classSimTK_1_1Markers.html#aa2557d3a435aa8f537db6e3ab3a3241e">SimTK::Markers::findCurrentMarkerLocation</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Using the current value of the internal state, calculate the ground frame location of a particular marker. </p>
<p>The difference between this location and the corresponding observation is the current error for this marker. </p>

</div>
</div>
<a class="anchor" id="a738192d37cefa7f62a1a22f7b27e255f"></a><!-- doxytag: member="SimTK::Markers::findCurrentMarkerError" ref="a738192d37cefa7f62a1a22f7b27e255f" args="(MarkerIx mx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Markers.html#a738192d37cefa7f62a1a22f7b27e255f">SimTK::Markers::findCurrentMarkerError</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Using the current value of the internal state, calculate the distance between the given marker's current location and its corresponding observed location (unweighted). </p>
<p>If the marker is not associated with an observation, or if the observed location is missing (indicated by a NaN value), then the error is reported as zero. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you actually want the square of the distance, you can save some computation time by using <a class="el" href="classSimTK_1_1Markers.html#a2f996fffa0879e42066e251a08ecfab8" title="Using the current value of the internal state, calculate the (unweighted) square of the distance betw...">findCurrentMarkerErrorSquared()</a> which avoids the square root needed to find the actual distance. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Markers.html#a2f996fffa0879e42066e251a08ecfab8" title="Using the current value of the internal state, calculate the (unweighted) square of the distance betw...">findCurrentMarkerErrorSquared()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2f996fffa0879e42066e251a08ecfab8"></a><!-- doxytag: member="SimTK::Markers::findCurrentMarkerErrorSquared" ref="a2f996fffa0879e42066e251a08ecfab8" args="(MarkerIx mx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classSimTK_1_1Markers.html#a2f996fffa0879e42066e251a08ecfab8">SimTK::Markers::findCurrentMarkerErrorSquared</a> </td>
          <td>(</td>
          <td class="paramtype">MarkerIx&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Using the current value of the internal state, calculate the (unweighted) square of the distance between the given marker's current location and its corresponding observed location (the squared distance is less expensive to compute than the distance). </p>
<p>If the marker is not associated with an observation, or if the observed location is missing (indicated by a NaN value), then the error is reported as zero. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1Markers.html#a738192d37cefa7f62a1a22f7b27e255f" title="Using the current value of the internal state, calculate the distance between the given marker&#39;s curr...">findCurrentMarkerError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b403b3918e31cab7bb4f9362170273"></a><!-- doxytag: member="SimTK::Markers::calcErrors" ref="aa2b403b3918e31cab7bb4f9362170273" args="(const State &amp;state, Vector &amp;err) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273">SimTK::Markers::calcErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the amount by which this assembly condition is violated by the q values in the given state, with one scalar error per assembly equation returned in <em>err</em>. </p>
<p>The functional return should be zero if successful; negative values are reserved with -1 meaning "not implemented"; return a positive value if your implementation is unable to evaluate the error at the current state. If this method is not implemented then you must implement <a class="el" href="classSimTK_1_1Markers.html#af9755ac3efc0ef4b91335f0c9dcdf6c2" title="Calculate the current contribution (&gt;= 0) of this assembly condition to the goal value that is being ...">calcGoal()</a> and this assembly condition may only be used as a goal, not a requirement. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1AssemblyCondition.html#a5822a085a33f147e38f644960eca14f8">SimTK::AssemblyCondition</a>.</p>

</div>
</div>
<a class="anchor" id="aeff24d4b6f38111004a124ed6dac3819"></a><!-- doxytag: member="SimTK::Markers::calcErrorJacobian" ref="aeff24d4b6f38111004a124ed6dac3819" args="(const State &amp;state, Matrix &amp;jacobian) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Markers.html#aeff24d4b6f38111004a124ed6dac3819">SimTK::Markers::calcErrorJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override to supply an analytic Jacobian for the assembly errors returned by <a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273" title="Calculate the amount by which this assembly condition is violated by the q values in the given state...">calcErrors()</a>. </p>
<p>The returned Jacobian must be nErr X nFreeQs; that is, if there is only one assembly error equation the returned matrix is a single row (that's the transpose of the gradient). The functional return should be zero if this succeeds; negative values are reserved with the default implementation returning -1 which indicates that the Jacobian must be calculated numerically using the <a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273" title="Calculate the amount by which this assembly condition is violated by the q values in the given state...">calcErrors()</a> method. Return a positive value if your implementation is unable to evaluate the Jacobian at the current state. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1AssemblyCondition.html#ada27c0d7a3244181b63ae6d6257d7136">SimTK::AssemblyCondition</a>.</p>

</div>
</div>
<a class="anchor" id="a67979f7f2240c5f4283231a6785c6a98"></a><!-- doxytag: member="SimTK::Markers::getNumErrors" ref="a67979f7f2240c5f4283231a6785c6a98" args="(const State &amp;state) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Markers.html#a67979f7f2240c5f4283231a6785c6a98">SimTK::Markers::getNumErrors</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override to supply an efficient method for determining how many errors will be returned by <a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273" title="Calculate the amount by which this assembly condition is violated by the q values in the given state...">calcErrors()</a>. </p>
<p>Otherwise the default implementation determines this by making a call to <a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273" title="Calculate the amount by which this assembly condition is violated by the q values in the given state...">calcErrors()</a> and returning the size of the returned error vector. The functional return should be zero if this succeeds; negative values are reserved; return a positive value if your implementation of this method can't determine the number of errors with the given state (unlikely!). </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1AssemblyCondition.html#a35aeddcb486378a30a1a52372c105482">SimTK::AssemblyCondition</a>.</p>

</div>
</div>
<a class="anchor" id="af9755ac3efc0ef4b91335f0c9dcdf6c2"></a><!-- doxytag: member="SimTK::Markers::calcGoal" ref="af9755ac3efc0ef4b91335f0c9dcdf6c2" args="(const State &amp;state, Real &amp;goal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Markers.html#af9755ac3efc0ef4b91335f0c9dcdf6c2">SimTK::Markers::calcGoal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>goal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the current contribution (&gt;= 0) of this assembly condition to the goal value that is being minimized. </p>
<p>If this isn't overridden we'll generate it by combining the m errors returned by <a class="el" href="classSimTK_1_1Markers.html#aa2b403b3918e31cab7bb4f9362170273" title="Calculate the amount by which this assembly condition is violated by the q values in the given state...">calcErrors()</a> in a mean sum of squares: goal = err^2/m. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1AssemblyCondition.html#a83f4776f8c3dd52a83e7684797e0411e">SimTK::AssemblyCondition</a>.</p>

</div>
</div>
<a class="anchor" id="a25842c4fbae6f2b6813e78453ead0ab6"></a><!-- doxytag: member="SimTK::Markers::calcGoalGradient" ref="a25842c4fbae6f2b6813e78453ead0ab6" args="(const State &amp;state, Vector &amp;grad) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Markers.html#a25842c4fbae6f2b6813e78453ead0ab6">SimTK::Markers::calcGoalGradient</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override to supply an analytic gradient for this assembly condition's goal. </p>
<p>The returned gradient must be nFreeQ X 1; that is, it is a column vector giving the partial derivative of the goal with respect to each of the free q's in order. The functional return should be zero if this succeeds. The default implementation return -1 which indicates that the gradient must be calculated numerically using the <a class="el" href="classSimTK_1_1Markers.html#af9755ac3efc0ef4b91335f0c9dcdf6c2" title="Calculate the current contribution (&gt;= 0) of this assembly condition to the goal value that is being ...">calcGoal()</a> method. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1AssemblyCondition.html#a71c99b10a6a207e2f6a10900f85778c4">SimTK::AssemblyCondition</a>.</p>

</div>
</div>
<a class="anchor" id="a362321f41dd568a89b6b7bddd0e6e1bf"></a><!-- doxytag: member="SimTK::Markers::initializeCondition" ref="a362321f41dd568a89b6b7bddd0e6e1bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Markers.html#a362321f41dd568a89b6b7bddd0e6e1bf">SimTK::Markers::initializeCondition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is called whenever the <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a> is initialized in case this assembly condition wants to do some internal work before getting started. </p>
<p>None of the other virtual methods will be called until this one has been, except possibly the destructor. The set of free q's and the internal <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> are valid at this point and can be retrieved from the <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a> stored in the base class. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1AssemblyCondition.html#aef6f7b295f057904287b70b683101921">SimTK::AssemblyCondition</a>.</p>

</div>
</div>
<a class="anchor" id="a2db6bcfc6f539439e174bc16df7e7433"></a><!-- doxytag: member="SimTK::Markers::uninitializeCondition" ref="a2db6bcfc6f539439e174bc16df7e7433" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Markers.html#a2db6bcfc6f539439e174bc16df7e7433">SimTK::Markers::uninitializeCondition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is called whenever the containing <a class="el" href="classSimTK_1_1Assembler.html" title="This Study attempts to find a configuration (set of joint coordinates q) of a Simbody MultibodySystem...">Assembler</a> is uninitialized in case this assembly condition has some cleanup to do. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1AssemblyCondition.html#a21bbea246047f2a686c5673ea4f3c633">SimTK::AssemblyCondition</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Assembler_8h_source.html">Assembler.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1Markers.html">Markers</a>      </li>

    <li class="footer">Generated on Wed Oct 9 2013 08:38:51 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
