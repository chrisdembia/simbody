<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: common.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">common.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef SimTK_SimTKCOMMON_COMMON_H_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define SimTK_SimTKCOMMON_COMMON_H_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* -------------------------------------------------------------------------- *</span>
<a name="l00005"></a>00005 <span class="comment"> *                       Simbody(tm): SimTKcommon                             *</span>
<a name="l00006"></a>00006 <span class="comment"> * -------------------------------------------------------------------------- *</span>
<a name="l00007"></a>00007 <span class="comment"> * This is part of the SimTK biosimulation toolkit originating from           *</span>
<a name="l00008"></a>00008 <span class="comment"> * Simbios, the NIH National Center for Physics-Based Simulation of           *</span>
<a name="l00009"></a>00009 <span class="comment"> * Biological Structures at Stanford, funded under the NIH Roadmap for        *</span>
<a name="l00010"></a>00010 <span class="comment"> * Medical Research, grant U54 GM072970. See https://simtk.org/home/simbody.  *</span>
<a name="l00011"></a>00011 <span class="comment"> *                                                                            *</span>
<a name="l00012"></a>00012 <span class="comment"> * Portions copyright (c) 2005-12 Stanford University and the Authors.        *</span>
<a name="l00013"></a>00013 <span class="comment"> * Authors: Michael Sherman                                                   *</span>
<a name="l00014"></a>00014 <span class="comment"> * Contributors:                                                              *</span>
<a name="l00015"></a>00015 <span class="comment"> *                                                                            *</span>
<a name="l00016"></a>00016 <span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may    *</span>
<a name="l00017"></a>00017 <span class="comment"> * not use this file except in compliance with the License. You may obtain a  *</span>
<a name="l00018"></a>00018 <span class="comment"> * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *</span>
<a name="l00019"></a>00019 <span class="comment"> *                                                                            *</span>
<a name="l00020"></a>00020 <span class="comment"> * Unless required by applicable law or agreed to in writing, software        *</span>
<a name="l00021"></a>00021 <span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,          *</span>
<a name="l00022"></a>00022 <span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *</span>
<a name="l00023"></a>00023 <span class="comment"> * See the License for the specific language governing permissions and        *</span>
<a name="l00024"></a>00024 <span class="comment"> * limitations under the License.                                             *</span>
<a name="l00025"></a>00025 <span class="comment"> * -------------------------------------------------------------------------- */</span>
<a name="l00026"></a>00026 
<a name="l00039"></a>00039 <span class="comment">// Provide doxygen documentation for the SimTK namespace.</span>
<a name="l00040"></a>00040 
<a name="l00049"></a>00049 <span class="comment">// Define shared doxygen &quot;modules&quot; and sub-modules here. We&#39;ll put things </span>
<a name="l00050"></a>00050 <span class="comment">// in them at various places when appropriate.</span>
<a name="l00051"></a>00051 
<a name="l00091"></a>00091 <span class="comment">/*****************************/</span>
<a name="l00092"></a>00092 <span class="comment">/* ANSI-C COMPATIBLE SECTION */</span>
<a name="l00093"></a>00093 <span class="comment">/*****************************/</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="comment">/* Set up a few compile-time options that affect all SimTK Core headers. */</span>
<a name="l00096"></a>00096 
<a name="l00104"></a>00104 <span class="preprocessor">#ifndef SimTK_DEFAULT_PRECISION</span>
<a name="l00105"></a><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#ad1b7c549db323942591b6ca95158437b">00105</a> <span class="preprocessor"></span><span class="preprocessor">#   define SimTK_DEFAULT_PRECISION 2</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>
<a name="l00108"></a>00108 <span class="preprocessor">#if   (SimTK_DEFAULT_PRECISION == 1)</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110     <span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a609c1052c1f2ca0d1289affa6d54af4d" title="This type is for use in C; in C++ use SimTK::Real instead.">SimTK_Real</a>;
<a name="l00111"></a>00111 <span class="preprocessor">#elif (SimTK_DEFAULT_PRECISION == 2)</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>
<a name="l00113"></a><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a609c1052c1f2ca0d1289affa6d54af4d">00113</a>     <span class="keyword">typedef</span> <span class="keywordtype">double</span> <a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a609c1052c1f2ca0d1289affa6d54af4d" title="This type is for use in C; in C++ use SimTK::Real instead.">SimTK_Real</a>;
<a name="l00114"></a>00114 <span class="preprocessor">#elif (SimTK_DEFAULT_PRECISION == 4)</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a>00116     <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span> <a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a609c1052c1f2ca0d1289affa6d54af4d" title="This type is for use in C; in C++ use SimTK::Real instead.">SimTK_Real</a>;
<a name="l00117"></a>00117 <span class="preprocessor">#else</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">    #error ILLEGAL VALUE FOR DEFAULT PRECISION</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>
<a name="l00121"></a>00121 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor">    #if defined(__cplusplus)</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">        #include &lt;cstdio&gt;</span>
<a name="l00124"></a>00124 <span class="preprocessor">        #define SimTK_DEBUG(s) std::printf(&quot;DBG: &quot; s)</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_DEBUG1(s,a1) std::printf(&quot;DBG: &quot; s,a1)    </span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_DEBUG2(s,a1,a2) std::printf(&quot;DBG: &quot; s,a1,a2)  </span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_DEBUG3(s,a1,a2,a3) std::printf(&quot;DBG: &quot; s,a1,a2,a3)    </span>
<a name="l00128"></a>00128 <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_DEBUG4(s,a1,a2,a3,a4) std::printf(&quot;DBG: &quot; s,a1,a2,a3,a4)</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span><span class="preprocessor">    #else</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span><span class="preprocessor">        #include &lt;stdio.h&gt;</span>
<a name="l00131"></a><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#aa0d4f8de62a78d8a4a9a27893915ce29">00131</a> <span class="preprocessor">        #define SimTK_DEBUG(s) printf(&quot;DBG: &quot; s)</span>
<a name="l00132"></a><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a05959b808cf4a656f6071644b3a883ee">00132</a> <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_DEBUG1(s,a1) printf(&quot;DBG: &quot; s,a1) </span>
<a name="l00133"></a><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a1f51a75b6fa8550cc80878084e3859ff">00133</a> <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_DEBUG2(s,a1,a2) printf(&quot;DBG: &quot; s,a1,a2)   </span>
<a name="l00134"></a><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0f865fbaed2bc16da59ff3a853637684">00134</a> <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_DEBUG3(s,a1,a2,a3) printf(&quot;DBG: &quot; s,a1,a2,a3) </span>
<a name="l00135"></a><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a84b59e5d458cc116f65aa723ddddf285">00135</a> <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_DEBUG4(s,a1,a2,a3,a4) printf(&quot;DBG: &quot; s,a1,a2,a3,a4)</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span><span class="preprocessor">    #define SimTK_DEBUG(s)</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">    #define SimTK_DEBUG1(s,a1)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">    #define SimTK_DEBUG2(s,a1,a2)</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="preprocessor">    #define SimTK_DEBUG3(s,a1,a2,a3)    </span>
<a name="l00142"></a>00142 <span class="preprocessor"></span><span class="preprocessor">    #define SimTK_DEBUG4(s,a1,a2,a3,a4)</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>
<a name="l00145"></a>00145 <span class="comment">/*</span>
<a name="l00146"></a>00146 <span class="comment"> * Shared libraries are messy in Visual Studio. We have to distinguish three</span>
<a name="l00147"></a>00147 <span class="comment"> * cases:</span>
<a name="l00148"></a>00148 <span class="comment"> *   (1) this header is being used to build the SimTKcommon shared library (dllexport)</span>
<a name="l00149"></a>00149 <span class="comment"> *   (2) this header is being used by a *client* of the SimTKcommon shared</span>
<a name="l00150"></a>00150 <span class="comment"> *       library (dllimport)</span>
<a name="l00151"></a>00151 <span class="comment"> *   (3) we are building the SimTKcommon static library, or the client is</span>
<a name="l00152"></a>00152 <span class="comment"> *       being compiled with the expectation of linking with the</span>
<a name="l00153"></a>00153 <span class="comment"> *       SimTKcommon static library (nothing special needed)</span>
<a name="l00154"></a>00154 <span class="comment"> * In the CMake script for building this library, we define one of the symbols</span>
<a name="l00155"></a>00155 <span class="comment"> *     SimTK_SimTKCOMMON_BUILDING_{SHARED|STATIC}_LIBRARY</span>
<a name="l00156"></a>00156 <span class="comment"> * Client code normally has no special symbol defined, in which case we&#39;ll</span>
<a name="l00157"></a>00157 <span class="comment"> * assume it wants to use the shared library. However, if the client defines</span>
<a name="l00158"></a>00158 <span class="comment"> * the symbol SimTK_USE_STATIC_LIBRARIES we&#39;ll suppress the dllimport so</span>
<a name="l00159"></a>00159 <span class="comment"> * that the client code can be linked with static libraries. Note that</span>
<a name="l00160"></a>00160 <span class="comment"> * the client symbol is not library dependent, while the library symbols</span>
<a name="l00161"></a>00161 <span class="comment"> * affect only the SimTKcommon library, meaning that other libraries can</span>
<a name="l00162"></a>00162 <span class="comment"> * be clients of this one. However, we are assuming all-static or all-shared.</span>
<a name="l00163"></a>00163 <span class="comment"> */</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor">    #ifdef _MSC_VER</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning(disable:4231) </span><span class="comment">/*need to use &#39;extern&#39; template explicit instantiation*/</span>
<a name="l00168"></a>00168 <span class="preprocessor">    #pragma warning(disable:4251) </span><span class="comment">/*no DLL interface for type of member of exported class*/</span>
<a name="l00169"></a>00169 <span class="preprocessor">    #pragma warning(disable:4275) </span><span class="comment">/*no DLL interface for base class of exported class*/</span>
<a name="l00170"></a>00170 <span class="preprocessor">    #pragma warning(disable:4345) </span><span class="comment">/*warning about PODs being default-initialized*/</span>
<a name="l00171"></a>00171 <span class="preprocessor">    #endif</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">    #if defined(SimTK_SimTKCOMMON_BUILDING_SHARED_LIBRARY)</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_SimTKCOMMON_EXPORT __declspec(dllexport)</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span>        <span class="comment">/* Keep MS VC++ quiet when it tries to instantiate incomplete template classes in a DLL. */</span>
<a name="l00175"></a>00175 <span class="preprocessor">        #ifdef _MSC_VER</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="preprocessor">        #pragma warning(disable:4661)</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span><span class="preprocessor">    #elif defined(SimTK_SimTKCOMMON_BUILDING_STATIC_LIBRARY) || defined(SimTK_USE_STATIC_LIBRARIES)</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_SimTKCOMMON_EXPORT</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">    #else</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span><span class="preprocessor">        #define SimTK_SimTKCOMMON_EXPORT __declspec(dllimport) </span><span class="comment">/*i.e., a client of a shared library*/</span>
<a name="l00182"></a>00182 <span class="preprocessor">    #endif</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>    <span class="comment">/* VC++ tries to be secure by leaving bounds checking on for STL containers</span>
<a name="l00184"></a>00184 <span class="comment">     * even in Release mode. This macro exists to disable that feature and can</span>
<a name="l00185"></a>00185 <span class="comment">     * result in a considerable speedup.</span>
<a name="l00186"></a>00186 <span class="comment">     * CAUTION: every linked-together compilation unit must have this set the same</span>
<a name="l00187"></a>00187 <span class="comment">     * way. Everyone who properly includes this file first is fine; but as of this</span>
<a name="l00188"></a>00188 <span class="comment">     * writing Simmath&#39;s IpOpt doesn&#39;t do so.</span>
<a name="l00189"></a>00189 <span class="comment">     * NOTE: Microsoft corrected this problem with VC10 -- the feature is </span>
<a name="l00190"></a>00190 <span class="comment">     * disabled by default in that compiler and later.</span>
<a name="l00191"></a>00191 <span class="comment">     */</span>
<a name="l00192"></a>00192     <span class="comment">/* (sherm 081204 disabling for now: doesn&#39;t work on VC++ 8 and is </span>
<a name="l00193"></a>00193 <span class="comment">     * tricky on VC++ 9 because all libraries, including 3rd party, must</span>
<a name="l00194"></a>00194 <span class="comment">     * be built the same way). Better to use the SimTK::Array_&lt;T&gt; class in</span>
<a name="l00195"></a>00195 <span class="comment">     * place of the std::vector&lt;T&gt; class to get better performance.</span>
<a name="l00196"></a>00196 <span class="comment">     #ifdef NDEBUG</span>
<a name="l00197"></a>00197 <span class="comment">        #undef _SECURE_SCL</span>
<a name="l00198"></a>00198 <span class="comment">        #define _SECURE_SCL 0</span>
<a name="l00199"></a>00199 <span class="comment">     #endif</span>
<a name="l00200"></a>00200 <span class="comment">     */</span>
<a name="l00201"></a>00201 <span class="preprocessor">#else</span>
<a name="l00202"></a><a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">00202</a> <span class="preprocessor"></span><span class="preprocessor">    #define SimTK_SimTKCOMMON_EXPORT // Linux, Mac</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span>
<a name="l00205"></a>00205 <span class="comment">/* Every SimTK Core library must provide these two routines, with the library</span>
<a name="l00206"></a>00206 <span class="comment"> * name appearing after the &quot;version_&quot; and &quot;about_&quot;.</span>
<a name="l00207"></a>00207 <span class="comment"> */</span>
<a name="l00208"></a>00208 <span class="preprocessor">#if defined(__cplusplus)</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00210"></a>00210 <span class="preprocessor">#endif</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>
<a name="l00212"></a>00212     <a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#aa3b937f5d36adc0d575230ec1677be0f" title="Obtain version information for the currently-loaded SimTKcommon library.">SimTK_version_SimTKcommon</a>(<span class="keywordtype">int</span>* major, <span class="keywordtype">int</span>* minor, <span class="keywordtype">int</span>* build);
<a name="l00219"></a>00219     <a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a0d6328a25a1642485423dcbe6d450a7d">SimTK_SimTKCOMMON_EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#abfcf9088ea1bc8db75c6ad20ce887df8" title="Obtain &quot;about&quot; information for the currently-loaded SimTKcommon library.">SimTK_about_SimTKcommon</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keywordtype">int</span> maxlen, <span class="keywordtype">char</span>* value);
<a name="l00220"></a>00220 <span class="preprocessor">#if defined(__cplusplus)</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>}
<a name="l00222"></a>00222 <span class="preprocessor">#endif</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span>
<a name="l00224"></a>00224 <span class="comment">/************************************/</span>
<a name="l00225"></a>00225 <span class="comment">/* END OF ANSI-C COMPATIBLE SECTION */</span>
<a name="l00226"></a>00226 <span class="comment">/************************************/</span>
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="preprocessor">#if defined(__cplusplus)</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span>
<a name="l00230"></a>00230 <span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00231"></a>00231 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00232"></a>00232 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00233"></a>00233 <span class="preprocessor">#include &lt;cfloat&gt;</span>
<a name="l00234"></a>00234 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00235"></a>00235 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00236"></a>00236 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="comment">/* Transition macros for C++11 support. VC10 and VC11 have partial support for</span>
<a name="l00239"></a>00239 <span class="comment">C++11, early VC&#39;s do not. Currently we&#39;re assuming no support from gcc. */</span>
<a name="l00240"></a>00240 <span class="preprocessor">#ifndef SWIG</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span><span class="preprocessor">    #if _MSC_VER&gt;=1700 </span><span class="comment">/* VC11 or higher */</span>
<a name="l00242"></a>00242 <span class="preprocessor">        #define OVERRIDE_11  override</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span><span class="preprocessor">        #define FINAL_11     final</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span><span class="preprocessor">    #elif _MSC_VER==1600 </span><span class="comment">/* VC10 */</span>
<a name="l00245"></a>00245 <span class="preprocessor">        #define OVERRIDE_11  override</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span><span class="preprocessor">        #define FINAL_11     sealed</span>
<a name="l00247"></a>00247 <span class="preprocessor"></span><span class="preprocessor">    #else </span><span class="comment">/* gcc or earlier VC */</span>
<a name="l00248"></a>00248 <span class="preprocessor">        #define OVERRIDE_11</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span><span class="preprocessor">        #define FINAL_11</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00251"></a>00251 <span class="preprocessor"></span><span class="preprocessor">#else </span><span class="comment">/* Swigging */</span>
<a name="l00252"></a>00252 <span class="preprocessor">    #define OVERRIDE_11</span>
<a name="l00253"></a>00253 <span class="preprocessor"></span><span class="preprocessor">    #define FINAL_11</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="comment">/* Currently (Microsoft VC++ 9) these C99-compatible floating point functions </span>
<a name="l00258"></a>00258 <span class="comment">are missing. We&#39;ll create them here and install them into namespace std.</span>
<a name="l00259"></a>00259 <span class="comment">TODO: This should be removed when these are available. */</span>
<a name="l00260"></a>00260 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00261"></a>00261 <span class="preprocessor"></span><span class="keyword">namespace </span>std {
<a name="l00262"></a>00262 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isfinite(<span class="keywordtype">float</span> f) {<span class="keywordflow">return</span> _finite(f) != 0;}
<a name="l00263"></a>00263 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isfinite(<span class="keywordtype">double</span> d) {<span class="keywordflow">return</span> _finite(d) != 0;}
<a name="l00264"></a>00264 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isfinite(<span class="keywordtype">long</span> <span class="keywordtype">double</span> l) {<span class="keywordflow">return</span> _finite(l) != 0;}
<a name="l00265"></a>00265 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isnan(<span class="keywordtype">float</span> f) {<span class="keywordflow">return</span> _isnan(f) != 0;}
<a name="l00266"></a>00266 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isnan(<span class="keywordtype">double</span> d) {<span class="keywordflow">return</span> _isnan(d) != 0;}
<a name="l00267"></a>00267 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isnan(<span class="keywordtype">long</span> <span class="keywordtype">double</span> l) {<span class="keywordflow">return</span> _isnan(l) != 0;}
<a name="l00268"></a>00268 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isinf(<span class="keywordtype">float</span> f) {<span class="keywordflow">return</span> <a class="code" href="namespaceSimTK.html#a63210772f3bd9e4b2eb35309408b173e">std::abs</a>(f)==std::numeric_limits&lt;float&gt;::infinity();}
<a name="l00269"></a>00269 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isinf(<span class="keywordtype">double</span> d) {<span class="keywordflow">return</span> <a class="code" href="namespaceSimTK.html#a63210772f3bd9e4b2eb35309408b173e">std::abs</a>(d)==std::numeric_limits&lt;double&gt;::infinity();}
<a name="l00270"></a>00270 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isinf(<span class="keywordtype">long</span> <span class="keywordtype">double</span> l) {<span class="keywordflow">return</span> <a class="code" href="namespaceSimTK.html#a63210772f3bd9e4b2eb35309408b173e">std::abs</a>(l)==std::numeric_limits&lt;double&gt;::infinity();}
<a name="l00271"></a>00271 <span class="keyword">inline</span> <span class="keywordtype">bool</span> signbit(<span class="keywordtype">float</span> f) {<span class="keywordflow">return</span> (*reinterpret_cast&lt;unsigned*&gt;(&amp;f) &amp; 0x80000000U) != 0;}
<a name="l00272"></a>00272 <span class="keyword">inline</span> <span class="keywordtype">bool</span> signbit(<span class="keywordtype">double</span> d) {<span class="keywordflow">return</span> (*reinterpret_cast&lt;unsigned long long*&gt;(&amp;d)
<a name="l00273"></a>00273                                &amp; 0x8000000000000000ULL) != 0;}
<a name="l00274"></a>00274 <span class="keyword">inline</span> <span class="keywordtype">bool</span> signbit(<span class="keywordtype">long</span> <span class="keywordtype">double</span> l) {<span class="keywordflow">return</span> (*reinterpret_cast&lt;unsigned long long*&gt;(&amp;l)
<a name="l00275"></a>00275                                     &amp; 0x8000000000000000ULL) != 0;}
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 <span class="preprocessor">#endif</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="keyword">namespace </span>SimTK {
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="comment">// This utility answers the question &quot;if I put this integral value in an int and then</span>
<a name="l00284"></a>00284 <span class="comment">// get it back, will its value be the same?&quot;.</span>
<a name="l00285"></a>00285 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">bool</span>)            {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00286"></a>00286 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">char</span>)            {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00287"></a>00287 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)   {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00288"></a>00288 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)     {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00289"></a>00289 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">short</span>)           {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00290"></a>00290 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)  {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00291"></a>00291 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">int</span>)             {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00292"></a>00292 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  u) {<span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(int(u)) == u;}
<a name="l00293"></a>00293 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">long</span> i)          {<span class="keywordflow">return</span> long(<span class="keywordtype">int</span>(i)) == i;}
<a name="l00294"></a>00294 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> u) {<span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(int(u)) == u;}
<a name="l00295"></a>00295 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">long</span> <span class="keywordtype">long</span> i)          {<span class="keywordflow">return</span> (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)(int(i)) == i;}
<a name="l00296"></a>00296 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> u) {<span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)(int(u)) == u;}
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="comment">// This utility answers the question &quot;is this integral value a nonnegative number</span>
<a name="l00299"></a>00299 <span class="comment">// that can be stored in an int?&quot;.</span>
<a name="l00300"></a>00300 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">bool</span>)             {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00301"></a>00301 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">char</span> c)           {<span class="keywordflow">return</span> c &gt;= 0;}
<a name="l00302"></a>00302 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)    {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00303"></a>00303 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">signed</span> <span class="keywordtype">char</span> c)    {<span class="keywordflow">return</span> c &gt;= 0;}
<a name="l00304"></a>00304 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">short</span> s)          {<span class="keywordflow">return</span> s &gt;= 0;}
<a name="l00305"></a>00305 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)   {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00306"></a>00306 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">int</span>  i)           {<span class="keywordflow">return</span> i &gt;= 0;}
<a name="l00307"></a>00307 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">long</span> l)           {<span class="keywordflow">return</span> canStoreInInt(l) &amp;&amp; l &gt;= 0;}
<a name="l00308"></a>00308 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">long</span> <span class="keywordtype">long</span> l)      {<span class="keywordflow">return</span> canStoreInInt(l) &amp;&amp; l &gt;= 0;}
<a name="l00309"></a>00309 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  u)  {<span class="keywordflow">return</span> canStoreInInt(u);}
<a name="l00310"></a>00310 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> u)  {<span class="keywordflow">return</span> canStoreInInt(u);}
<a name="l00311"></a>00311 <span class="keyword">inline</span> <span class="keywordtype">bool</span> canStoreInNonnegativeInt(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> u) {<span class="keywordflow">return</span> canStoreInInt(u);}
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="comment">// This utility answers the question of whether an integer is suitable as a size</span>
<a name="l00314"></a>00314 <span class="comment">// limited by the given maximum size. Signed types must be checked for being</span>
<a name="l00315"></a>00315 <span class="comment">// nonegative; doing that with unsigned types leads to compiler warnings.</span>
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="comment">// char can be signed or unsigned depending on the compiler; assume signed.</span>
<a name="l00318"></a>00318 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">char</span>           sz, <span class="keywordtype">char</span>           mx){<span class="keywordflow">return</span> 0&lt;=sz&amp;&amp;sz&lt;=mx;}
<a name="l00319"></a>00319 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>    sz, <span class="keywordtype">signed</span> <span class="keywordtype">char</span>    mx){<span class="keywordflow">return</span> 0&lt;=sz&amp;&amp;sz&lt;=mx;}
<a name="l00320"></a>00320 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">short</span>          sz, <span class="keywordtype">short</span>          mx){<span class="keywordflow">return</span> 0&lt;=sz&amp;&amp;sz&lt;=mx;}
<a name="l00321"></a>00321 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">int</span>            sz, <span class="keywordtype">int</span>            mx){<span class="keywordflow">return</span> 0&lt;=sz&amp;&amp;sz&lt;=mx;}
<a name="l00322"></a>00322 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">long</span>           sz, <span class="keywordtype">long</span>           mx){<span class="keywordflow">return</span> 0&lt;=sz&amp;&amp;sz&lt;=mx;}
<a name="l00323"></a>00323 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">long</span> <span class="keywordtype">long</span>      sz, <span class="keywordtype">long</span> <span class="keywordtype">long</span>      mx){<span class="keywordflow">return</span> 0&lt;=sz&amp;&amp;sz&lt;=mx;}
<a name="l00324"></a>00324 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  sz, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  mx){<span class="keywordflow">return</span> sz&lt;=mx;}
<a name="l00325"></a>00325 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> sz, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> mx){<span class="keywordflow">return</span> sz&lt;=mx;}
<a name="l00326"></a>00326 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   sz, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   mx){<span class="keywordflow">return</span> sz&lt;=mx;}
<a name="l00327"></a>00327 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  sz, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  mx){<span class="keywordflow">return</span> sz&lt;=mx;}
<a name="l00328"></a>00328 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSizeInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> sz, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> mx){<span class="keywordflow">return</span> sz&lt;=mx;}
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="comment">// This utility answers the question of whether an integer is suitable as an index</span>
<a name="l00331"></a>00331 <span class="comment">// for an array limited by the given maximum size. Signed types must be checked for being</span>
<a name="l00332"></a>00332 <span class="comment">// nonegative; doing that with unsigned types leads to compiler warnings. This is just</span>
<a name="l00333"></a>00333 <span class="comment">// like the &quot;size in range&quot; check above except the maximum value allowed for an index</span>
<a name="l00334"></a>00334 <span class="comment">// is one less that the size.</span>
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 <span class="comment">// char can be signed or unsigned depending on the compiler; assume signed.</span>
<a name="l00337"></a>00337 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">char</span>           ix, <span class="keywordtype">char</span>           sz){<span class="keywordflow">return</span> 0&lt;=ix&amp;&amp;ix&lt;sz;}
<a name="l00338"></a>00338 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>    ix, <span class="keywordtype">signed</span> <span class="keywordtype">char</span>    sz){<span class="keywordflow">return</span> 0&lt;=ix&amp;&amp;ix&lt;sz;}
<a name="l00339"></a>00339 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">short</span>          ix, <span class="keywordtype">short</span>          sz){<span class="keywordflow">return</span> 0&lt;=ix&amp;&amp;ix&lt;sz;}
<a name="l00340"></a>00340 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">int</span>            ix, <span class="keywordtype">int</span>            sz){<span class="keywordflow">return</span> 0&lt;=ix&amp;&amp;ix&lt;sz;}
<a name="l00341"></a>00341 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">long</span>           ix, <span class="keywordtype">long</span>           sz){<span class="keywordflow">return</span> 0&lt;=ix&amp;&amp;ix&lt;sz;}
<a name="l00342"></a>00342 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">long</span> <span class="keywordtype">long</span>      ix, <span class="keywordtype">long</span> <span class="keywordtype">long</span>      sz){<span class="keywordflow">return</span> 0&lt;=ix&amp;&amp;ix&lt;sz;}
<a name="l00343"></a>00343 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  ix, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  sz){<span class="keywordflow">return</span> ix&lt;sz;}
<a name="l00344"></a>00344 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> ix, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> sz){<span class="keywordflow">return</span> ix&lt;sz;}
<a name="l00345"></a>00345 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   ix, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   sz){<span class="keywordflow">return</span> ix&lt;sz;}
<a name="l00346"></a>00346 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  ix, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  sz){<span class="keywordflow">return</span> ix&lt;sz;}
<a name="l00347"></a>00347 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isIndexInRange(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ix, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> sz){<span class="keywordflow">return</span> ix&lt;sz;}
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 <span class="comment">// This utility answers the question: is this integral value nonnegative? The answer</span>
<a name="l00350"></a>00350 <span class="comment">// is always true for unsigned types and you&#39;ll get a warning from some compilers if</span>
<a name="l00351"></a>00351 <span class="comment">// you check.</span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">bool</span>)              {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00354"></a>00354 <span class="comment">// char can be signed or unsigned depending on the compiler; assume signed.</span>
<a name="l00355"></a>00355 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">char</span>        n)     {<span class="keywordflow">return</span> n&gt;=0;}
<a name="l00356"></a>00356 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">signed</span> <span class="keywordtype">char</span> n)     {<span class="keywordflow">return</span> n&gt;=0;}
<a name="l00357"></a>00357 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">short</span>       n)     {<span class="keywordflow">return</span> n&gt;=0;}
<a name="l00358"></a>00358 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">int</span>         n)     {<span class="keywordflow">return</span> n&gt;=0;}
<a name="l00359"></a>00359 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">long</span>        n)     {<span class="keywordflow">return</span> n&gt;=0;}
<a name="l00360"></a>00360 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">long</span> <span class="keywordtype">long</span>   n)     {<span class="keywordflow">return</span> n&gt;=0;}
<a name="l00361"></a>00361 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)     {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00362"></a>00362 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)    {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00363"></a>00363 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)      {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00364"></a>00364 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)     {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00365"></a>00365 <span class="keyword">inline</span> <span class="keywordtype">bool</span> isNonnegative(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>){<span class="keywordflow">return</span> <span class="keyword">true</span>;}
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="comment">// A NaN-like value for unique index types created using the macro</span>
<a name="l00368"></a>00368 <span class="comment">// SimTK_DEFINE_UNIQUE_INDEX_TYPE(). A unique, typed constant with</span>
<a name="l00369"></a>00369 <span class="comment">// this numerical value is created for each index type.</span>
<a name="l00370"></a>00370 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> InvalidIndex = -1111111111;
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 
<a name="l00406"></a>00406 <span class="preprocessor">#define SimTK_DEFINE_UNIQUE_INDEX_TYPE(NAME)                   \</span>
<a name="l00407"></a>00407 <span class="preprocessor">    SimTK_DEFINE_AND_EXPORT_UNIQUE_LOCAL_INDEX_TYPE(,,,NAME)   \</span>
<a name="l00408"></a>00408 <span class="preprocessor">    static const NAME Invalid ## NAME;</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>
<a name="l00412"></a>00412 <span class="preprocessor">#define SimTK_DEFINE_AND_EXPORT_UNIQUE_INDEX_TYPE(EXPORT,NAME)     \</span>
<a name="l00413"></a>00413 <span class="preprocessor">    SimTK_DEFINE_AND_EXPORT_UNIQUE_LOCAL_INDEX_TYPE(EXPORT,,,NAME) \</span>
<a name="l00414"></a>00414 <span class="preprocessor">    static const NAME Invalid ## NAME;</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>
<a name="l00417"></a>00417 <span class="preprocessor">#define SimTK_DEFINE_UNIQUE_LOCAL_INDEX_TYPE(PARENT,NAME) \</span>
<a name="l00418"></a>00418 <span class="preprocessor">    SimTK_DEFINE_AND_EXPORT_UNIQUE_LOCAL_INDEX_TYPE(,PARENT,::,NAME)</span>
<a name="l00419"></a>00419 <span class="preprocessor"></span>
<a name="l00422"></a>00422 <span class="preprocessor">#define SimTK_DEFINE_AND_EXPORT_UNIQUE_LOCAL_INDEX_TYPE(EXPORT,PARENT,SEP,NAME)   \</span>
<a name="l00423"></a>00423 <span class="preprocessor">class EXPORT NAME {                         \</span>
<a name="l00424"></a>00424 <span class="preprocessor">    int ix;                                 \</span>
<a name="l00425"></a>00425 <span class="preprocessor">public:                                     \</span>
<a name="l00426"></a>00426 <span class="preprocessor">    NAME() : ix(SimTK::InvalidIndex) { }       \</span>
<a name="l00427"></a>00427 <span class="preprocessor">    explicit NAME(int i) : ix(i)      {assert(i&gt;=0 || i==SimTK::InvalidIndex);} \</span>
<a name="l00428"></a>00428 <span class="preprocessor">    explicit NAME(long l): ix((int)l) {assert(SimTK::canStoreInNonnegativeInt(l));}    \</span>
<a name="l00429"></a>00429 <span class="preprocessor">    explicit NAME(unsigned int  u)  : ix((int)u)  {assert(SimTK::canStoreInInt(u));}   \</span>
<a name="l00430"></a>00430 <span class="preprocessor">    explicit NAME(unsigned long ul) : ix((int)ul) {assert(SimTK::canStoreInInt(ul));}  \</span>
<a name="l00431"></a>00431 <span class="preprocessor">    operator int() const {return ix;}               \</span>
<a name="l00432"></a>00432 <span class="preprocessor">    bool isValid() const {return ix&gt;=0;}            \</span>
<a name="l00433"></a>00433 <span class="preprocessor">    bool isValidExtended() const {return ix&gt;=-1;}   \</span>
<a name="l00434"></a>00434 <span class="preprocessor">    void invalidate(){ix=SimTK::InvalidIndex;}      \</span>
<a name="l00435"></a>00435 <span class="preprocessor">    \</span>
<a name="l00436"></a>00436 <span class="preprocessor">    bool operator==(int  i) const {assert(isValidExtended() &amp;&amp; isValidExtended(i)); return ix==i;}    \</span>
<a name="l00437"></a>00437 <span class="preprocessor">    bool operator==(short s) const{assert(isValidExtended() &amp;&amp; isValidExtended(s)); return ix==(int)s;}  \</span>
<a name="l00438"></a>00438 <span class="preprocessor">    bool operator==(long l) const {assert(isValidExtended() &amp;&amp; isValidExtended(l)); return ix==(int)l;}  \</span>
<a name="l00439"></a>00439 <span class="preprocessor">    bool operator==(unsigned int  u)  const {assert(isValidExtended() &amp;&amp; isValid(u)); return ix==(int)u;}   \</span>
<a name="l00440"></a>00440 <span class="preprocessor">    bool operator==(unsigned short us)const {assert(isValidExtended() &amp;&amp; isValid(us)); return ix==(int)us;} \</span>
<a name="l00441"></a>00441 <span class="preprocessor">    bool operator==(unsigned long ul) const {assert(isValidExtended() &amp;&amp; isValid(ul)); return ix==(int)ul;} \</span>
<a name="l00442"></a>00442 <span class="preprocessor">    bool operator!=(int  i)           const {return !operator==(i);}    \</span>
<a name="l00443"></a>00443 <span class="preprocessor">    bool operator!=(short s)          const {return !operator==(s);}    \</span>
<a name="l00444"></a>00444 <span class="preprocessor">    bool operator!=(long l)           const {return !operator==(l);}    \</span>
<a name="l00445"></a>00445 <span class="preprocessor">    bool operator!=(unsigned int  u)  const {return !operator==(u);}    \</span>
<a name="l00446"></a>00446 <span class="preprocessor">    bool operator!=(unsigned long ul) const {return !operator==(ul);}   \</span>
<a name="l00447"></a>00447 <span class="preprocessor">    \</span>
<a name="l00448"></a>00448 <span class="preprocessor">    bool operator&lt; (int  i) const {assert(isValidExtended() &amp;&amp; isValidExtended(i)); return ix&lt;i;}        \</span>
<a name="l00449"></a>00449 <span class="preprocessor">    bool operator&lt; (short s) const{assert(isValidExtended() &amp;&amp; isValidExtended(s)); return ix&lt;(int)s;}   \</span>
<a name="l00450"></a>00450 <span class="preprocessor">    bool operator&lt; (long l) const {assert(isValidExtended() &amp;&amp; isValidExtended(l)); return ix&lt;(int)l;}   \</span>
<a name="l00451"></a>00451 <span class="preprocessor">    bool operator&lt; (unsigned int  u)  const {assert(isValidExtended() &amp;&amp; isValid(u));  return ix&lt;(int)u;}    \</span>
<a name="l00452"></a>00452 <span class="preprocessor">    bool operator&lt; (unsigned short us)const {assert(isValidExtended() &amp;&amp; isValid(us)); return ix&lt;(int)us;}   \</span>
<a name="l00453"></a>00453 <span class="preprocessor">    bool operator&lt; (unsigned long ul) const {assert(isValidExtended() &amp;&amp; isValid(ul)); return ix&lt;(int)ul;}   \</span>
<a name="l00454"></a>00454 <span class="preprocessor">    bool operator&gt;=(int  i)           const {return !operator&lt;(i);}    \</span>
<a name="l00455"></a>00455 <span class="preprocessor">    bool operator&gt;=(short s)          const {return !operator&lt;(s);}    \</span>
<a name="l00456"></a>00456 <span class="preprocessor">    bool operator&gt;=(long l)           const {return !operator&lt;(l);}    \</span>
<a name="l00457"></a>00457 <span class="preprocessor">    bool operator&gt;=(unsigned int  u)  const {return !operator&lt;(u);}    \</span>
<a name="l00458"></a>00458 <span class="preprocessor">    bool operator&gt;=(unsigned short us)const {return !operator&lt;(us);}   \</span>
<a name="l00459"></a>00459 <span class="preprocessor">    bool operator&gt;=(unsigned long ul) const {return !operator&lt;(ul);}   \</span>
<a name="l00460"></a>00460 <span class="preprocessor">    \</span>
<a name="l00461"></a>00461 <span class="preprocessor">    bool operator&gt; (int  i) const {assert(isValidExtended() &amp;&amp; isValidExtended(i)); return ix&gt;i;}        \</span>
<a name="l00462"></a>00462 <span class="preprocessor">    bool operator&gt; (short s) const{assert(isValidExtended() &amp;&amp; isValidExtended(s)); return ix&gt;(int)s;}   \</span>
<a name="l00463"></a>00463 <span class="preprocessor">    bool operator&gt; (long l) const {assert(isValidExtended() &amp;&amp; isValidExtended(l)); return ix&gt;(int)l;}   \</span>
<a name="l00464"></a>00464 <span class="preprocessor">    bool operator&gt; (unsigned int  u)  const {assert(isValidExtended() &amp;&amp; isValid(u));  return ix&gt;(int)u;}    \</span>
<a name="l00465"></a>00465 <span class="preprocessor">    bool operator&gt; (unsigned short us)const {assert(isValidExtended() &amp;&amp; isValid(us)); return ix&gt;(int)us;}   \</span>
<a name="l00466"></a>00466 <span class="preprocessor">    bool operator&gt; (unsigned long ul) const {assert(isValidExtended() &amp;&amp; isValid(ul)); return ix&gt;(int)ul;}   \</span>
<a name="l00467"></a>00467 <span class="preprocessor">    bool operator&lt;=(int  i)           const {return !operator&gt;(i);}    \</span>
<a name="l00468"></a>00468 <span class="preprocessor">    bool operator&lt;=(short s)          const {return !operator&gt;(s);}    \</span>
<a name="l00469"></a>00469 <span class="preprocessor">    bool operator&lt;=(long l)           const {return !operator&gt;(l);}    \</span>
<a name="l00470"></a>00470 <span class="preprocessor">    bool operator&lt;=(unsigned int  u)  const {return !operator&gt;(u);}    \</span>
<a name="l00471"></a>00471 <span class="preprocessor">    bool operator&lt;=(unsigned short us)const {return !operator&gt;(us);}   \</span>
<a name="l00472"></a>00472 <span class="preprocessor">    bool operator&lt;=(unsigned long ul) const {return !operator&gt;(ul);}   \</span>
<a name="l00473"></a>00473 <span class="preprocessor">    \</span>
<a name="l00474"></a>00474 <span class="preprocessor">    const NAME&amp; operator++() {assert(isValid()); ++ix; return *this;}       </span><span class="comment">/*prefix */</span>   \
<a name="l00475"></a>00475     NAME operator++(int)     {assert(isValid()); ++ix; return NAME(ix-1);}  <span class="comment">/*postfix*/</span>   \
<a name="l00476"></a>00476     const NAME&amp; operator--() {assert(isValid()); --ix; return *this;}       <span class="comment">/*prefix */</span>   \
<a name="l00477"></a>00477     NAME operator--(int)     {assert(isValid()); --ix; return NAME(ix+1);}  <span class="comment">/*postfix*/</span>   \
<a name="l00478"></a>00478     NAME next() const {assert(isValid()); return NAME(ix+1);}                             \
<a name="l00479"></a>00479     NAME prev() const {assert(isValid()); return NAME(ix-1);} <span class="comment">/*might return -1*/</span>         \
<a name="l00480"></a>00480     \
<a name="l00481"></a>00481     NAME&amp; operator+=(int i)  {assert(isValid() &amp;&amp; isValidExtended(ix+i)); ix+=i; return *this;}     \
<a name="l00482"></a>00482     NAME&amp; operator-=(int i)  {assert(isValid() &amp;&amp; isValidExtended(ix-i)); ix-=i; return *this;}     \
<a name="l00483"></a>00483     NAME&amp; operator+=(short s){assert(isValid() &amp;&amp; SimTK::canStoreInInt(s) &amp;&amp; isValidExtended(ix+(int)s)); ix+=(int)s; return *this;}     \
<a name="l00484"></a>00484     NAME&amp; operator-=(short s){assert(isValid() &amp;&amp; SimTK::canStoreInInt(s) &amp;&amp; isValidExtended(ix-(int)s)); ix-=(int)s; return *this;}     \
<a name="l00485"></a>00485     NAME&amp; operator+=(long l) {assert(isValid() &amp;&amp; SimTK::canStoreInInt(l) &amp;&amp; isValidExtended(ix+(int)l)); ix+=(int)l; return *this;}     \
<a name="l00486"></a>00486     NAME&amp; operator-=(long l) {assert(isValid() &amp;&amp; SimTK::canStoreInInt(l) &amp;&amp; isValidExtended(ix-(int)l)); ix-=(int)l; return *this;}     \
<a name="l00487"></a>00487     NAME&amp; operator+=(unsigned int  u)  {assert(isValid()&amp;&amp; SimTK::canStoreInInt(u)  &amp;&amp; isValid(ix+(int)u));  ix+=(int)u;  return *this;}  \
<a name="l00488"></a>00488     NAME&amp; operator-=(unsigned int  u)  {assert(isValid()&amp;&amp; SimTK::canStoreInInt(u)  &amp;&amp; isValidExtended(ix-(int)u));  ix-=(int)u;  return *this;}  \
<a name="l00489"></a>00489     NAME&amp; operator+=(unsigned short us){assert(isValid()&amp;&amp; SimTK::canStoreInInt(us) &amp;&amp; isValid(ix+(int)us)); ix+=(int)us; return *this;}  \
<a name="l00490"></a>00490     NAME&amp; operator-=(unsigned short us){assert(isValid()&amp;&amp; SimTK::canStoreInInt(us) &amp;&amp; isValidExtended(ix-(int)us)); ix-=(int)us; return *this;}  \
<a name="l00491"></a>00491     NAME&amp; operator+=(unsigned long ul) {assert(isValid()&amp;&amp; SimTK::canStoreInInt(ul) &amp;&amp; isValid(ix+(int)ul)); ix+=(int)ul; return *this;}  \
<a name="l00492"></a>00492     NAME&amp; operator-=(unsigned long ul) {assert(isValid()&amp;&amp; SimTK::canStoreInInt(ul) &amp;&amp; isValidExtended(ix-(int)ul)); ix-=(int)ul; return *this;}  \
<a name="l00493"></a>00493     \
<a name="l00494"></a>00494     static const NAME&amp; Invalid() {static const NAME invalid; return invalid;}       \
<a name="l00495"></a>00495     static bool isValid(int  i) {return i&gt;=0;}                                      \
<a name="l00496"></a>00496     static bool isValid(short s){return s&gt;=0;}                                      \
<a name="l00497"></a>00497     static bool isValid(long l) {return SimTK::canStoreInNonnegativeInt(l);}        \
<a name="l00498"></a>00498     static bool isValid(unsigned int  u)  {return SimTK::canStoreInInt(u);}         \
<a name="l00499"></a>00499     static bool isValid(unsigned short)   {return true;}                            \
<a name="l00500"></a>00500     static bool isValid(unsigned long ul) {return SimTK::canStoreInInt(ul);}        \
<a name="l00501"></a>00501     static bool isValidExtended(int  i) {return i&gt;=-1;}                             \
<a name="l00502"></a>00502     static bool isValidExtended(short s){return s&gt;=-1;}                             \
<a name="l00503"></a>00503     static bool isValidExtended(long l) {return SimTK::canStoreInInt(l) &amp;&amp; l&gt;=-1;}  \
<a name="l00504"></a>00504     <span class="comment">/* IndexTraits for use in Array_&lt;T,X&gt; with this as X; same as int */</span>            \
<a name="l00505"></a>00505     typedef int size_type;                                                  \
<a name="l00506"></a>00506     typedef int difference_type;                                            \
<a name="l00507"></a>00507     static size_type max_size() {return std::numeric_limits&lt;int&gt;::max();}   \
<a name="l00508"></a>00508 };
<a name="l00509"></a>00509 
<a name="l00516"></a>00516 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00517"></a>00517 <span class="preprocessor"></span><span class="preprocessor">    #define SimTK_DYNAMIC_CAST_DEBUG dynamic_cast   // safe but slow</span>
<a name="l00518"></a>00518 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00519"></a>00519 <span class="preprocessor"></span><span class="preprocessor">    #define SimTK_DYNAMIC_CAST_DEBUG static_cast    // unsafe but fast</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00521"></a>00521 <span class="preprocessor"></span>
<a name="l00525"></a>00525 <span class="preprocessor">#define SimTK_DOWNCAST(Derived,Parent)                          \</span>
<a name="l00526"></a>00526 <span class="preprocessor">    static bool isA(const Parent&amp; p)                            \</span>
<a name="l00527"></a>00527 <span class="preprocessor">        { return dynamic_cast&lt;const Derived*&gt;(&amp;p) != 0; }       \</span>
<a name="l00528"></a>00528 <span class="preprocessor">    static const Derived&amp; downcast(const Parent&amp; p)             \</span>
<a name="l00529"></a>00529 <span class="preprocessor">        { return SimTK_DYNAMIC_CAST_DEBUG&lt;const Derived&amp;&gt;(p); } \</span>
<a name="l00530"></a>00530 <span class="preprocessor">    static Derived&amp; updDowncast(Parent&amp; p)                      \</span>
<a name="l00531"></a>00531 <span class="preprocessor">        { return SimTK_DYNAMIC_CAST_DEBUG&lt;Derived&amp;&gt;(p); }       \</span>
<a name="l00532"></a>00532 <span class="preprocessor">    static Derived&amp; downcast(Parent&amp; p)                         \</span>
<a name="l00533"></a>00533 <span class="preprocessor">        { return SimTK_DYNAMIC_CAST_DEBUG&lt;Derived&amp;&gt;(p); }</span>
<a name="l00534"></a>00534 <span class="preprocessor"></span>
<a name="l00537"></a>00537 <span class="preprocessor">#define SimTK_DOWNCAST2(Derived,Helper,Parent)                          \</span>
<a name="l00538"></a>00538 <span class="preprocessor">    static bool isA(const Parent&amp; p)                                    \</span>
<a name="l00539"></a>00539 <span class="preprocessor">        { return Helper::isA(p); }                                      \</span>
<a name="l00540"></a>00540 <span class="preprocessor">    static const Derived&amp; downcast(const Parent&amp; p)                     \</span>
<a name="l00541"></a>00541 <span class="preprocessor">        { return static_cast&lt;const Derived&amp;&gt;(Helper::downcast(p)); }    \</span>
<a name="l00542"></a>00542 <span class="preprocessor">    static Derived&amp; updDowncast(Parent&amp; p)                              \</span>
<a name="l00543"></a>00543 <span class="preprocessor">        { return static_cast&lt;Derived&amp;&gt;(Helper::downcast(p)); }          \</span>
<a name="l00544"></a>00544 <span class="preprocessor">    static Derived&amp; downcast(Parent&amp; p)                                 \</span>
<a name="l00545"></a>00545 <span class="preprocessor">        { return static_cast&lt;Derived&amp;&gt;(Helper::downcast(p)); }</span>
<a name="l00546"></a>00546 <span class="preprocessor"></span>
<a name="l00547"></a>00547 
<a name="l00551"></a>00551 <span class="preprocessor">#define SimTK_PIMPL_DOWNCAST(Derived, Parent)           \</span>
<a name="l00552"></a>00552 <span class="preprocessor">    static bool           isInstanceOf(const Parent&amp;);  \</span>
<a name="l00553"></a>00553 <span class="preprocessor">    static const Derived&amp; downcast(const Parent&amp;);      \</span>
<a name="l00554"></a>00554 <span class="preprocessor">    static Derived&amp;       updDowncast(Parent&amp;)</span>
<a name="l00555"></a>00555 <span class="preprocessor"></span>
<a name="l00556"></a>00556 <span class="keyword">namespace </span>SimTK {
<a name="l00557"></a>00557 
<a name="l00560"></a>00560 <span class="keyword">namespace </span>Exception { }
<a name="l00561"></a>00561 
<a name="l00564"></a>00564 <span class="keyword">typedef</span> <a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html#a609c1052c1f2ca0d1289affa6d54af4d" title="This type is for use in C; in C++ use SimTK::Real instead.">SimTK_Real</a>              Real;
<a name="l00567"></a>00567 <span class="keyword">typedef</span> std::complex&lt;Real&gt;      Complex;
<a name="l00569"></a>00569 <span class="keyword">typedef</span> std::complex&lt;float&gt;     fComplex;
<a name="l00571"></a>00571 <span class="keyword">typedef</span> std::complex&lt;float&gt;     dComplex;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 <span class="comment">// Forward declaration giving template defaults must come before any</span>
<a name="l00575"></a>00575 <span class="comment">// other declarations.</span>
<a name="l00576"></a>00576 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> M, <span class="keyword">class</span> E=Real, <span class="keywordtype">int</span> STRIDE=1&gt;              <span class="keyword">class </span>Vec;
<a name="l00577"></a>00577 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N, <span class="keyword">class</span> E=Real, <span class="keywordtype">int</span> STRIDE=1&gt;              <span class="keyword">class </span>Row; 
<a name="l00578"></a>00578 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> M, <span class="keywordtype">int</span> N, <span class="keyword">class</span> E=Real, <span class="keywordtype">int</span> CS=M, <span class="keywordtype">int</span> RS=1&gt; <span class="keyword">class </span>Mat; <span class="comment">// col &amp; row spacing</span>
<a name="l00579"></a>00579 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> M, <span class="keyword">class</span> E=Real, <span class="keywordtype">int</span> RS=1&gt;                  <span class="keyword">class </span>SymMat;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 
<a name="l00584"></a>00584 <span class="keyword">struct </span>Segment {
<a name="l00585"></a>00585     Segment() : length(0), offset(0) { }
<a name="l00586"></a>00586     <span class="keyword">explicit</span> Segment(<span class="keywordtype">int</span> l, <span class="keywordtype">int</span> ofs=0) : length(l), offset(ofs) { 
<a name="l00587"></a>00587         assert(l&gt;=0 &amp;&amp; ofs&gt;=0);
<a name="l00588"></a>00588     }
<a name="l00589"></a>00589     <span class="comment">// default copy, assignment, destructor</span>
<a name="l00590"></a>00590     <span class="keywordtype">int</span> length;
<a name="l00591"></a>00591     <span class="keywordtype">int</span> offset;
<a name="l00592"></a>00592 };  
<a name="l00593"></a>00593 
<a name="l00594"></a>00594 
<a name="l00600"></a>00600 <span class="keyword">struct </span>DontCopy {};
<a name="l00604"></a>00604 <span class="keyword">struct </span>TrustMe {};
<a name="l00605"></a>00605 
<a name="l00608"></a>00608 <span class="keyword">struct </span>FalseType {};
<a name="l00611"></a>00611 <span class="keyword">struct </span>TrueType {};
<a name="l00612"></a>00612 
<a name="l00614"></a>00614 <span class="keyword">template</span> &lt;<span class="keyword">class</span> L, <span class="keyword">class</span> R&gt; <span class="keyword">struct </span>AndOpType {};
<a name="l00615"></a>00615 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>AndOpType&lt;FalseType,FalseType&gt; {<span class="keyword">typedef</span> FalseType Result;};
<a name="l00616"></a>00616 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>AndOpType&lt;FalseType,TrueType&gt;  {<span class="keyword">typedef</span> FalseType Result;};
<a name="l00617"></a>00617 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>AndOpType&lt;TrueType, FalseType&gt; {<span class="keyword">typedef</span> FalseType Result;};
<a name="l00618"></a>00618 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>AndOpType&lt;TrueType, TrueType&gt;  {<span class="keyword">typedef</span> TrueType  Result;};
<a name="l00619"></a>00619 
<a name="l00621"></a>00621 <span class="keyword">template</span> &lt;<span class="keyword">class</span> L, <span class="keyword">class</span> R&gt; <span class="keyword">struct </span>OrOpType {};
<a name="l00622"></a>00622 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>OrOpType&lt;FalseType,FalseType&gt; {<span class="keyword">typedef</span> FalseType Result;};
<a name="l00623"></a>00623 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>OrOpType&lt;FalseType,TrueType&gt;  {<span class="keyword">typedef</span> TrueType  Result;};
<a name="l00624"></a>00624 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>OrOpType&lt;TrueType, FalseType&gt; {<span class="keyword">typedef</span> TrueType  Result;};
<a name="l00625"></a>00625 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>OrOpType&lt;TrueType, TrueType&gt;  {<span class="keyword">typedef</span> TrueType  Result;};
<a name="l00626"></a>00626 
<a name="l00628"></a>00628 <span class="keyword">template</span> &lt;<span class="keyword">class</span> L, <span class="keyword">class</span> R&gt; <span class="keyword">struct </span>XorOpType {};
<a name="l00629"></a>00629 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>XorOpType&lt;FalseType,FalseType&gt; {<span class="keyword">typedef</span> FalseType Result;};
<a name="l00630"></a>00630 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>XorOpType&lt;FalseType,TrueType&gt;  {<span class="keyword">typedef</span> TrueType  Result;};
<a name="l00631"></a>00631 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>XorOpType&lt;TrueType, FalseType&gt; {<span class="keyword">typedef</span> TrueType  Result;};
<a name="l00632"></a>00632 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>XorOpType&lt;TrueType, TrueType&gt;  {<span class="keyword">typedef</span> FalseType Result;};
<a name="l00633"></a>00633 
<a name="l00635"></a>00635 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>IsIntegralType {
<a name="l00638"></a>00638     <span class="keyword">typedef</span> FalseType Result;
<a name="l00641"></a>00641     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
<a name="l00642"></a>00642 };
<a name="l00645"></a>00645 <span class="preprocessor">#define SimTK_SPECIALIZE_INTEGRAL_TYPE(T)       \</span>
<a name="l00646"></a>00646 <span class="preprocessor">    template&lt;&gt; struct IsIntegralType&lt;T&gt;         \</span>
<a name="l00647"></a>00647 <span class="preprocessor">    {typedef TrueType Result; static const bool result = true;}</span>
<a name="l00648"></a>00648 <span class="preprocessor"></span>
<a name="l00649"></a>00649 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">bool</span>); 
<a name="l00650"></a>00650 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">char</span>);
<a name="l00651"></a>00651 <span class="comment">// This causes problems when used with Qt which for some crazy</span>
<a name="l00652"></a>00652 <span class="comment">// reason likes to make its own wchar_t rather than using the built in.</span>
<a name="l00653"></a>00653 <span class="comment">// SimTK_SPECIALIZE_INTEGRAL_TYPE(wchar_t);</span>
<a name="l00654"></a>00654 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>);
<a name="l00655"></a>00655 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>);
<a name="l00656"></a>00656 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">short</span>);
<a name="l00657"></a>00657 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>);
<a name="l00658"></a>00658 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">int</span>);
<a name="l00659"></a>00659 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>); <span class="comment">// a.k.a. &quot;unsigned&quot;</span>
<a name="l00660"></a>00660 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">long</span>);
<a name="l00661"></a>00661 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);
<a name="l00662"></a>00662 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">long</span> <span class="keywordtype">long</span>);
<a name="l00663"></a>00663 SimTK_SPECIALIZE_INTEGRAL_TYPE(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>);
<a name="l00664"></a>00664 
<a name="l00666"></a>00666 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>IsFloatingType {
<a name="l00669"></a>00669     <span class="keyword">typedef</span> FalseType Result;
<a name="l00672"></a>00672     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
<a name="l00673"></a>00673 };
<a name="l00676"></a>00676 <span class="preprocessor">#define SimTK_SPECIALIZE_FLOATING_TYPE(T)       \</span>
<a name="l00677"></a>00677 <span class="preprocessor">    template&lt;&gt; struct IsFloatingType&lt;T&gt;         \</span>
<a name="l00678"></a>00678 <span class="preprocessor">    {typedef TrueType Result; static const bool result = true;}</span>
<a name="l00679"></a>00679 <span class="preprocessor"></span>
<a name="l00680"></a>00680 SimTK_SPECIALIZE_FLOATING_TYPE(<span class="keywordtype">float</span>); 
<a name="l00681"></a>00681 SimTK_SPECIALIZE_FLOATING_TYPE(<span class="keywordtype">double</span>); 
<a name="l00682"></a>00682 SimTK_SPECIALIZE_FLOATING_TYPE(<span class="keywordtype">long</span> <span class="keywordtype">double</span>); 
<a name="l00683"></a>00683 
<a name="l00685"></a>00685 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>IsVoidType {
<a name="l00688"></a>00688     <span class="keyword">typedef</span> FalseType Result;
<a name="l00691"></a>00691     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
<a name="l00692"></a>00692 };
<a name="l00693"></a>00693 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>IsVoidType&lt;void&gt; 
<a name="l00694"></a>00694 {<span class="keyword">typedef</span> TrueType Result; <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;};
<a name="l00695"></a>00695 
<a name="l00698"></a>00698 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>IsArithmeticType {
<a name="l00701"></a>00701     <span class="keyword">typedef</span> OrOpType&lt;typename IsIntegralType&lt;T&gt;::Result,
<a name="l00702"></a>00702                      <span class="keyword">typename</span> IsFloatingType&lt;T&gt;::Result&gt;    Result;
<a name="l00705"></a>00705     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = IsIntegralType&lt;T&gt;::result 
<a name="l00706"></a>00706                             || IsFloatingType&lt;T&gt;::result;
<a name="l00707"></a>00707 };
<a name="l00708"></a>00708 
<a name="l00709"></a>00709 <span class="comment">// This struct&#39;s sole use is to allow us to define the typedef </span>
<a name="l00710"></a>00710 <span class="comment">// Is64BitPlatformType as equivalent to either TrueType or FalseType.</span>
<a name="l00711"></a>00711 <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> is64Bit&gt; <span class="keyword">struct </span>Is64BitHelper {};
<a name="l00712"></a>00712 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Is64BitHelper&lt;true&gt;  
<a name="l00713"></a>00713 {<span class="keyword">typedef</span> TrueType  Result; <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;};
<a name="l00714"></a>00714 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Is64BitHelper&lt;false&gt; 
<a name="l00715"></a>00715 {<span class="keyword">typedef</span> FalseType Result; <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;};
<a name="l00716"></a>00716 
<a name="l00721"></a>00721 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> Is64BitPlatform = <span class="keyword">sizeof</span>(size_t) &gt; <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
<a name="l00722"></a>00722 <span class="keyword">typedef</span> Is64BitHelper&lt;Is64BitPlatform&gt;::Result Is64BitPlatformType;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 
<a name="l00728"></a>00728 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>NiceTypeName {
<a name="l00729"></a>00729     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* name() {<span class="keywordflow">return</span> <span class="keyword">typeid</span>(T).name();}
<a name="l00730"></a>00730 };
<a name="l00731"></a>00731 
<a name="l00735"></a>00735 <span class="preprocessor">#define SimTK_NICETYPENAME_LITERAL(T)           \</span>
<a name="l00736"></a>00736 <span class="preprocessor">template &lt;&gt; struct NiceTypeName&lt; T &gt; {          \</span>
<a name="l00737"></a>00737 <span class="preprocessor">    static const char* name() { return #T; }    \</span>
<a name="l00738"></a>00738 <span class="preprocessor">};</span>
<a name="l00739"></a>00739 <span class="preprocessor"></span>
<a name="l00740"></a>00740 <span class="comment">// Some types for which we&#39;d like to see nice type names.</span>
<a name="l00741"></a>00741 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">bool</span>);            
<a name="l00742"></a>00742 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">char</span>); 
<a name="l00743"></a>00743 <span class="comment">// This causes problems when used with Qt which for some crazy</span>
<a name="l00744"></a>00744 <span class="comment">// reason likes to make its own wchar_t rather than using the built in.</span>
<a name="l00745"></a>00745 <span class="comment">// SimTK_NICETYPENAME_LITERAL(wchar_t);            </span>
<a name="l00746"></a>00746 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>); 
<a name="l00747"></a>00747 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>);
<a name="l00748"></a>00748 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">short</span>);           
<a name="l00749"></a>00749 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>);  
<a name="l00750"></a>00750 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">int</span>); 
<a name="l00751"></a>00751 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">unsigned</span>); <span class="comment">// preferred to &quot;unsigned int&quot;</span>
<a name="l00752"></a>00752 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">long</span>);            
<a name="l00753"></a>00753 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);   
<a name="l00754"></a>00754 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">long</span> <span class="keywordtype">long</span>);
<a name="l00755"></a>00755 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>);
<a name="l00756"></a>00756 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">float</span>);           
<a name="l00757"></a>00757 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">double</span>); 
<a name="l00758"></a>00758 SimTK_NICETYPENAME_LITERAL(<span class="keywordtype">long</span> <span class="keywordtype">double</span>);
<a name="l00759"></a>00759 SimTK_NICETYPENAME_LITERAL(std::string);
<a name="l00760"></a>00760 SimTK_NICETYPENAME_LITERAL(std::complex&lt;float&gt;);
<a name="l00761"></a>00761 SimTK_NICETYPENAME_LITERAL(std::complex&lt;double&gt;); 
<a name="l00762"></a>00762 SimTK_NICETYPENAME_LITERAL(std::complex&lt;long double&gt;); 
<a name="l00763"></a>00763 SimTK_NICETYPENAME_LITERAL(SimTK::FalseType);
<a name="l00764"></a>00764 SimTK_NICETYPENAME_LITERAL(SimTK::TrueType); 
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 } <span class="comment">// namespace SimTK</span>
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 <span class="preprocessor">#endif </span><span class="comment">/* C++ stuff */</span>
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="preprocessor">#endif </span><span class="comment">/* SimTK_SimTKCOMMON_COMMON_H_ */</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html">common.h</a>      </li>

    <li class="footer">Generated on Wed Oct 9 2013 08:38:30 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
