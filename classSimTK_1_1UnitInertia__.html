<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::UnitInertia_&lt; P &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1UnitInertia__.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::UnitInertia_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::UnitInertia_" --><!-- doxytag: inherits="SimTK::Inertia_" -->
<p>A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying it by the actual body mass.  
 <a href="classSimTK_1_1UnitInertia__.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MassProperties_8h_source.html">MassProperties.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::UnitInertia_&lt; P &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1UnitInertia__.png" usemap="#SimTK::UnitInertia_&lt; P &gt;_map" alt=""/>
  <map id="SimTK::UnitInertia_&lt; P &gt;_map" name="SimTK::UnitInertia_&lt; P &gt;_map">
<area href="classSimTK_1_1Inertia__.html" title="The physical meaning of an inertia is the distribution of a rigid body&#39;s mass about a particular poin..." alt="SimTK::Inertia_&lt; P &gt;" shape="rect" coords="0,0,148,24"/>
</map>
 </div></div>

<p><a href="classSimTK_1_1UnitInertia__-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#ae99be8ef0c02a608415ac09cd4c08d9e">UnitInertia_</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default is a NaN-ed out mess to avoid accidents, even in Release mode.  <a href="#ae99be8ef0c02a608415ac09cd4c08d9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a387d94e0b21d63c31abee6e38d13a3c2">UnitInertia_</a> (const RealP &amp;moment)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal unit inertia matrix with identical diagonal elements.  <a href="#a387d94e0b21d63c31abee6e38d13a3c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a428d474987b57e275010e899df64b634">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unit inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals).  <a href="#a428d474987b57e275010e899df64b634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#acece1584634f71dc9d42338275358438">UnitInertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal unit inertia matrix (only non-zero on diagonal).  <a href="#acece1584634f71dc9d42338275358438"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#af3a0c1914d9c3632de7777d1e14ccb24">UnitInertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a general unit inertia matrix.  <a href="#af3a0c1914d9c3632de7777d1e14ccb24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a2e06c431d9332364cbd7a32055a452b4">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia from a symmetric 3x3 matrix.  <a href="#a2e06c431d9332364cbd7a32055a452b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#adbd367dbd9f823d671489dca9d7f8a37">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia from a 3x3 symmetric matrix.  <a href="#adbd367dbd9f823d671489dca9d7f8a37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#ac4d3e0602950a28cd8ec8e5ae6f39036">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;<a class="el" href="group__TypedNumConstants.html#ga89110fa308da931e7b5b69f62b143bd3">I</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia matrix from an Inertia matrix.  <a href="#ac4d3e0602950a28cd8ec8e5ae6f39036"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a965913951efebcc88457a3fb2309e44d">setUnitInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a UnitInertia matrix to have only principal moments (that is, it will be diagonal).  <a href="#a965913951efebcc88457a3fb2309e44d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a941ff2a084bb33e57b81bb78f6792d8b">setUnitInertia</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set principal moments and optionally off-diagonal terms.  <a href="#a941ff2a084bb33e57b81bb78f6792d8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#af519b525445b103c7b97bec214c28788">setUnitInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this UnitInertia to a general matrix.  <a href="#af519b525445b103c7b97bec214c28788"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a9c2535890d3b9e0ca3b8519d252f8cf7">shiftToCentroid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, produce a new unit inertia matrix which is the same as this one except measured about the body's centroid CF.  <a href="#a9c2535890d3b9e0ca3b8519d252f8cf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a86344e7cc8a70d606ba5a8c16511d4ed">shiftToCentroidInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, modify it so that it is instead taken about the body's centroid CF.  <a href="#a86344e7cc8a70d606ba5a8c16511d4ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04">shiftFromCentroid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), create a new object that is the same as this one except shifted to some other point p measured from the centroid.  <a href="#a4f981071de25c9d3f263643b31850a04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8">shiftFromCentroidInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), shift it in place to some other point p measured from the centroid.  <a href="#a9e4d4d72a9d1890c1f6a45067d5c88c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451">reexpress</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged).  <a href="#a82227844aba875e9fa4063bff68a3451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a76f8a4eba1df68a53839ae02025f5507">reexpress</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a76f8a4eba1df68a53839ae02025f5507"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4b820a2338b949af9816a70343940a07">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this unit inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested and get a new one instead.  <a href="#a4b820a2338b949af9816a70343940a07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a9f0b740b16c447193af134d6dcfc8a29">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a9f0b740b16c447193af134d6dcfc8a29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#aaf30c07af59a472f872e6867ef8a14df">operator const SymMat33P &amp;</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const SymMat33.  <a href="#aaf30c07af59a472f872e6867ef8a14df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4ad2f3845459ee8d4a99857160b67238">asUnitInertia</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast this UnitInertia matrix as a unit inertia matrix.  <a href="#a4ad2f3845459ee8d4a99857160b67238"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#adff44afd712eb42eb003df3454dd5fc3">setFromUnitInertia</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;<a class="el" href="group__TypedNumConstants.html#ga89110fa308da931e7b5b69f62b143bd3">I</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set from a unit inertia matrix.  <a href="#adff44afd712eb42eb003df3454dd5fc3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a0747db2089594f1958363401e7a75a3e">isValidUnitInertiaMatrix</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test some conditions that must hold for a valid UnitInertia matrix.  <a href="#a0747db2089594f1958363401e7a75a3e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">UnitInertia matrix factories</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are UnitInertia matrix factories for some common 3D solids.</p>
<p>Each defines its own frame aligned (when possible) with principal moments. Each has unit mass and its center of mass located at the origin (usually). Use this with <a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> to move it somewhere else, and with <a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> to express the UnitInertia matrix in another frame. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a1e27445e87e048350c0733f282a14d4a">pointMassAtOrigin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a point located at the origin -- that is, an all-zero matrix.  <a href="#a1e27445e87e048350c0733f282a14d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#ad12590783e2b1cc3dc3715f6c4c8f3ef">pointMassAt</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a point of unit mass located at a given location measured from origin OF and expressed in F (where F is the implicit frame of this UnitInertia matrix).  <a href="#ad12590783e2b1cc3dc3715f6c4c8f3ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#aea6dff2244b2e884fc5ae7747b4489c2">sphere</a> (const RealP &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin.  <a href="#aea6dff2244b2e884fc5ae7747b4489c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a22aae6b90b2feeb28272a15ac0ee431b">cylinderAlongZ</a> (const RealP &amp;r, const RealP &amp;hz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along z axis; use radius and half-length.  <a href="#a22aae6b90b2feeb28272a15ac0ee431b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a433b955d92ee92f053e4c90301b2537e">cylinderAlongY</a> (const RealP &amp;r, const RealP &amp;hy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along y axis; use radius and half-length.  <a href="#a433b955d92ee92f053e4c90301b2537e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a89f3c0caf76077405e5eca28662214dc">cylinderAlongX</a> (const RealP &amp;r, const RealP &amp;hx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along x axis; use radius and half-length.  <a href="#a89f3c0caf76077405e5eca28662214dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b">brick</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass brick given by half-lengths in each direction.  <a href="#aa765bcf7ca1430d4bb0ee35964b6a87b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a6727b53f8dc2470095ead9162f74df1e">brick</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b" title="Unit-mass brick given by half-lengths in each direction.">brick()</a> that takes a Vec3 for the half lengths.  <a href="#a6727b53f8dc2470095ead9162f74df1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006">ellipsoid</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass ellipsoid given by half-lengths in each direction.  <a href="#afb4918161a3aa2b765b10834420f2006"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a617357823ece8ff6c7f03c6cb34ab31e">ellipsoid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006" title="Unit-mass ellipsoid given by half-lengths in each direction.">ellipsoid()</a> that takes a Vec3 for the half lengths.  <a href="#a617357823ece8ff6c7f03c6cb34ab31e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br/>
class SimTK::UnitInertia_&lt; P &gt;</h3>

<p>A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying it by the actual body mass. </p>
<p>Functionality is limited here to those few operations which ensure unit mass; most operations on a UnitInertia matrix result in a general Inertia instead. You can use a UnitInertia object wherever an Inertia is expected but not vice versa.</p>
<p>When constructing a UnitInertia matrix, note that we cannot verify that it actually has unit mass because every legal Inertia matrix can be viewed as the UnitInertia matrix for some differently-scaled object.</p>
<p>Unit inertia matrices are sometimes called "gyration" matrices; we will often represent them with the symbol "G" to avoid confusion with general inertia matrices for which the symbol "I" (or sometimes "J") is used.</p>
<h3>Abbreviations</h3>
<p>Typedefs exist for the most common invocations of <a class="el" href="classSimTK_1_1UnitInertia__.html" title="A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying i...">UnitInertia_</a>&lt;P&gt;:</p>
<ul>
<li><a class="el" href="namespaceSimTK.html#af4586b331c8fbbb1f3c18d2a1a03ce92">UnitInertia</a> for default Real precision (this is almost always used)</li>
<li><a class="el" href="namespaceSimTK.html#a477722ebc554f08856ea0f612b27b8c3">fUnitInertia</a> for single (float) precision</li>
<li><a class="el" href="namespaceSimTK.html#adcce13c4ad58d5aee947072ef9cd3586">dUnitInertia</a> for double precision </li>
</ul>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae99be8ef0c02a608415ac09cd4c08d9e"></a><!-- doxytag: member="SimTK::UnitInertia_::UnitInertia_" ref="ae99be8ef0c02a608415ac09cd4c08d9e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default is a NaN-ed out mess to avoid accidents, even in Release mode. </p>
<p>Other than this value, a <a class="el" href="classSimTK_1_1UnitInertia__.html" title="A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying i...">UnitInertia_</a> should always be valid. </p>

</div>
</div>
<a class="anchor" id="a387d94e0b21d63c31abee6e38d13a3c2"></a><!-- doxytag: member="SimTK::UnitInertia_::UnitInertia_" ref="a387d94e0b21d63c31abee6e38d13a3c2" args="(const RealP &amp;moment)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>moment</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a principal unit inertia matrix with identical diagonal elements. </p>
<p>This is the unit inertia matrix of a unit mass sphere of radius r = sqrt(5/2 * moment) centered on the origin. </p>

</div>
</div>
<a class="anchor" id="a428d474987b57e275010e899df64b634"></a><!-- doxytag: member="SimTK::UnitInertia_::UnitInertia_" ref="a428d474987b57e275010e899df64b634" args="(const Vec3P &amp;moments, const Vec3P &amp;products=Vec3P(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em> = <code><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a unit inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals). </p>
<p>Moments are in the order xx,yy,zz; products are xy,xz,yz. </p>

</div>
</div>
<a class="anchor" id="acece1584634f71dc9d42338275358438"></a><!-- doxytag: member="SimTK::UnitInertia_::UnitInertia_" ref="acece1584634f71dc9d42338275358438" args="(const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a principal unit inertia matrix (only non-zero on diagonal). </p>

</div>
</div>
<a class="anchor" id="af3a0c1914d9c3632de7777d1e14ccb24"></a><!-- doxytag: member="SimTK::UnitInertia_::UnitInertia_" ref="af3a0c1914d9c3632de7777d1e14ccb24" args="(const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a general unit inertia matrix. </p>
<p>Note the order of these arguments: moments of inertia first, then products of inertia. </p>

</div>
</div>
<a class="anchor" id="a2e06c431d9332364cbd7a32055a452b4"></a><!-- doxytag: member="SimTK::UnitInertia_::UnitInertia_" ref="a2e06c431d9332364cbd7a32055a452b4" args="(const SymMat33P &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a UnitInertia from a symmetric 3x3 matrix. </p>
<p>The diagonals must be nonnegative and satisfy the triangle inequality. </p>

</div>
</div>
<a class="anchor" id="adbd367dbd9f823d671489dca9d7f8a37"></a><!-- doxytag: member="SimTK::UnitInertia_::UnitInertia_" ref="adbd367dbd9f823d671489dca9d7f8a37" args="(const Mat33P &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a UnitInertia from a 3x3 symmetric matrix. </p>
<p>In Debug mode we'll test that the supplied matrix is numerically close to symmetric, and that it satisfies other requirements of an inertia matrix. </p>

</div>
</div>
<a class="anchor" id="ac4d3e0602950a28cd8ec8e5ae6f39036"></a><!-- doxytag: member="SimTK::UnitInertia_::UnitInertia_" ref="ac4d3e0602950a28cd8ec8e5ae6f39036" args="(const Inertia_&lt; P &gt; &amp;I)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a UnitInertia matrix from an Inertia matrix. </p>
<p>Note that there is no way to check whether this is really a unit inertia -- <em>any</em> inertia matrix may be interpreted as a unit inertia for some shape. So be sure you know what you're doing before you use this constructor! </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a965913951efebcc88457a3fb2309e44d"></a><!-- doxytag: member="SimTK::UnitInertia_::setUnitInertia" ref="a965913951efebcc88457a3fb2309e44d" args="(const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a965913951efebcc88457a3fb2309e44d">setUnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a UnitInertia matrix to have only principal moments (that is, it will be diagonal). </p>
<p>Returns a reference to "this" like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="a941ff2a084bb33e57b81bb78f6792d8b"></a><!-- doxytag: member="SimTK::UnitInertia_::setUnitInertia" ref="a941ff2a084bb33e57b81bb78f6792d8b" args="(const Vec3P &amp;moments, const Vec3P &amp;products=Vec3P(0))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a965913951efebcc88457a3fb2309e44d">setUnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em> = <code><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set principal moments and optionally off-diagonal terms. </p>
<p>Returns a reference to "this" like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="af519b525445b103c7b97bec214c28788"></a><!-- doxytag: member="SimTK::UnitInertia_::setUnitInertia" ref="af519b525445b103c7b97bec214c28788" args="(const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a965913951efebcc88457a3fb2309e44d">setUnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this UnitInertia to a general matrix. </p>
<p>Note the order of these arguments: moments of inertia first, then products of inertia. Behaves like an assignment statement. Will throw an error message in Debug mode if the supplied elements do not constitute a valid inertia matrix. </p>

</div>
</div>
<a class="anchor" id="a9c2535890d3b9e0ca3b8519d252f8cf7"></a><!-- doxytag: member="SimTK::UnitInertia_::shiftToCentroid" ref="a9c2535890d3b9e0ca3b8519d252f8cf7" args="(const Vec3P &amp;CF) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a9c2535890d3b9e0ca3b8519d252f8cf7">shiftToCentroid</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>CF</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, produce a new unit inertia matrix which is the same as this one except measured about the body's centroid CF. </p>
<p>We are given the vector from OF to the centroid CF, expressed in F. This produces a new UnitInertia matrix G' whose (implicit) frame F' is aligned with F but has origin CF (an inertia matrix like that is called "central" or "centroidal"). From the parallel axis theorem for inertias, G' = G - Gcom where Gcom is the inertia matrix of a fictitious, unit-mass point located at CF (measured in F) taken about OF. (17 flops) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a86344e7cc8a70d606ba5a8c16511d4ed" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroidInPlace()</a>, <a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a86344e7cc8a70d606ba5a8c16511d4ed"></a><!-- doxytag: member="SimTK::UnitInertia_::shiftToCentroidInPlace" ref="a86344e7cc8a70d606ba5a8c16511d4ed" args="(const Vec3P &amp;CF)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a86344e7cc8a70d606ba5a8c16511d4ed">shiftToCentroidInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>CF</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, modify it so that it is instead taken about the body's centroid CF. </p>
<p>We are given the vector from OF to the centroid CF, expressed in F. This produces a new UnitInertia G' whose (implicit) frame F' is aligned with F but has origin CF (an inertia matrix like that is called "central" or "centroidal"). From the parallel axis theorem for inertias, G' = G - Gcom where Gcom is the inertia matrix of a fictitious, unit-mass point located at CF (measured in F) taken about OF. A reference to the modified object is returned so that you can chain this method in the manner of assignment operators. Cost is 17 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a9c2535890d3b9e0ca3b8519d252f8cf7" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroid()</a> if you want to leave this object unmolested. </dd>
<dd>
<a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroidInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f981071de25c9d3f263643b31850a04"></a><!-- doxytag: member="SimTK::UnitInertia_::shiftFromCentroid" ref="a4f981071de25c9d3f263643b31850a04" args="(const Vec3P &amp;p) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04">shiftFromCentroid</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), create a new object that is the same as this one except shifted to some other point p measured from the centroid. </p>
<p>This produces a new inertia G' about the point p given by G' = G + Gp where Gp is the inertia of a fictitious point located at p, taken about CF. Cost is 17 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroidInPlace()</a>, <a class="el" href="classSimTK_1_1UnitInertia__.html#a9c2535890d3b9e0ca3b8519d252f8cf7" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroid()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e4d4d72a9d1890c1f6a45067d5c88c8"></a><!-- doxytag: member="SimTK::UnitInertia_::shiftFromCentroidInPlace" ref="a9e4d4d72a9d1890c1f6a45067d5c88c8" args="(const Vec3P &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8">shiftFromCentroidInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), shift it in place to some other point p measured from the centroid. </p>
<p>This changes G to a modified inertia G' taken about the point p, with the parallel axis theorem for inertia giving G' = G + Gp where Gp is the inertia of a fictitious, unit-mass point located at p, taken about CF. Cost is 17 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> if you want to leave this object unmolested. </dd>
<dd>
shitToCentroidInPlace() </dd></dl>

</div>
</div>
<a class="anchor" id="a82227844aba875e9fa4063bff68a3451"></a><!-- doxytag: member="SimTK::UnitInertia_::reexpress" ref="a82227844aba875e9fa4063bff68a3451" args="(const Rotation_&lt; P &gt; &amp;R_FB) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451">reexpress</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged). </p>
<p>Call this inertia matrix G_OF_F, that is, it is taken about the origin of some frame F, and expressed in F. We want to return G_OF_B, the same unit inertia matrix, still taken about the origin of F, but expressed in the B frame, given by G_OF_B=R_BF*G_OF_F*R_FB where R_FB is the rotation matrix giving the orientation of frame B in F. This is handled here by a special method of the Rotation class which rotates a symmetric tensor at a cost of 57 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a4b820a2338b949af9816a70343940a07" title="Re-express this unit inertia matrix in another frame, changing the object in place; see reexpress() i...">reexpressInPlace()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#a8ded5c13f1f5cee2aec5319953eb401c">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a76f8a4eba1df68a53839ae02025f5507"></a><!-- doxytag: member="SimTK::UnitInertia_::reexpress" ref="a76f8a4eba1df68a53839ae02025f5507" args="(const InverseRotation_&lt; P &gt; &amp;R_FB) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451">reexpress</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>rexpress(Rotation) for information </dd></dl>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#a73c802f5dab0c8aba78da00df82a73f4">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4b820a2338b949af9816a70343940a07"></a><!-- doxytag: member="SimTK::UnitInertia_::reexpressInPlace" ref="a4b820a2338b949af9816a70343940a07" args="(const Rotation_&lt; P &gt; &amp;R_FB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a4b820a2338b949af9816a70343940a07">reexpressInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-express this unit inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested and get a new one instead. </p>
<p>Cost is 57 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested. </dd></dl>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#a4c4a49f053e7c11240ad4e802786f254">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9f0b740b16c447193af134d6dcfc8a29"></a><!-- doxytag: member="SimTK::UnitInertia_::reexpressInPlace" ref="a9f0b740b16c447193af134d6dcfc8a29" args="(const InverseRotation_&lt; P &gt; &amp;R_FB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a4b820a2338b949af9816a70343940a07">reexpressInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>rexpressInPlace(Rotation) for information </dd></dl>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#a4021fe4887710d1285fc6d1c5bd728aa">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aaf30c07af59a472f872e6867ef8a14df"></a><!-- doxytag: member="SimTK::UnitInertia_::operator const SymMat33P &amp;" ref="aaf30c07af59a472f872e6867ef8a14df" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::operator const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an implicit conversion to const SymMat33. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#ae1c83f66b07a3633caf070d8896e17b7">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4ad2f3845459ee8d4a99857160b67238"></a><!-- doxytag: member="SimTK::UnitInertia_::asUnitInertia" ref="a4ad2f3845459ee8d4a99857160b67238" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a4ad2f3845459ee8d4a99857160b67238">asUnitInertia</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recast this UnitInertia matrix as a unit inertia matrix. </p>
<p>This is just for emphasis; a UnitInertia matrix is already a kind of Inertia matrix by inheritance. </p>

</div>
</div>
<a class="anchor" id="adff44afd712eb42eb003df3454dd5fc3"></a><!-- doxytag: member="SimTK::UnitInertia_::setFromUnitInertia" ref="adff44afd712eb42eb003df3454dd5fc3" args="(const Inertia_&lt; P &gt; &amp;I)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#adff44afd712eb42eb003df3454dd5fc3">setFromUnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set from a unit inertia matrix. </p>
<p>Note that we can't check; every Inertia matrix can be interpreted as a unit inertia for some shape. </p>

</div>
</div>
<a class="anchor" id="a0747db2089594f1958363401e7a75a3e"></a><!-- doxytag: member="SimTK::UnitInertia_::isValidUnitInertiaMatrix" ref="a0747db2089594f1958363401e7a75a3e" args="(const SymMat33P &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a0747db2089594f1958363401e7a75a3e">isValidUnitInertiaMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test some conditions that must hold for a valid UnitInertia matrix. </p>
<p>Cost is about 9 flops. TODO: this may not be comprehensive. </p>

</div>
</div>
<a class="anchor" id="a1e27445e87e048350c0733f282a14d4a"></a><!-- doxytag: member="SimTK::UnitInertia_::pointMassAtOrigin" ref="a1e27445e87e048350c0733f282a14d4a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a1e27445e87e048350c0733f282a14d4a">pointMassAtOrigin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a UnitInertia matrix for a point located at the origin -- that is, an all-zero matrix. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#adaf11cafc9975fd5e6072f12548a467f">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad12590783e2b1cc3dc3715f6c4c8f3ef"></a><!-- doxytag: member="SimTK::UnitInertia_::pointMassAt" ref="ad12590783e2b1cc3dc3715f6c4c8f3ef" args="(const Vec3P &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#ad12590783e2b1cc3dc3715f6c4c8f3ef">pointMassAt</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a UnitInertia matrix for a point of unit mass located at a given location measured from origin OF and expressed in F (where F is the implicit frame of this UnitInertia matrix). </p>
<p>Cost is 11 flops. </p>

</div>
</div>
<a class="anchor" id="aea6dff2244b2e884fc5ae7747b4489c2"></a><!-- doxytag: member="SimTK::UnitInertia_::sphere" ref="aea6dff2244b2e884fc5ae7747b4489c2" args="(const RealP &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#aea6dff2244b2e884fc5ae7747b4489c2">sphere</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#a0079ce02a6ce9ddb2c3cdf26f5c88fac">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a22aae6b90b2feeb28272a15ac0ee431b"></a><!-- doxytag: member="SimTK::UnitInertia_::cylinderAlongZ" ref="a22aae6b90b2feeb28272a15ac0ee431b" args="(const RealP &amp;r, const RealP &amp;hz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a22aae6b90b2feeb28272a15ac0ee431b">cylinderAlongZ</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unit-mass cylinder aligned along z axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hz=0 it is a thin disk. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#a731715abc3e23d14716ed8778c3a41db">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a433b955d92ee92f053e4c90301b2537e"></a><!-- doxytag: member="SimTK::UnitInertia_::cylinderAlongY" ref="a433b955d92ee92f053e4c90301b2537e" args="(const RealP &amp;r, const RealP &amp;hy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a433b955d92ee92f053e4c90301b2537e">cylinderAlongY</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unit-mass cylinder aligned along y axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hy=0 it is a thin disk. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#afb7fa18382bb190462ec90cee793c618">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a89f3c0caf76077405e5eca28662214dc"></a><!-- doxytag: member="SimTK::UnitInertia_::cylinderAlongX" ref="a89f3c0caf76077405e5eca28662214dc" args="(const RealP &amp;r, const RealP &amp;hx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#a89f3c0caf76077405e5eca28662214dc">cylinderAlongX</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unit-mass cylinder aligned along x axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hx=0 it is a thin disk. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#ab408d2690f9520647fc41426d2da97a5">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa765bcf7ca1430d4bb0ee35964b6a87b"></a><!-- doxytag: member="SimTK::UnitInertia_::brick" ref="aa765bcf7ca1430d4bb0ee35964b6a87b" args="(const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b">brick</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unit-mass brick given by half-lengths in each direction. </p>
<p>One dimension zero gives inertia of a thin rectangular sheet; two zero gives inertia of a thin rod in the remaining direction. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#afe1dc7f12543454dadb1ea0ab243b2a3">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6727b53f8dc2470095ead9162f74df1e"></a><!-- doxytag: member="SimTK::UnitInertia_::brick" ref="a6727b53f8dc2470095ead9162f74df1e" args="(const Vec3P &amp;halfLengths)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b">brick</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b" title="Unit-mass brick given by half-lengths in each direction.">brick()</a> that takes a Vec3 for the half lengths. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#a6e344c2ae3ff6b5ac4a84f632c4c7f8e">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afb4918161a3aa2b765b10834420f2006"></a><!-- doxytag: member="SimTK::UnitInertia_::ellipsoid" ref="afb4918161a3aa2b765b10834420f2006" args="(const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006">ellipsoid</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unit-mass ellipsoid given by half-lengths in each direction. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#a2ce85ba36aeec4e390d1adb99d34b33d">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a617357823ece8ff6c7f03c6cb34ab31e"></a><!-- doxytag: member="SimTK::UnitInertia_::ellipsoid" ref="a617357823ece8ff6c7f03c6cb34ab31e" args="(const Vec3P &amp;halfLengths)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006">ellipsoid</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006" title="Unit-mass ellipsoid given by half-lengths in each direction.">ellipsoid()</a> that takes a Vec3 for the half lengths. </p>

<p>Reimplemented from <a class="el" href="classSimTK_1_1Inertia__.html#ac4bc60ba4fe2d9bf269bfb9789a3433b">SimTK::Inertia_&lt; P &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MassProperties_8h_source.html">MassProperties.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>      </li>

    <li class="footer">Generated on Mon Jul 14 2014 23:26:08 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
