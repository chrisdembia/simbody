<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::MobilizedBody::Custom::Implementation Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::MobilizedBody::Custom::Implementation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::MobilizedBody::Custom::Implementation" --><!-- doxytag: inherits="PIMPLHandle&lt; Implementation, ImplementationImpl &gt;" -->
<p>This is the implementation class for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html" title="The handle class MobilizedBody::Custom (dataless) and its companion class MobilizedBody::Custom::Impl...">Custom</a> mobilizers.  
 <a href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MobilizedBody__Custom_8h_source.html">MobilizedBody_Custom.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::MobilizedBody::Custom::Implementation:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.png" usemap="#SimTK::MobilizedBody::Custom::Implementation_map" alt=""/>
  <map id="SimTK::MobilizedBody::Custom::Implementation_map" name="SimTK::MobilizedBody::Custom::Implementation_map">
<area href="classSimTK_1_1PIMPLHandle.html" alt="SimTK::PIMPLHandle&lt; Implementation, ImplementationImpl &gt;" shape="rect" coords="0,0,349,24"/>
</map>
 </div></div>

<p><a href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a5ab03db155da9aa8e5f969e6613bf0fd">~Implementation</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor is virtual so derived classes get a chance to clean up if necessary.  <a href="#a5ab03db155da9aa8e5f969e6613bf0fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html">Implementation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3c0f165813eb7491a4aaa17c6cfb9f8">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should produce a deep copy identical to the concrete derived <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html" title="This is the implementation class for Custom mobilizers.">Implementation</a> object underlying this <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html" title="This is the implementation class for Custom mobilizers.">Implementation</a> base class object.  <a href="#ac3c0f165813eb7491a4aaa17c6cfb9f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#afd1c8f179855ba4b5c60b6885d1c9887">Implementation</a> (<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;, int nu, int nq, int nAngles=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html" title="This is the implementation class for Custom mobilizers.">Implementation</a> base class constructor sets the topological defaults for the number of mobilities (generalized speeds) u, the number of generalized coordinates q, and the number of those q's that are angles.  <a href="#afd1c8f179855ba4b5c60b6885d1c9887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2850db71037610153135583ba0f3edf4">getQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Vector containing all the generalized coordinates q currently in use by this mobilizer.  <a href="#a2850db71037610153135583ba0f3edf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac03778d9f963f8b2d9bf889fe15a708d">getU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Vector containing all the generalized speeds u currently in use by this mobilizer.  <a href="#ac03778d9f963f8b2d9bf889fe15a708d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4e13daf1b675ee04cd2339f8ddc959c4">getQDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Vector containing all the generalized coordinate derivatives qdot currently in use by this mobilizer.  <a href="#a4e13daf1b675ee04cd2339f8ddc959c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ae0439ba2dcb4b778ea0f8e4a3d14fad6">getUDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Vector containing all the generalized accelerations udot currently in use by this mobilizer.  <a href="#ae0439ba2dcb4b778ea0f8e4a3d14fad6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a1358ffb48f0443818d30ac78afa63065">getQDotDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Vector containing all the generalized coordinate second derivatives qdotdot currently in use by this mobilizer.  <a href="#a1358ffb48f0443818d30ac78afa63065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a40a0c6b00a67848863503e6504a94043">getMobilizerTransform</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cross-mobilizer transform X_FM, the body's "moving" mobilizer frame M measured and expressed in the parent body's corresponding "fixed" frame F.  <a href="#a40a0c6b00a67848863503e6504a94043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a1b9d92031b918666128e197a0542ead7">getMobilizerVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cross-mobilizer velocity V_FM, the relative velocity of this body's "moving" mobilizer frame M in the parent body's corresponding "fixed" frame F, measured and expressed in F.  <a href="#a1b9d92031b918666128e197a0542ead7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a6999212221257f46895eb7a6d56b29f1">getUseEulerAngles</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether rotations are being represented as quaternions or Euler angles.  <a href="#a6999212221257f46895eb7a6d56b29f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a970f782c765862cba774461b2c7fc9bf">invalidateTopologyCache</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you want to make sure that the next <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0" title="The Matter Subsystem&#39;s realizeTopology() method will call this method along with the built-in Mobiliz...">realizeTopology()</a> call does something.  <a href="#a970f782c765862cba774461b2c7fc9bf"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">MobilizedBody Virtuals</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These must be defined for any <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html" title="The handle class MobilizedBody::Custom (dataless) and its companion class MobilizedBody::Custom::Impl...">Custom</a> <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>.</p>
<p>Note that the numbers nu, nq, and nAngles are passed in to these routines for redundancy -- you should make sure they have the values you are expecting! </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a1443aac6089cc6f2c1e85c8b5aa4f4c2">calcMobilizerTransformFromQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, int nq, const Real *q) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given values for this mobilizer's nq generalized coordinates q, compute X_FM(q), that is, the cross-mobilizer spatial Transform giving the configuration of the "moving" frame M fixed to the outboard (child) body B in the "fixed" frame F attached to the inboard (parent) body P.  <a href="#a1443aac6089cc6f2c1e85c8b5aa4f4c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a3e218c380d12a9f4af73d5072cfc6034">multiplyByHMatrix</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, int nu, const Real *u) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate V_FM(u) = H*u where H=H(q) is the joint transition matrix mapping the mobilities to the relative spatial velocity between the F frame on the parent to the M frame on the child.  <a href="#a3e218c380d12a9f4af73d5072cfc6034"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7d85e17cf561d35aba399e1b3a0c87b5">multiplyByHTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;F, int nu, Real *f) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate f = ~H*F where F is a spatial force (torque+force) and f is its mapping onto the mobilities.  <a href="#a7d85e17cf561d35aba399e1b3a0c87b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a9263c8eed08cf33cd00f31fdb2301146">multiplyByHDotMatrix</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, int nu, const Real *u) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate A0_FM = HDot*u where HDot=HDot(q,u) is the time derivative of H.  <a href="#a9263c8eed08cf33cd00f31fdb2301146"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#af3e9247d1a717df881ed2654300ee9ef">multiplyByHDotTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;F, int nu, Real *f) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate f = ~HDot*F where F is a spatial vector and f is its mapping onto the mobilities.  <a href="#af3e9247d1a717df881ed2654300ee9ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a0038e9bc6b9f7337601ca2e085229549">multiplyByN</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool transposeMatrix, int nIn, const Real *in, int nOut, Real *out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_q = N(q)*in_u (e.g., qdot=N*u) or out_u = ~N*in_q.  <a href="#a0038e9bc6b9f7337601ca2e085229549"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a301c187b22f0366db831e3c4bc8a55d5">multiplyByNInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool transposeMatrix, int nIn, const Real *in, int nOut, Real *out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_u = NInv(q)*in_q (e.g., u=NInv*qdot) or out_q = ~NInv*in_u.  <a href="#a301c187b22f0366db831e3c4bc8a55d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f680117b0024df633655911cda13cb0">multiplyByNDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool transposeMatrix, int nIn, const Real *in, int nOut, Real *out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_q = NDot(q)*in_u or out_u = ~NDot*in_q.  <a href="#a4f680117b0024df633655911cda13cb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a69b034e9b66fe77603a5f514999b3621">setQToFitTransform</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_FM, int nq, Real *q) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a set of q's for this mobilizer that best approximate the supplied Transform which requests a particular relative orientation and translation between the "fixed" and "moving" frames connected by this mobilizer.  <a href="#a69b034e9b66fe77603a5f514999b3621"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4a5622b63a472b2e2ca5275556521962">setUToFitVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FM, int nu, Real *u) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a set of u's (generalized speeds) for this mobilizer that best approximate the supplied spatial velocity <code>V_FM</code> which requests the relative angular and linear velocity between the "fixed" and "moving" frames connected by this mobilizer.  <a href="#a4a5622b63a472b2e2ca5275556521962"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2f2612a5b9f913fcedaff2aa6cc22719">calcDecorativeGeometryAndAppend</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> stage, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &gt; &amp;geom) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this optional method if you would like your <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> to generate any suggestions for geometry that could be used as default visualization as an aid to understanding a system containing this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>.  <a href="#a2f2612a5b9f913fcedaff2aa6cc22719"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Optional realize() Virtual Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Provide implementations of these methods if you want to allocate <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> variables (such as modeling options or parameters) or want to pre-calculate some expensive quantities and store them in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> cache for your future use.</p>
<p>Note that the Position and Velocity realize methods will be called <em>before</em> calling the matrix operator methods for this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. That way if you want to precalculate the H or HDot matrix, for example, you can do so in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3d2d1525a8835dd2650db6a6b7eae1d" title="The Matter Subsystem&#39;s realizePosition() method will call this method along with the built-in Mobiliz...">realizePosition()</a> or <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a075f9a6a6c9d7e9e5e36dcdd7a91077c" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method along with the built-in Mobiliz...">realizeVelocity()</a> and then use it in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a3e218c380d12a9f4af73d5072cfc6034" title="Calculate V_FM(u) = H*u where H=H(q) is the joint transition matrix mapping the mobilities to the rel...">multiplyByHMatrix()</a>, etc. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0">realizeTopology</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0" title="The Matter Subsystem&#39;s realizeTopology() method will call this method along with the built-in Mobiliz...">realizeTopology()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0" title="The Matter Subsystem&#39;s realizeTopology() method will call this method along with the built-in Mobiliz...">realizeTopology()</a> methods.  <a href="#a4f47ca2f3772d58b58816d9ed37cf8f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2114ad8d6a1dc4beb74a5862da38255b">realizeModel</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2114ad8d6a1dc4beb74a5862da38255b" title="The Matter Subsystem&#39;s realizeModel() method will call this method along with the built-in MobilizedB...">realizeModel()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2114ad8d6a1dc4beb74a5862da38255b" title="The Matter Subsystem&#39;s realizeModel() method will call this method along with the built-in MobilizedB...">realizeModel()</a> methods.  <a href="#a2114ad8d6a1dc4beb74a5862da38255b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ad7b28bd19fe6d7836c3d31e8ddcef4e8">realizeInstance</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ad7b28bd19fe6d7836c3d31e8ddcef4e8" title="The Matter Subsystem&#39;s realizeInstance() method will call this method along with the built-in Mobiliz...">realizeInstance()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ad7b28bd19fe6d7836c3d31e8ddcef4e8" title="The Matter Subsystem&#39;s realizeInstance() method will call this method along with the built-in Mobiliz...">realizeInstance()</a> methods.  <a href="#ad7b28bd19fe6d7836c3d31e8ddcef4e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a917bb2733422da09a3208eda81e7ce5f">realizeTime</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a917bb2733422da09a3208eda81e7ce5f" title="The Matter Subsystem&#39;s realizeTime() method will call this method along with the built-in MobilizedBo...">realizeTime()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a917bb2733422da09a3208eda81e7ce5f" title="The Matter Subsystem&#39;s realizeTime() method will call this method along with the built-in MobilizedBo...">realizeTime()</a> methods.  <a href="#a917bb2733422da09a3208eda81e7ce5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3d2d1525a8835dd2650db6a6b7eae1d">realizePosition</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3d2d1525a8835dd2650db6a6b7eae1d" title="The Matter Subsystem&#39;s realizePosition() method will call this method along with the built-in Mobiliz...">realizePosition()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3d2d1525a8835dd2650db6a6b7eae1d" title="The Matter Subsystem&#39;s realizePosition() method will call this method along with the built-in Mobiliz...">realizePosition()</a> methods.  <a href="#ac3d2d1525a8835dd2650db6a6b7eae1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a075f9a6a6c9d7e9e5e36dcdd7a91077c">realizeVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a075f9a6a6c9d7e9e5e36dcdd7a91077c" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method along with the built-in Mobiliz...">realizeVelocity()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a075f9a6a6c9d7e9e5e36dcdd7a91077c" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method along with the built-in Mobiliz...">realizeVelocity()</a> methods.  <a href="#a075f9a6a6c9d7e9e5e36dcdd7a91077c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2b0f9efdf0e933041b26b9f1869b765d">realizeDynamics</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2b0f9efdf0e933041b26b9f1869b765d" title="The Matter Subsystem&#39;s realizeDynamics() method will call this method along with the built-in Mobiliz...">realizeDynamics()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2b0f9efdf0e933041b26b9f1869b765d" title="The Matter Subsystem&#39;s realizeDynamics() method will call this method along with the built-in Mobiliz...">realizeDynamics()</a> methods.  <a href="#a2b0f9efdf0e933041b26b9f1869b765d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ae128c1105be58d233d362417ff3fa35a">realizeAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ae128c1105be58d233d362417ff3fa35a" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method along with the built-in Mob...">realizeAcceleration()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ae128c1105be58d233d362417ff3fa35a" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method along with the built-in Mob...">realizeAcceleration()</a> methods.  <a href="#ae128c1105be58d233d362417ff3fa35a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7b540d77d7e23baff099655ef690963b">realizeReport</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7b540d77d7e23baff099655ef690963b" title="The Matter Subsystem&#39;s realizeReport() method will call this method along with the built-in Mobilized...">realizeReport()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7b540d77d7e23baff099655ef690963b" title="The Matter Subsystem&#39;s realizeReport() method will call this method along with the built-in Mobilized...">realizeReport()</a> methods.  <a href="#a7b540d77d7e23baff099655ef690963b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2fe717a7b4a761f997dd581dff3f885f">MobilizedBody::CustomImpl</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is the implementation class for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html" title="The handle class MobilizedBody::Custom (dataless) and its companion class MobilizedBody::Custom::Impl...">Custom</a> mobilizers. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html" title="The handle class MobilizedBody::Custom (dataless) and its companion class MobilizedBody::Custom::Impl...">MobilizedBody::Custom</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5ab03db155da9aa8e5f969e6613bf0fd"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::~Implementation" ref="a5ab03db155da9aa8e5f969e6613bf0fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a5ab03db155da9aa8e5f969e6613bf0fd">SimTK::MobilizedBody::Custom::Implementation::~Implementation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor is virtual so derived classes get a chance to clean up if necessary. </p>

</div>
</div>
<a class="anchor" id="afd1c8f179855ba4b5c60b6885d1c9887"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::Implementation" ref="afd1c8f179855ba4b5c60b6885d1c9887" args="(SimbodyMatterSubsystem &amp;, int nu, int nq, int nAngles=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#afd1c8f179855ba4b5c60b6885d1c9887">SimTK::MobilizedBody::Custom::Implementation::Implementation</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nAngles</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html" title="This is the implementation class for Custom mobilizers.">Implementation</a> base class constructor sets the topological defaults for the number of mobilities (generalized speeds) u, the number of generalized coordinates q, and the number of those q's that are angles. </p>
<p>There can be up to 3 angular coordinates (which must be measured in radians). You also can specify 4 as the number of angles, which is interpreted to mean the the mobilizer uses a quaternion to represent orientation. Because quaternions are not appropriate for some calculations, however, the user may globally disable them by calling setUseEulerAngles() on the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>. Therefore, if you specify nAngles=4, the actual number of angular state variables may be either 3 (a set of Euler angles) or 4 (quaternion components), and the total number of state variables could be either nq-1 or nq. Before interpreting the state variables, you must first call <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a6999212221257f46895eb7a6d56b29f1" title="Get whether rotations are being represented as quaternions or Euler angles.">getUseEulerAngles()</a> to determine which representation is in use.</p>
<p>In any case, if there are any angular coordinates they must be the <em>first</em> coordinates in the array of q's associated with this mobilizer. Translational or other q's will immediately follow the angular ones. This permits Simbody to handle quaternion normalization and conversion automatically, and to find angles which need to have their sines and cosines calculated.</p>
<p>NOTE: if you don't say there are any angles, you can manage things yourself. However, there is no way to get quaternions normalized and converted if you don't tell Simbody about them. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac3c0f165813eb7491a4aaa17c6cfb9f8"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::clone" ref="ac3c0f165813eb7491a4aaa17c6cfb9f8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html">Implementation</a>* <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3c0f165813eb7491a4aaa17c6cfb9f8">SimTK::MobilizedBody::Custom::Implementation::clone</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method should produce a deep copy identical to the concrete derived <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html" title="This is the implementation class for Custom mobilizers.">Implementation</a> object underlying this <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html" title="This is the implementation class for Custom mobilizers.">Implementation</a> base class object. </p>
<p>Note that the result is new heap space; the caller must be sure to take ownership of the returned pointer and call delete on it when done. </p>

</div>
</div>
<a class="anchor" id="a2850db71037610153135583ba0f3edf4"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::getQ" ref="a2850db71037610153135583ba0f3edf4" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2850db71037610153135583ba0f3edf4">SimTK::MobilizedBody::Custom::Implementation::getQ</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a Vector containing all the generalized coordinates q currently in use by this mobilizer. </p>
<p>Note that if this mobilizer uses quaternions, the number of q's will depend on whether quaternions are currently enabled. Call <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a6999212221257f46895eb7a6d56b29f1" title="Get whether rotations are being represented as quaternions or Euler angles.">getUseEulerAngles()</a> to check this. </p>

</div>
</div>
<a class="anchor" id="ac03778d9f963f8b2d9bf889fe15a708d"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::getU" ref="ac03778d9f963f8b2d9bf889fe15a708d" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac03778d9f963f8b2d9bf889fe15a708d">SimTK::MobilizedBody::Custom::Implementation::getU</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a Vector containing all the generalized speeds u currently in use by this mobilizer. </p>

</div>
</div>
<a class="anchor" id="a4e13daf1b675ee04cd2339f8ddc959c4"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::getQDot" ref="a4e13daf1b675ee04cd2339f8ddc959c4" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4e13daf1b675ee04cd2339f8ddc959c4">SimTK::MobilizedBody::Custom::Implementation::getQDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a Vector containing all the generalized coordinate derivatives qdot currently in use by this mobilizer. </p>
<p>Note that if this mobilizer uses quaternions, the number of q's will depend on whether quaternions are currently enabled. Call <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a6999212221257f46895eb7a6d56b29f1" title="Get whether rotations are being represented as quaternions or Euler angles.">getUseEulerAngles()</a> to check this. </p>

</div>
</div>
<a class="anchor" id="ae0439ba2dcb4b778ea0f8e4a3d14fad6"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::getUDot" ref="ae0439ba2dcb4b778ea0f8e4a3d14fad6" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ae0439ba2dcb4b778ea0f8e4a3d14fad6">SimTK::MobilizedBody::Custom::Implementation::getUDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a Vector containing all the generalized accelerations udot currently in use by this mobilizer. </p>

</div>
</div>
<a class="anchor" id="a1358ffb48f0443818d30ac78afa63065"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::getQDotDot" ref="a1358ffb48f0443818d30ac78afa63065" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a1358ffb48f0443818d30ac78afa63065">SimTK::MobilizedBody::Custom::Implementation::getQDotDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a Vector containing all the generalized coordinate second derivatives qdotdot currently in use by this mobilizer. </p>
<p>Note that if this mobilizer uses quaternions, the number of q's will depend on whether quaternions are currently enabled. Call <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a6999212221257f46895eb7a6d56b29f1" title="Get whether rotations are being represented as quaternions or Euler angles.">getUseEulerAngles()</a> to check this. </p>

</div>
</div>
<a class="anchor" id="a40a0c6b00a67848863503e6504a94043"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::getMobilizerTransform" ref="a40a0c6b00a67848863503e6504a94043" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a40a0c6b00a67848863503e6504a94043">SimTK::MobilizedBody::Custom::Implementation::getMobilizerTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the cross-mobilizer transform X_FM, the body's "moving" mobilizer frame M measured and expressed in the parent body's corresponding "fixed" frame F. </p>
<p>The state must have been realized to at least Position stage. Note: this refers to F and M <em>as defined</em>, not as they are if the mobilizer has been reversed (that is, we're really returning X_F0M0 here). </p>

</div>
</div>
<a class="anchor" id="a1b9d92031b918666128e197a0542ead7"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::getMobilizerVelocity" ref="a1b9d92031b918666128e197a0542ead7" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a1b9d92031b918666128e197a0542ead7">SimTK::MobilizedBody::Custom::Implementation::getMobilizerVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the cross-mobilizer velocity V_FM, the relative velocity of this body's "moving" mobilizer frame M in the parent body's corresponding "fixed" frame F, measured and expressed in F. </p>
<p>Note that this isn't the usual spatial velocity since it isn't expressed in G. The state must have been realized to at least Velocity stage. Note: this refers to F and M <em>as defined</em>, not as they are if the mobilizer has been reversed (that is, we're really returning V_F0M0 here). </p>

</div>
</div>
<a class="anchor" id="a6999212221257f46895eb7a6d56b29f1"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::getUseEulerAngles" ref="a6999212221257f46895eb7a6d56b29f1" args="(const State &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a6999212221257f46895eb7a6d56b29f1">SimTK::MobilizedBody::Custom::Implementation::getUseEulerAngles</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get whether rotations are being represented as quaternions or Euler angles. </p>
<p>This method is only relevant if the constructor was invoked with nAngles==4. If this returns false, the first four q's should be interpreted as the components of a (possibly not normalized) quaternion. If it returns true, the first three q's should be interpreted as Euler angles.</p>
<p>Note that the total number of state variables is one less when using Euler angles than when using quaternions. </p>

</div>
</div>
<a class="anchor" id="a970f782c765862cba774461b2c7fc9bf"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::invalidateTopologyCache" ref="a970f782c765862cba774461b2c7fc9bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a970f782c765862cba774461b2c7fc9bf">SimTK::MobilizedBody::Custom::Implementation::invalidateTopologyCache</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this if you want to make sure that the next <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0" title="The Matter Subsystem&#39;s realizeTopology() method will call this method along with the built-in Mobiliz...">realizeTopology()</a> call does something. </p>
<p>This is done automatically when you modify the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> in ways understood by Simbody. But if you are just changing some of your own topology and want to make sure you get a chance to recompute something in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0" title="The Matter Subsystem&#39;s realizeTopology() method will call this method along with the built-in Mobiliz...">realizeTopology()</a>, make this call at the time of modification. </p>

</div>
</div>
<a class="anchor" id="a1443aac6089cc6f2c1e85c8b5aa4f4c2"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::calcMobilizerTransformFromQ" ref="a1443aac6089cc6f2c1e85c8b5aa4f4c2" args="(const State &amp;s, int nq, const Real *q) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a1443aac6089cc6f2c1e85c8b5aa4f4c2">SimTK::MobilizedBody::Custom::Implementation::calcMobilizerTransformFromQ</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given values for this mobilizer's nq generalized coordinates q, compute X_FM(q), that is, the cross-mobilizer spatial Transform giving the configuration of the "moving" frame M fixed to the outboard (child) body B in the "fixed" frame F attached to the inboard (parent) body P. </p>
<p>The state is guaranteed to have been realized to at least Instance stage. Caution: if your mobilizer has a quaternion, the four q's will not necessarily be normalized here but you <em>must</em> normalize them before converting them to a Rotation. Casting them to a Quaternion will do that automatically. </p>

</div>
</div>
<a class="anchor" id="a3e218c380d12a9f4af73d5072cfc6034"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::multiplyByHMatrix" ref="a3e218c380d12a9f4af73d5072cfc6034" args="(const State &amp;s, int nu, const Real *u) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a3e218c380d12a9f4af73d5072cfc6034">SimTK::MobilizedBody::Custom::Implementation::multiplyByHMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate V_FM(u) = H*u where H=H(q) is the joint transition matrix mapping the mobilities to the relative spatial velocity between the F frame on the parent to the M frame on the child. </p>
<p>The state is guaranteed to have been realized to at least Position stage.</p>
<p>IMPORTANT -- H should depend only on X_FM(q), not directly on q, since different sets of q's can generate the same Transform (e.g. quaternions and Euler angles). You can call getMobilizerTransform(s) to get the already calculated Transform.</p>
<p>EVEN MORE IMPORTANT -- H here must be the same as the H^T used in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7d85e17cf561d35aba399e1b3a0c87b5" title="Calculate f = ~H*F where F is a spatial force (torque+force) and f is its mapping onto the mobilities...">multiplyByHTranspose()</a>, and the HDot methods must use the time derivative of H.</p>
<p>Note: the "H" we're using here is the transpose of what is used in Schwieter's IVM paper and in all of Abhi Jain's papers. That's because Jain used H^T as the joint kinematics Jacobian, with H being the force transmission matrix which no mobilizer-writing user is going to be thinking about. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7d85e17cf561d35aba399e1b3a0c87b5" title="Calculate f = ~H*F where F is a spatial force (torque+force) and f is its mapping onto the mobilities...">multiplyByHTranspose()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d85e17cf561d35aba399e1b3a0c87b5"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::multiplyByHTranspose" ref="a7d85e17cf561d35aba399e1b3a0c87b5" args="(const State &amp;s, const SpatialVec &amp;F, int nu, Real *f) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7d85e17cf561d35aba399e1b3a0c87b5">SimTK::MobilizedBody::Custom::Implementation::multiplyByHTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate f = ~H*F where F is a spatial force (torque+force) and f is its mapping onto the mobilities. </p>
<p>IMPORTANT -- H should depend only on X_FM(q), not directly on q, since different sets of q's can generate the same Transform (e.g. quaternions and Euler angles). You can call getMobilizerTransform(s) to get the already calculated Transform. H here must match H and HDot in the other methods for this mobilizer. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a3e218c380d12a9f4af73d5072cfc6034" title="Calculate V_FM(u) = H*u where H=H(q) is the joint transition matrix mapping the mobilities to the rel...">multiplyByHMatrix()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9263c8eed08cf33cd00f31fdb2301146"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::multiplyByHDotMatrix" ref="a9263c8eed08cf33cd00f31fdb2301146" args="(const State &amp;s, int nu, const Real *u) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a9263c8eed08cf33cd00f31fdb2301146">SimTK::MobilizedBody::Custom::Implementation::multiplyByHDotMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate A0_FM = HDot*u where HDot=HDot(q,u) is the time derivative of H. </p>
<p>This calculates the "bias acceleration" due to coriolis effects, such that the full cross-mobilizer acceleration is A_FM=A0_FM + H*udot. The state is guaranteed to have been realized to at least Velocity stage.</p>
<p>IMPORTANT -- HDot should depend only on X_FM(q) and V_FM(q,u), not directly on q or u, since different choices of coordinates can generate the same X and V, but all such choices must produce the same H and HDot. You can call getMobilizerTransform(s) to get the already calculated Transform, and getMobilizerVelocity(s) to get the already calculated velocity. </p>

</div>
</div>
<a class="anchor" id="af3e9247d1a717df881ed2654300ee9ef"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::multiplyByHDotTranspose" ref="af3e9247d1a717df881ed2654300ee9ef" args="(const State &amp;s, const SpatialVec &amp;F, int nu, Real *f) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#af3e9247d1a717df881ed2654300ee9ef">SimTK::MobilizedBody::Custom::Implementation::multiplyByHDotTranspose</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate f = ~HDot*F where F is a spatial vector and f is its mapping onto the mobilities. </p>
<p>The state is guaranteed to have been realized to at least Velocity stage.</p>
<p>IMPORTANT -- HDot should depend only on X_FM(q) and V_FM(q,u), not directly on q or u, since different choices of coordinates can generate the same X and V, but all such choices must produce the same H and HDot. You can call getMobilizerTransform(s) to get the already calculated Transform, and getMobilizerVelocity(s) to get the already calculated velocity. </p>

</div>
</div>
<a class="anchor" id="a0038e9bc6b9f7337601ca2e085229549"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::multiplyByN" ref="a0038e9bc6b9f7337601ca2e085229549" args="(const State &amp;s, bool transposeMatrix, int nIn, const Real *in, int nOut, Real *out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a0038e9bc6b9f7337601ca2e085229549">SimTK::MobilizedBody::Custom::Implementation::multiplyByN</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate out_q = N(q)*in_u (e.g., qdot=N*u) or out_u = ~N*in_q. </p>
<p>Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by N on the right, with the Vectors viewed as RowVectors instead. The default implementation assumes that N is an identity matrix, and will only work if nq=nu=nIn=nOut and nAngles &lt; 4 (i.e., no quaternions). If this is true for your mobilizer, you do not need to implement this method.</p>
<p>The state is guaranteed to have been realized to at least Position stage. </p>

</div>
</div>
<a class="anchor" id="a301c187b22f0366db831e3c4bc8a55d5"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::multiplyByNInv" ref="a301c187b22f0366db831e3c4bc8a55d5" args="(const State &amp;s, bool transposeMatrix, int nIn, const Real *in, int nOut, Real *out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a301c187b22f0366db831e3c4bc8a55d5">SimTK::MobilizedBody::Custom::Implementation::multiplyByNInv</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate out_u = NInv(q)*in_q (e.g., u=NInv*qdot) or out_q = ~NInv*in_u. </p>
<p>Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by NInv on the right, with the Vectors viewed as RowVectors instead. The default implementation assumes that NInv is an identity matrix, and will only work if nq=nu=nIn=nOut and nAngles &lt; 4 (i.e., no quaternions). If this is true for your mobilizer, you do not need to implement this method.</p>
<p>The state is guaranteed to have been realized to at least Position stage. </p>

</div>
</div>
<a class="anchor" id="a4f680117b0024df633655911cda13cb0"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::multiplyByNDot" ref="a4f680117b0024df633655911cda13cb0" args="(const State &amp;s, bool transposeMatrix, int nIn, const Real *in, int nOut, Real *out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f680117b0024df633655911cda13cb0">SimTK::MobilizedBody::Custom::Implementation::multiplyByNDot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate out_q = NDot(q)*in_u or out_u = ~NDot*in_q. </p>
<p>Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by NDot on the right, with the Vectors viewed as RowVectors instead. The default implementation assumes that NDot is zero, and will only work if nq=nu=nIn=nOut and nAngles &lt; 4 (i.e., no quaternions) If this is true for your mobilizer, you do not need to implement this method.</p>
<p>The state is guaranteed to have been realized to at least Position stage. </p>

</div>
</div>
<a class="anchor" id="a69b034e9b66fe77603a5f514999b3621"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::setQToFitTransform" ref="a69b034e9b66fe77603a5f514999b3621" args="(const State &amp;, const Transform &amp;X_FM, int nq, Real *q) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a69b034e9b66fe77603a5f514999b3621">SimTK::MobilizedBody::Custom::Implementation::setQToFitTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a set of q's for this mobilizer that best approximate the supplied Transform which requests a particular relative orientation and translation between the "fixed" and "moving" frames connected by this mobilizer. </p>
<p>The state is guaranteed to have been realized to at least Instance stage.</p>
<p>The default implementation uses a nonlinear optimizer to search for the best fit. Whenever possible, subclasses should override this to provide a faster and more robust implementation. </p>

</div>
</div>
<a class="anchor" id="a4a5622b63a472b2e2ca5275556521962"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::setUToFitVelocity" ref="a4a5622b63a472b2e2ca5275556521962" args="(const State &amp;, const SpatialVec &amp;V_FM, int nu, Real *u) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4a5622b63a472b2e2ca5275556521962">SimTK::MobilizedBody::Custom::Implementation::setUToFitVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a set of u's (generalized speeds) for this mobilizer that best approximate the supplied spatial velocity <code>V_FM</code> which requests the relative angular and linear velocity between the "fixed" and "moving" frames connected by this mobilizer. </p>
<p>Routines which affect generalized speeds u depend on the generalized coordinates q already having been set; they never change these coordinates. The state is guaranteed to have been realized to at least Position stage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a69b034e9b66fe77603a5f514999b3621" title="Find a set of q&#39;s for this mobilizer that best approximate the supplied Transform which requests a pa...">setQToFitTransform()</a></dd></dl>
<p>The default implementation uses a nonlinear optimizer to search for the best fit. Whenever possible, subclasses should override this to provide a faster and more robust implementation. </p>

</div>
</div>
<a class="anchor" id="a2f2612a5b9f913fcedaff2aa6cc22719"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::calcDecorativeGeometryAndAppend" ref="a2f2612a5b9f913fcedaff2aa6cc22719" args="(const State &amp;s, Stage stage, Array_&lt; DecorativeGeometry &gt; &amp;geom) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2f2612a5b9f913fcedaff2aa6cc22719">SimTK::MobilizedBody::Custom::Implementation::calcDecorativeGeometryAndAppend</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>geom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implement this optional method if you would like your <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> to generate any suggestions for geometry that could be used as default visualization as an aid to understanding a system containing this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. </p>
<p>For example, if your mobilizer connects two points, you might want to draw a line between those points. You can also generate text labels, and you can provide methods for controlling the presence or appearance of your generated geometry. If you don't implement this routine no extra geometry will be generated here. </p>

</div>
</div>
<a class="anchor" id="a4f47ca2f3772d58b58816d9ed37cf8f0"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizeTopology" ref="a4f47ca2f3772d58b58816d9ed37cf8f0" args="(State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0">SimTK::MobilizedBody::Custom::Implementation::realizeTopology</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0" title="The Matter Subsystem&#39;s realizeTopology() method will call this method along with the built-in Mobiliz...">realizeTopology()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a4f47ca2f3772d58b58816d9ed37cf8f0" title="The Matter Subsystem&#39;s realizeTopology() method will call this method along with the built-in Mobiliz...">realizeTopology()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>pre-calculate Topology stage "cache" values (mutable values which are stored in the derived <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html" title="This is the implementation class for Custom mobilizers.">Implementation</a> class directly), and</li>
<li>allocate Model-stage state variables for later use, and</li>
<li>allocate Model-stage cache entries in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. The indices to the Model-stage state &amp; cache entries are stored locally as part of the Topology-stage cache. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2114ad8d6a1dc4beb74a5862da38255b"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizeModel" ref="a2114ad8d6a1dc4beb74a5862da38255b" args="(State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2114ad8d6a1dc4beb74a5862da38255b">SimTK::MobilizedBody::Custom::Implementation::realizeModel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2114ad8d6a1dc4beb74a5862da38255b" title="The Matter Subsystem&#39;s realizeModel() method will call this method along with the built-in MobilizedB...">realizeModel()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2114ad8d6a1dc4beb74a5862da38255b" title="The Matter Subsystem&#39;s realizeModel() method will call this method along with the built-in MobilizedB...">realizeModel()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>pre-calculate Model stage cache values according to the settings of the Model variables,</li>
<li>allocate any later-Stage variables that may be needed (typically these will be Instance stage variables containing geometric information or parameters like lengths or pitch for a <a class="el" href="classSimTK_1_1MobilizedBody_1_1Screw.html" title="One mobility -- coordinated rotation and translation along the common z axis of the inboard and outbo...">Screw</a>. The indices to any of the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> entries allocated here are stored in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a> as part of the Model-stage cache. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad7b28bd19fe6d7836c3d31e8ddcef4e8"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizeInstance" ref="ad7b28bd19fe6d7836c3d31e8ddcef4e8" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ad7b28bd19fe6d7836c3d31e8ddcef4e8">SimTK::MobilizedBody::Custom::Implementation::realizeInstance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ad7b28bd19fe6d7836c3d31e8ddcef4e8" title="The Matter Subsystem&#39;s realizeInstance() method will call this method along with the built-in Mobiliz...">realizeInstance()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ad7b28bd19fe6d7836c3d31e8ddcef4e8" title="The Matter Subsystem&#39;s realizeInstance() method will call this method along with the built-in Mobiliz...">realizeInstance()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>pre-calculate Instance stage cache values according to the settings of the Instance variables. </li>
</ul>

</div>
</div>
<a class="anchor" id="a917bb2733422da09a3208eda81e7ce5f"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizeTime" ref="a917bb2733422da09a3208eda81e7ce5f" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a917bb2733422da09a3208eda81e7ce5f">SimTK::MobilizedBody::Custom::Implementation::realizeTime</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a917bb2733422da09a3208eda81e7ce5f" title="The Matter Subsystem&#39;s realizeTime() method will call this method along with the built-in MobilizedBo...">realizeTime()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a917bb2733422da09a3208eda81e7ce5f" title="The Matter Subsystem&#39;s realizeTime() method will call this method along with the built-in MobilizedBo...">realizeTime()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>pre-calculate Time stage cache values according to the current value of time found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac3d2d1525a8835dd2650db6a6b7eae1d"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizePosition" ref="ac3d2d1525a8835dd2650db6a6b7eae1d" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3d2d1525a8835dd2650db6a6b7eae1d">SimTK::MobilizedBody::Custom::Implementation::realizePosition</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3d2d1525a8835dd2650db6a6b7eae1d" title="The Matter Subsystem&#39;s realizePosition() method will call this method along with the built-in Mobiliz...">realizePosition()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ac3d2d1525a8835dd2650db6a6b7eae1d" title="The Matter Subsystem&#39;s realizePosition() method will call this method along with the built-in Mobiliz...">realizePosition()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>pre-calculate Position stage cache values according to the current values of positions found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. Note that this is called <em>before</em> methods which implement operators involving position-dependent matrices N and H. </li>
</ul>

</div>
</div>
<a class="anchor" id="a075f9a6a6c9d7e9e5e36dcdd7a91077c"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizeVelocity" ref="a075f9a6a6c9d7e9e5e36dcdd7a91077c" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a075f9a6a6c9d7e9e5e36dcdd7a91077c">SimTK::MobilizedBody::Custom::Implementation::realizeVelocity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a075f9a6a6c9d7e9e5e36dcdd7a91077c" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method along with the built-in Mobiliz...">realizeVelocity()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a075f9a6a6c9d7e9e5e36dcdd7a91077c" title="The Matter Subsystem&#39;s realizeVelocity() method will call this method along with the built-in Mobiliz...">realizeVelocity()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>pre-calculate Velocity stage cache values according to the current values of velocities found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. Note that this is called <em>before</em> methods which implement operators involving velocity-dependent matrices NDot and HDot. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2b0f9efdf0e933041b26b9f1869b765d"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizeDynamics" ref="a2b0f9efdf0e933041b26b9f1869b765d" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2b0f9efdf0e933041b26b9f1869b765d">SimTK::MobilizedBody::Custom::Implementation::realizeDynamics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2b0f9efdf0e933041b26b9f1869b765d" title="The Matter Subsystem&#39;s realizeDynamics() method will call this method along with the built-in Mobiliz...">realizeDynamics()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a2b0f9efdf0e933041b26b9f1869b765d" title="The Matter Subsystem&#39;s realizeDynamics() method will call this method along with the built-in Mobiliz...">realizeDynamics()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>pre-calculate Dynamics stage cache values according to the current values found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. Computations at Dynamics stage cannot affect the behavior of the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> since that is completely determined by the Position and Velocity stage operators. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae128c1105be58d233d362417ff3fa35a"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizeAcceleration" ref="ae128c1105be58d233d362417ff3fa35a" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ae128c1105be58d233d362417ff3fa35a">SimTK::MobilizedBody::Custom::Implementation::realizeAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ae128c1105be58d233d362417ff3fa35a" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method along with the built-in Mob...">realizeAcceleration()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#ae128c1105be58d233d362417ff3fa35a" title="The Matter Subsystem&#39;s realizeAcceleration() method will call this method along with the built-in Mob...">realizeAcceleration()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>pre-calculate Acceleration stage cache values according to the current values of body and mobility accelerations found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. Computations at Acceleration stage cannot affect the behavior of the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> since that is completely determined by the Position and Velocity stage operators. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7b540d77d7e23baff099655ef690963b"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::realizeReport" ref="a7b540d77d7e23baff099655ef690963b" args="(const State &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7b540d77d7e23baff099655ef690963b">SimTK::MobilizedBody::Custom::Implementation::realizeReport</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Matter <a class="el" href="classSimTK_1_1Subsystem.html" title="The abstract parent of all Subsystems.">Subsystem</a>'s <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7b540d77d7e23baff099655ef690963b" title="The Matter Subsystem&#39;s realizeReport() method will call this method along with the built-in Mobilized...">realizeReport()</a> method will call this method along with the built-in MobilizedBodies' <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html#a7b540d77d7e23baff099655ef690963b" title="The Matter Subsystem&#39;s realizeReport() method will call this method along with the built-in Mobilized...">realizeReport()</a> methods. </p>
<p>This gives the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> a chance to</p>
<ul>
<li>calculate Report stage cache values according to the current values found in the <a class="el" href="classSimTK_1_1State.html" title="This is the handle class for the hidden State implementation.">State</a>. Computations at Report stage cannot affect the progress of a simulation in any way. </li>
</ul>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a2fe717a7b4a761f997dd581dff3f885f"></a><!-- doxytag: member="SimTK::MobilizedBody::Custom::Implementation::MobilizedBody::CustomImpl" ref="a2fe717a7b4a761f997dd581dff3f885f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class MobilizedBody::CustomImpl<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MobilizedBody__Custom_8h_source.html">MobilizedBody_Custom.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html">Custom</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html">Implementation</a>      </li>

    <li class="footer">Generated on Mon Jul 14 2014 23:26:04 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
