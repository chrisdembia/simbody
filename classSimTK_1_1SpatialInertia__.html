<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: SimTK::SpatialInertia_&lt; P &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classSimTK_1_1SpatialInertia__.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::SpatialInertia_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SimTK::SpatialInertia_" -->
<p>A spatial inertia contains the mass, center of mass point, and inertia matrix for a rigid body.  
 <a href="classSimTK_1_1SpatialInertia__.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MassProperties_8h_source.html">MassProperties.h</a>&gt;</code></p>

<p><a href="classSimTK_1_1SpatialInertia__-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a5a18e7fd09141c51fbaa54258117ccdb">SpatialInertia_</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor fills everything with NaN, even in Release mode.  <a href="#a5a18e7fd09141c51fbaa54258117ccdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#ab5b284bdee64fb8b30f434bccb8b718f">SpatialInertia_</a> (RealP mass, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;com, const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;gyration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#ad6c076c62aa1294911c7ff7752394c86">setMass</a> (RealP mass)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a04b055dd19ea4987cdf9a88810543a58">setMassCenter</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;com)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a147ff1b0fe566a4b8c65988d41171315">setUnitInertia</a> (const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;gyration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a762590b92c50cb50029734c74eee6e79">getMass</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a7f900c3e5e922ce38699a5efeb810a77">getMassCenter</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a6773b0b67718b80e867a90f1ed6b857e">getUnitInertia</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a95cfb63169ec43c12f067600d1a03718">calcMassMoment</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the first mass moment (mass-weighted COM location) from the mass and COM vector.  <a href="#a95cfb63169ec43c12f067600d1a03718"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">InertiaP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#abe5e20ab4de7ae55024c9f6219d1febb">calcInertia</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inertia matrix (second mass moment, mass-weighted gyration matrix) from the mass and unit inertia matrix.  <a href="#abe5e20ab4de7ae55024c9f6219d1febb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a7cc7b7d2e8a3d7a17a7a6208efea9e31">operator+=</a> (const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in a compatible SpatialInertia.  <a href="#a7cc7b7d2e8a3d7a17a7a6208efea9e31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a16b3ffe93dd0a5b9a87651306f5f9137">operator-=</a> (const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off a compatible SpatialInertia.  <a href="#a16b3ffe93dd0a5b9a87651306f5f9137"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a1210e27aeaf4c729c0fa9f3b7504fb35">operator*=</a> (const RealP &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a SpatialInertia by a scalar.  <a href="#a1210e27aeaf4c729c0fa9f3b7504fb35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a27c2d4d66bd4bbb6d843914181e93bc4">operator/=</a> (const RealP &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a SpatialInertia by a scalar.  <a href="#a27c2d4d66bd4bbb6d843914181e93bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">SpatialVecP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#ae27f14b5f3ccf81f7f05b95712b36784">operator*</a> (const <a class="el" href="classSimTK_1_1Vec.html">SpatialVecP</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a SpatialInertia by a SpatialVec to produce a SpatialVec result; 45 flops.  <a href="#ae27f14b5f3ccf81f7f05b95712b36784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a38d2cb7d77972fb33fa5d794d6b3ac63">reexpress</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new SpatialInertia object which is the same as this one except re-expressed in another coordinate frame.  <a href="#a38d2cb7d77972fb33fa5d794d6b3ac63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#ac6121fedec819b4562d2453c83b182f1">reexpress</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#ac6121fedec819b4562d2453c83b182f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c53418feeabe8460aa257c937bc4995">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this SpatialInertia in another frame, modifying the original object.  <a href="#a8c53418feeabe8460aa257c937bc4995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#aeb844974c0f911186c3e04eb773f55e6">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#aeb844974c0f911186c3e04eb773f55e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#aded210e33511953be4e804cc8181a3dd">shift</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;S) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new SpatialInertia object which is the same as this one except the origin ("taken about" point) has changed from OF to OF+S.  <a href="#aded210e33511953be4e804cc8181a3dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c47be818f2ff9a2e99317bf70dc6899">shiftInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change origin from OF to OF+S, modifying the original object in place.  <a href="#a8c47be818f2ff9a2e99317bf70dc6899"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#af470ddf2aa42d86b56b846ef89d205b9">transform</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_FB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new SpatialInertia object which is the same as this one but measured about and expressed in a new frame.  <a href="#af470ddf2aa42d86b56b846ef89d205b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a9cd793bc0b9a0de19c6a3e96557f6ae0">transform</a> (const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;X_FB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform using an inverse transform to avoid having to convert it.  <a href="#a9cd793bc0b9a0de19c6a3e96557f6ae0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a70ed68773d8508b66b575860a6b8c7d1">transformInPlace</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_FB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform this SpatialInertia object so that it is measured about and expressed in a new frame, modifying the object in place.  <a href="#a70ed68773d8508b66b575860a6b8c7d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a730a21dc374eb7f7e5b230829c34ad32">transformInPlace</a> (const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;X_FB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform using an inverse transform to avoid having to convert it.  <a href="#a730a21dc374eb7f7e5b230829c34ad32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html">SpatialMatP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a461a0f13fb5b50e970416b0781d4631d">toSpatialMat</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#aa8fbbb1b76326c2960f89c3cc17256e3">operator+</a> (const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two compatible spatial inertias.  <a href="#aa8fbbb1b76326c2960f89c3cc17256e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a28bcef8b2f22a45c06652f13976e1eec">operator-</a> (const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one compatible spatial inertia from another.  <a href="#a28bcef8b2f22a45c06652f13976e1eec"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br/>
class SimTK::SpatialInertia_&lt; P &gt;</h3>

<p>A spatial inertia contains the mass, center of mass point, and inertia matrix for a rigid body. </p>
<p>This is 10 independent quantities altogether; however, inertia is mass-scaled making it linearly dependent on the mass. Here instead we represent inertia using a unit inertia matrix, which is equivalent to the inertia this body would have if it had unit mass. Then the actual inertia is given by mass*unitInertia. In this manner the mass, center of mass location, and inertia are completely independent so can be changed separately. That means if you double the mass, you'll also double the inertia as you would expect.</p>
<p>Spatial inertia may be usefully viewed as a symmetric spatial matrix, that is, a 6x6 symmetric matrix arranged as 2x2 blocks of 3x3 matrices. Although this class represents the spatial inertia in compact form, it supports methods and operators that allow it to behave as though it were a spatial matrix (except much faster to work with). In spatial matrix form, the matrix has the following interpretation: </p>
<pre>
              [  m*G   m*px ]
          M = [             ]
              [ -m*px  m*I  ]
</pre><p> Here m is mass, p is the vector from the body origin to the center of mass, G is the 3x3 symmetric unit inertia (gyration) matrix, and I is a 3x3 identity matrix. "px" indicates the skew symmetric cross product matrix formed from the vector p, so -px=~px.</p>
<h3>Abbreviations</h3>
<p>Typedefs exist for the most common invocations of <a class="el" href="classSimTK_1_1SpatialInertia__.html" title="A spatial inertia contains the mass, center of mass point, and inertia matrix for a rigid body...">SpatialInertia_</a>&lt;P&gt;:</p>
<ul>
<li><a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a> for default Real precision (this is almost always used)</li>
<li><a class="el" href="namespaceSimTK.html#a9d341aa61d4a6e53db1e610ac22e39b5">fSpatialInertia</a> for single (float) precision</li>
<li><a class="el" href="namespaceSimTK.html#a014e74e4b8e0c5775715942ad5086dea">dSpatialInertia</a> for double precision </li>
</ul>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5a18e7fd09141c51fbaa54258117ccdb"></a><!-- doxytag: member="SimTK::SpatialInertia_::SpatialInertia_" ref="a5a18e7fd09141c51fbaa54258117ccdb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default constructor fills everything with NaN, even in Release mode. </p>

</div>
</div>
<a class="anchor" id="ab5b284bdee64fb8b30f434bccb8b718f"></a><!-- doxytag: member="SimTK::SpatialInertia_::SpatialInertia_" ref="ab5b284bdee64fb8b30f434bccb8b718f" args="(RealP mass, const Vec3P &amp;com, const UnitInertiaP &amp;gyration)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>com</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;&#160;</td>
          <td class="paramname"><em>gyration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad6c076c62aa1294911c7ff7752394c86"></a><!-- doxytag: member="SimTK::SpatialInertia_::setMass" ref="ad6c076c62aa1294911c7ff7752394c86" args="(RealP mass)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#ad6c076c62aa1294911c7ff7752394c86">setMass</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>mass</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a04b055dd19ea4987cdf9a88810543a58"></a><!-- doxytag: member="SimTK::SpatialInertia_::setMassCenter" ref="a04b055dd19ea4987cdf9a88810543a58" args="(const Vec3P &amp;com)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a04b055dd19ea4987cdf9a88810543a58">setMassCenter</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>com</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a147ff1b0fe566a4b8c65988d41171315"></a><!-- doxytag: member="SimTK::SpatialInertia_::setUnitInertia" ref="a147ff1b0fe566a4b8c65988d41171315" args="(const UnitInertiaP &amp;gyration)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a147ff1b0fe566a4b8c65988d41171315">setUnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;&#160;</td>
          <td class="paramname"><em>gyration</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a762590b92c50cb50029734c74eee6e79"></a><!-- doxytag: member="SimTK::SpatialInertia_::getMass" ref="a762590b92c50cb50029734c74eee6e79" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a762590b92c50cb50029734c74eee6e79">getMass</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f900c3e5e922ce38699a5efeb810a77"></a><!-- doxytag: member="SimTK::SpatialInertia_::getMassCenter" ref="a7f900c3e5e922ce38699a5efeb810a77" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a7f900c3e5e922ce38699a5efeb810a77">getMassCenter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6773b0b67718b80e867a90f1ed6b857e"></a><!-- doxytag: member="SimTK::SpatialInertia_::getUnitInertia" ref="a6773b0b67718b80e867a90f1ed6b857e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a6773b0b67718b80e867a90f1ed6b857e">getUnitInertia</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a95cfb63169ec43c12f067600d1a03718"></a><!-- doxytag: member="SimTK::SpatialInertia_::calcMassMoment" ref="a95cfb63169ec43c12f067600d1a03718" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a95cfb63169ec43c12f067600d1a03718">calcMassMoment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the first mass moment (mass-weighted COM location) from the mass and COM vector. </p>
<p>Cost is 3 inline flops. </p>

</div>
</div>
<a class="anchor" id="abe5e20ab4de7ae55024c9f6219d1febb"></a><!-- doxytag: member="SimTK::SpatialInertia_::calcInertia" ref="abe5e20ab4de7ae55024c9f6219d1febb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">InertiaP</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#abe5e20ab4de7ae55024c9f6219d1febb">calcInertia</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the inertia matrix (second mass moment, mass-weighted gyration matrix) from the mass and unit inertia matrix. </p>
<p>Cost is 6 inline flops. </p>

</div>
</div>
<a class="anchor" id="a7cc7b7d2e8a3d7a17a7a6208efea9e31"></a><!-- doxytag: member="SimTK::SpatialInertia_::operator+=" ref="a7cc7b7d2e8a3d7a17a7a6208efea9e31" args="(const SpatialInertia_ &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add in a compatible SpatialInertia. </p>
<p>This is only valid if both SpatialInertias are expressed in the same frame and measured about the same point but there is no way for this method to check. Cost is about 40 flops. </p>

</div>
</div>
<a class="anchor" id="a16b3ffe93dd0a5b9a87651306f5f9137"></a><!-- doxytag: member="SimTK::SpatialInertia_::operator&#45;=" ref="a16b3ffe93dd0a5b9a87651306f5f9137" args="(const SpatialInertia_ &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract off a compatible SpatialInertia. </p>
<p>This is only valid if both SpatialInertias are expressed in the same frame and measured about the same point but there is no way for this method to check. Cost is about 40 flops. </p>

</div>
</div>
<a class="anchor" id="a1210e27aeaf4c729c0fa9f3b7504fb35"></a><!-- doxytag: member="SimTK::SpatialInertia_::operator*=" ref="a1210e27aeaf4c729c0fa9f3b7504fb35" args="(const RealP &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a SpatialInertia by a scalar. </p>
<p>Because we keep the mass factored out, this requires only a single multiply. </p>

</div>
</div>
<a class="anchor" id="a27c2d4d66bd4bbb6d843914181e93bc4"></a><!-- doxytag: member="SimTK::SpatialInertia_::operator/=" ref="a27c2d4d66bd4bbb6d843914181e93bc4" args="(const RealP &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide a SpatialInertia by a scalar. </p>
<p>Because we keep the mass factored out, this requires only a single divide. </p>

</div>
</div>
<a class="anchor" id="ae27f14b5f3ccf81f7f05b95712b36784"></a><!-- doxytag: member="SimTK::SpatialInertia_::operator*" ref="ae27f14b5f3ccf81f7f05b95712b36784" args="(const SpatialVecP &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SpatialVecP</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">SpatialVecP</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a SpatialInertia by a SpatialVec to produce a SpatialVec result; 45 flops. </p>

</div>
</div>
<a class="anchor" id="a38d2cb7d77972fb33fa5d794d6b3ac63"></a><!-- doxytag: member="SimTK::SpatialInertia_::reexpress" ref="a38d2cb7d77972fb33fa5d794d6b3ac63" args="(const Rotation_&lt; P &gt; &amp;R_FB) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a38d2cb7d77972fb33fa5d794d6b3ac63">reexpress</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a new SpatialInertia object which is the same as this one except re-expressed in another coordinate frame. </p>
<p>We consider this object to be expressed in some frame F and we're given a rotation matrix R_FB we can use to re-express in a new frame B. Cost is 72 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c53418feeabe8460aa257c937bc4995" title="Re-express this SpatialInertia in another frame, modifying the original object.">reexpressInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6121fedec819b4562d2453c83b182f1"></a><!-- doxytag: member="SimTK::SpatialInertia_::reexpress" ref="ac6121fedec819b4562d2453c83b182f1" args="(const InverseRotation_&lt; P &gt; &amp;R_FB) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a38d2cb7d77972fb33fa5d794d6b3ac63">reexpress</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>rexpress(Rotation) for information </dd></dl>

</div>
</div>
<a class="anchor" id="a8c53418feeabe8460aa257c937bc4995"></a><!-- doxytag: member="SimTK::SpatialInertia_::reexpressInPlace" ref="a8c53418feeabe8460aa257c937bc4995" args="(const Rotation_&lt; P &gt; &amp;R_FB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c53418feeabe8460aa257c937bc4995">reexpressInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-express this SpatialInertia in another frame, modifying the original object. </p>
<p>We return a reference to the object so that you can chain this operation in the manner of assignment operators. Cost is 72 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a38d2cb7d77972fb33fa5d794d6b3ac63" title="Return a new SpatialInertia object which is the same as this one except re-expressed in another coord...">reexpress()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb844974c0f911186c3e04eb773f55e6"></a><!-- doxytag: member="SimTK::SpatialInertia_::reexpressInPlace" ref="aeb844974c0f911186c3e04eb773f55e6" args="(const InverseRotation_&lt; P &gt; &amp;R_FB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c53418feeabe8460aa257c937bc4995">reexpressInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>rexpressInPlace(Rotation) for information </dd></dl>

</div>
</div>
<a class="anchor" id="aded210e33511953be4e804cc8181a3dd"></a><!-- doxytag: member="SimTK::SpatialInertia_::shift" ref="aded210e33511953be4e804cc8181a3dd" args="(const Vec3P &amp;S) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#aded210e33511953be4e804cc8181a3dd">shift</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a new SpatialInertia object which is the same as this one except the origin ("taken about" point) has changed from OF to OF+S. </p>
<p>Cost is 37 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c47be818f2ff9a2e99317bf70dc6899" title="Change origin from OF to OF+S, modifying the original object in place.">shiftInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8c47be818f2ff9a2e99317bf70dc6899"></a><!-- doxytag: member="SimTK::SpatialInertia_::shiftInPlace" ref="a8c47be818f2ff9a2e99317bf70dc6899" args="(const Vec3P &amp;S)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c47be818f2ff9a2e99317bf70dc6899">shiftInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change origin from OF to OF+S, modifying the original object in place. </p>
<p>Returns a reference to the modified object so that you can chain this operation in the manner of assignment operators. Cost is 37 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#aded210e33511953be4e804cc8181a3dd" title="Return a new SpatialInertia object which is the same as this one except the origin (&quot;taken about&quot; poi...">shift()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a class="anchor" id="af470ddf2aa42d86b56b846ef89d205b9"></a><!-- doxytag: member="SimTK::SpatialInertia_::transform" ref="af470ddf2aa42d86b56b846ef89d205b9" args="(const Transform_&lt; P &gt; &amp;X_FB) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#af470ddf2aa42d86b56b846ef89d205b9">transform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a new SpatialInertia object which is the same as this one but measured about and expressed in a new frame. </p>
<p>We consider the current spatial inertia M to be measured (implicitly) in some frame F, that is, we have M=M_OF_F. We want M_OB_B for some new frame B, given the transform X_FB giving the location and orientation of B in F. This combines the <a class="el" href="classSimTK_1_1SpatialInertia__.html#a38d2cb7d77972fb33fa5d794d6b3ac63" title="Return a new SpatialInertia object which is the same as this one except re-expressed in another coord...">reexpress()</a> and <a class="el" href="classSimTK_1_1SpatialInertia__.html#aded210e33511953be4e804cc8181a3dd" title="Return a new SpatialInertia object which is the same as this one except the origin (&quot;taken about&quot; poi...">shift()</a> operations available separately. Cost is 109 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a70ed68773d8508b66b575860a6b8c7d1" title="Transform this SpatialInertia object so that it is measured about and expressed in a new frame...">transformInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9cd793bc0b9a0de19c6a3e96557f6ae0"></a><!-- doxytag: member="SimTK::SpatialInertia_::transform" ref="a9cd793bc0b9a0de19c6a3e96557f6ae0" args="(const InverseTransform_&lt; P &gt; &amp;X_FB) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#af470ddf2aa42d86b56b846ef89d205b9">transform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform using an inverse transform to avoid having to convert it. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>transform(Transform) for information </dd></dl>

</div>
</div>
<a class="anchor" id="a70ed68773d8508b66b575860a6b8c7d1"></a><!-- doxytag: member="SimTK::SpatialInertia_::transformInPlace" ref="a70ed68773d8508b66b575860a6b8c7d1" args="(const Transform_&lt; P &gt; &amp;X_FB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a70ed68773d8508b66b575860a6b8c7d1">transformInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform this SpatialInertia object so that it is measured about and expressed in a new frame, modifying the object in place. </p>
<p>We consider the current spatial inertia M to be measured (implicitly) in some frame F, that is, we have M=M_OF_F. We want to change it to M_OB_B for some new frame B, given the transform X_FB giving the location and orientation of B in F. This combines the <a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c53418feeabe8460aa257c937bc4995" title="Re-express this SpatialInertia in another frame, modifying the original object.">reexpressInPlace()</a> and <a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c47be818f2ff9a2e99317bf70dc6899" title="Change origin from OF to OF+S, modifying the original object in place.">shiftInPlace()</a> operations available separately. Returns a reference to the modified object so that you can chain this operation in the manner of assignment operators. Cost is 109 flops. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#af470ddf2aa42d86b56b846ef89d205b9" title="Return a new SpatialInertia object which is the same as this one but measured about and expressed in ...">transform()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a class="anchor" id="a730a21dc374eb7f7e5b230829c34ad32"></a><!-- doxytag: member="SimTK::SpatialInertia_::transformInPlace" ref="a730a21dc374eb7f7e5b230829c34ad32" args="(const InverseTransform_&lt; P &gt; &amp;X_FB)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a70ed68773d8508b66b575860a6b8c7d1">transformInPlace</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform using an inverse transform to avoid having to convert it. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>transformInPlace(Transform) for information </dd></dl>

</div>
</div>
<a class="anchor" id="a461a0f13fb5b50e970416b0781d4631d"></a><!-- doxytag: member="SimTK::SpatialInertia_::toSpatialMat" ref="a461a0f13fb5b50e970416b0781d4631d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Mat.html">SpatialMatP</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html#a461a0f13fb5b50e970416b0781d4631d">toSpatialMat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aa8fbbb1b76326c2960f89c3cc17256e3"></a><!-- doxytag: member="SimTK::SpatialInertia_::operator+" ref="aa8fbbb1b76326c2960f89c3cc17256e3" args="(const SpatialInertia_&lt; P &gt; &amp;l, const SpatialInertia_&lt; P &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two compatible spatial inertias. </p>
<p>Cost is about 40 flops. </p>

</div>
</div>
<a class="anchor" id="a28bcef8b2f22a45c06652f13976e1eec"></a><!-- doxytag: member="SimTK::SpatialInertia_::operator&#45;" ref="a28bcef8b2f22a45c06652f13976e1eec" args="(const SpatialInertia_&lt; P &gt; &amp;l, const SpatialInertia_&lt; P &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract one compatible spatial inertia from another. </p>
<p>Cost is about 40 flops. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MassProperties_8h_source.html">MassProperties.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a>      </li>
      <li class="navelem"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>      </li>

    <li class="footer">Generated on Wed Oct 9 2013 08:38:59 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
