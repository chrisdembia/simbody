<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Simbody: Array.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.4 (development)</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('Array_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Array.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="Array_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef SimTK_SimTKCOMMON_ARRAY_H_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define SimTK_SimTKCOMMON_ARRAY_H_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* -------------------------------------------------------------------------- *</span>
<a name="l00005"></a>00005 <span class="comment"> *                       Simbody(tm): SimTKcommon                             *</span>
<a name="l00006"></a>00006 <span class="comment"> * -------------------------------------------------------------------------- *</span>
<a name="l00007"></a>00007 <span class="comment"> * This is part of the SimTK biosimulation toolkit originating from           *</span>
<a name="l00008"></a>00008 <span class="comment"> * Simbios, the NIH National Center for Physics-Based Simulation of           *</span>
<a name="l00009"></a>00009 <span class="comment"> * Biological Structures at Stanford, funded under the NIH Roadmap for        *</span>
<a name="l00010"></a>00010 <span class="comment"> * Medical Research, grant U54 GM072970. See https://simtk.org/home/simbody.  *</span>
<a name="l00011"></a>00011 <span class="comment"> *                                                                            *</span>
<a name="l00012"></a>00012 <span class="comment"> * Portions copyright (c) 2010-13 Stanford University and the Authors.        *</span>
<a name="l00013"></a>00013 <span class="comment"> * Authors: Michael Sherman                                                   *</span>
<a name="l00014"></a>00014 <span class="comment"> * Contributors:                                                              *</span>
<a name="l00015"></a>00015 <span class="comment"> *                                                                            *</span>
<a name="l00016"></a>00016 <span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may    *</span>
<a name="l00017"></a>00017 <span class="comment"> * not use this file except in compliance with the License. You may obtain a  *</span>
<a name="l00018"></a>00018 <span class="comment"> * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *</span>
<a name="l00019"></a>00019 <span class="comment"> *                                                                            *</span>
<a name="l00020"></a>00020 <span class="comment"> * Unless required by applicable law or agreed to in writing, software        *</span>
<a name="l00021"></a>00021 <span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,          *</span>
<a name="l00022"></a>00022 <span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *</span>
<a name="l00023"></a>00023 <span class="comment"> * See the License for the specific language governing permissions and        *</span>
<a name="l00024"></a>00024 <span class="comment"> * limitations under the License.                                             *</span>
<a name="l00025"></a>00025 <span class="comment"> * -------------------------------------------------------------------------- */</span>
<a name="l00026"></a>00026 
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h.html" title="Mandatory first inclusion for any Simbody source or header file.">SimTKcommon/internal/common.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="ExceptionMacros_8h.html" title="This file contains macros which are convenient to use for sprinkling error checking around liberally ...">SimTKcommon/internal/ExceptionMacros.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="Serialize_8h.html" title="This file contains definitions of templatized serialize-to-stream methods specialized for the built-i...">SimTKcommon/internal/Serialize.h</a>&quot;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;ostream&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;climits&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">namespace </span>SimTK {
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">// These are the classes defined in this header.</span>
<a name="l00047"></a>00047 <span class="keyword">template</span> &lt;<span class="keyword">class</span> X&gt;                   <span class="keyword">struct </span>ArrayIndexTraits;
<a name="l00048"></a>00048 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X=<span class="keywordtype">unsigned</span>&gt; <span class="keyword">class  </span>ArrayViewConst_;
<a name="l00049"></a>00049 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X=<span class="keywordtype">unsigned</span>&gt; <span class="keyword">class  </span>ArrayView_;
<a name="l00050"></a>00050 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X=<span class="keywordtype">unsigned</span>&gt; <span class="keyword">class  </span>Array_;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">//==============================================================================</span>
<a name="l00055"></a>00055 <span class="comment">//                           CLASS ArrayIndexTraits</span>
<a name="l00056"></a>00056 <span class="comment">//==============================================================================</span>
<a name="l00057"></a>00057 
<a name="l00100"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits.html">00100</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> X&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a> {
<a name="l00103"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a8a52ff7e685e2a6fa1d715475fbffa12">00103</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> X::size_type       <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a8a52ff7e685e2a6fa1d715475fbffa12" title="The signed or unsigned integral type to which an object of index type X can be converted without prod...">size_type</a>;
<a name="l00106"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a3f2218d2538016278c51f8f9d8be5dc9">00106</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> X::difference_type <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a3f2218d2538016278c51f8f9d8be5dc9" title="A signed integral type large enough to hold the full range of possible signed differences i-j between...">difference_type</a>;
<a name="l00109"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a005352314ba62448f8710051b705a058">00109</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a8a52ff7e685e2a6fa1d715475fbffa12" title="The signed or unsigned integral type to which an object of index type X can be converted without prod...">size_type</a> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a005352314ba62448f8710051b705a058" title="The maximum allowable size for any Array_&lt;T,X&gt; that uses this type X as its index type...">max_size</a>() {<span class="keywordflow">return</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a005352314ba62448f8710051b705a058" title="The maximum allowable size for any Array_&lt;T,X&gt; that uses this type X as its index type...">X::max_size</a>();}
<a name="l00110"></a>00110 };
<a name="l00111"></a>00111 
<a name="l00114"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01_4.html">00114</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;unsigned&gt; {
<a name="l00115"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01_4.html#a237891bd7f929131cd54a075aef041f3">00115</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span>        <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01_4.html#a237891bd7f929131cd54a075aef041f3">size_type</a>;
<a name="l00116"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01_4.html#a92755f7b8f71d7f788ac3b3892c99a0d">00116</a>     <span class="keyword">typedef</span> <span class="keywordtype">int</span>             <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01_4.html#a92755f7b8f71d7f788ac3b3892c99a0d">difference_type</a>;
<a name="l00117"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01_4.html#a11132e679112ee1777cd4fab980b341d">00117</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01_4.html#a237891bd7f929131cd54a075aef041f3">size_type</a>        <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01_4.html#a11132e679112ee1777cd4fab980b341d">max_size</a>() {<span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>)INT_MAX;}
<a name="l00118"></a>00118 };
<a name="l00119"></a>00119 
<a name="l00121"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01int_01_4.html">00121</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;int&gt; {
<a name="l00122"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01int_01_4.html#afde47749cdf6e194508e9234407ad5d8">00122</a>     <span class="keyword">typedef</span> <span class="keywordtype">int</span>             <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01int_01_4.html#afde47749cdf6e194508e9234407ad5d8">size_type</a>;
<a name="l00123"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01int_01_4.html#a0cbfd69e41b78ac4d0e9a67004c8c4fb">00123</a>     <span class="keyword">typedef</span> <span class="keywordtype">int</span>             <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01int_01_4.html#a0cbfd69e41b78ac4d0e9a67004c8c4fb">difference_type</a>;
<a name="l00124"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01int_01_4.html#a7a3a13b354bac114584e1a02a82ace3d">00124</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01int_01_4.html#afde47749cdf6e194508e9234407ad5d8">size_type</a>        <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01int_01_4.html#a7a3a13b354bac114584e1a02a82ace3d">max_size</a>() {<span class="keywordflow">return</span> INT_MAX;}
<a name="l00125"></a>00125 };
<a name="l00126"></a>00126 
<a name="l00134"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01_4.html">00134</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;unsigned long&gt; {
<a name="l00135"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01_4.html#aa0c86d06bfbdcd8262d179c0c662fe62">00135</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>       <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01_4.html#aa0c86d06bfbdcd8262d179c0c662fe62">size_type</a>;
<a name="l00136"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01_4.html#aa36691c69e90e74446a61ded3eb5b723">00136</a>     <span class="keyword">typedef</span> <span class="keywordtype">long</span>                <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01_4.html#aa36691c69e90e74446a61ded3eb5b723">difference_type</a>;
<a name="l00137"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01_4.html#ac5dc6c1139a80228c95f508dd7ecf163">00137</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01_4.html#aa0c86d06bfbdcd8262d179c0c662fe62">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01_4.html#ac5dc6c1139a80228c95f508dd7ecf163">max_size</a>() {<span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)LONG_MAX;}
<a name="l00138"></a>00138 };
<a name="l00139"></a>00139 
<a name="l00147"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01_4.html">00147</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;long&gt; {
<a name="l00148"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01_4.html#a4de344582b66ebf7bef70bb5a9da9277">00148</a>     <span class="keyword">typedef</span> <span class="keywordtype">long</span>                <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01_4.html#a4de344582b66ebf7bef70bb5a9da9277">size_type</a>;
<a name="l00149"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01_4.html#aaada77b6f4e48fe9ee121c9c4e1caaeb">00149</a>     <span class="keyword">typedef</span> <span class="keywordtype">long</span>                <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01_4.html#aaada77b6f4e48fe9ee121c9c4e1caaeb">difference_type</a>;
<a name="l00150"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01_4.html#ae44d787df4a5ba666f43d194c0215704">00150</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01_4.html#a4de344582b66ebf7bef70bb5a9da9277">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01_4.html#ae44d787df4a5ba666f43d194c0215704">max_size</a>() {<span class="keywordflow">return</span> LONG_MAX;}
<a name="l00151"></a>00151 };
<a name="l00152"></a>00152 
<a name="l00158"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01short_01_4.html">00158</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;unsigned short&gt; {
<a name="l00159"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01short_01_4.html#a71dce75055a49d2cbf54dd1de777edb9">00159</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>      <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01short_01_4.html#a71dce75055a49d2cbf54dd1de777edb9">size_type</a>;
<a name="l00160"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01short_01_4.html#a58a32c3e4253c940c99aa014e798a00f">00160</a>     <span class="keyword">typedef</span> <span class="keywordtype">int</span>                 <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01short_01_4.html#a58a32c3e4253c940c99aa014e798a00f">difference_type</a>;
<a name="l00161"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01short_01_4.html#acf6192072469dca3780b721cc4a981f7">00161</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01short_01_4.html#a71dce75055a49d2cbf54dd1de777edb9">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01short_01_4.html#acf6192072469dca3780b721cc4a981f7">max_size</a>() {<span class="keywordflow">return</span> USHRT_MAX;}
<a name="l00162"></a>00162 };
<a name="l00163"></a>00163 
<a name="l00168"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01short_01_4.html">00168</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;short&gt; {
<a name="l00169"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01short_01_4.html#a77dd0e0f74deef3d4eca9254f1ae6017">00169</a>     <span class="keyword">typedef</span> <span class="keywordtype">short</span>               <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01short_01_4.html#a77dd0e0f74deef3d4eca9254f1ae6017">size_type</a>;
<a name="l00170"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01short_01_4.html#af0295eaf3ca3d79193ea696968850f51">00170</a>     <span class="keyword">typedef</span> <span class="keywordtype">short</span>               <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01short_01_4.html#af0295eaf3ca3d79193ea696968850f51">difference_type</a>;
<a name="l00171"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01short_01_4.html#afab77af3b16dd9977ab409fd2601bfe3">00171</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01short_01_4.html#a77dd0e0f74deef3d4eca9254f1ae6017">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01short_01_4.html#afab77af3b16dd9977ab409fd2601bfe3">max_size</a>() {<span class="keywordflow">return</span> SHRT_MAX;}
<a name="l00172"></a>00172 }; 
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00179"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01char_01_4.html">00179</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;unsigned char&gt; {
<a name="l00180"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01char_01_4.html#a17285dc617d4731b7f729a37e4de61d1">00180</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>       <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01char_01_4.html#a17285dc617d4731b7f729a37e4de61d1">size_type</a>;
<a name="l00181"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01char_01_4.html#a06d96a9443666f4f12e86e9042a35a7b">00181</a>     <span class="keyword">typedef</span> <span class="keywordtype">short</span>               <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01char_01_4.html#a06d96a9443666f4f12e86e9042a35a7b">difference_type</a>;
<a name="l00182"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01char_01_4.html#a2e135768b603bf3f9507407311ec03fc">00182</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01char_01_4.html#a17285dc617d4731b7f729a37e4de61d1">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01char_01_4.html#a2e135768b603bf3f9507407311ec03fc">max_size</a>() {<span class="keywordflow">return</span> UCHAR_MAX;} <span class="comment">// not CHAR_MAX</span>
<a name="l00183"></a>00183 };
<a name="l00184"></a>00184 
<a name="l00190"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01signed_01char_01_4.html">00190</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;signed char&gt; {
<a name="l00191"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01signed_01char_01_4.html#a6c77303cfe1d36a8ca954c3933d98b9f">00191</a>     <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span>         <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01signed_01char_01_4.html#a6c77303cfe1d36a8ca954c3933d98b9f">size_type</a>;
<a name="l00192"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01signed_01char_01_4.html#a2aa8b8a5ffc69fb1acb1da5230b9df17">00192</a>     <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span>         <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01signed_01char_01_4.html#a2aa8b8a5ffc69fb1acb1da5230b9df17">difference_type</a>;
<a name="l00193"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01signed_01char_01_4.html#a1d80007656ae3873ba9680ef5e31da33">00193</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01signed_01char_01_4.html#a6c77303cfe1d36a8ca954c3933d98b9f">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01signed_01char_01_4.html#a1d80007656ae3873ba9680ef5e31da33">max_size</a>() {<span class="keywordflow">return</span> SCHAR_MAX;}
<a name="l00194"></a>00194 };
<a name="l00195"></a>00195 
<a name="l00202"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01char_01_4.html">00202</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;char&gt; {
<a name="l00203"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01char_01_4.html#a3359cb6a136351f8ce61b747abc4c20f">00203</a>     <span class="keyword">typedef</span> <span class="keywordtype">char</span>                <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01char_01_4.html#a3359cb6a136351f8ce61b747abc4c20f">size_type</a>;
<a name="l00204"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01char_01_4.html#a0f6455f10953fda1f7cb4a6261b01dbc">00204</a>     <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span>         <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01char_01_4.html#a0f6455f10953fda1f7cb4a6261b01dbc">difference_type</a>;
<a name="l00205"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01char_01_4.html#a34ab3f60b213b95502557342008a5333">00205</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01char_01_4.html#a3359cb6a136351f8ce61b747abc4c20f">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01char_01_4.html#a34ab3f60b213b95502557342008a5333">max_size</a>() {<span class="keywordflow">return</span> (<span class="keywordtype">char</span>)SCHAR_MAX;}
<a name="l00206"></a>00206 };
<a name="l00207"></a>00207 
<a name="l00213"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01bool_01_4.html">00213</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;bool&gt; {
<a name="l00214"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01bool_01_4.html#ae07264e17c0084344c53066c39c31b2a">00214</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>       <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01bool_01_4.html#ae07264e17c0084344c53066c39c31b2a">size_type</a>;
<a name="l00215"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01bool_01_4.html#a74fd1c12aa1b5357e7dc30d263c2aa4b">00215</a>     <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span>         <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01bool_01_4.html#a74fd1c12aa1b5357e7dc30d263c2aa4b">difference_type</a>;
<a name="l00216"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01bool_01_4.html#ad08329b074a87b01bcc8c17cdfc4425e">00216</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01bool_01_4.html#ae07264e17c0084344c53066c39c31b2a">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01bool_01_4.html#ad08329b074a87b01bcc8c17cdfc4425e">max_size</a>() {<span class="keywordflow">return</span> 2;}
<a name="l00217"></a>00217 };
<a name="l00218"></a>00218 
<a name="l00221"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01long_01_4.html">00221</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;unsigned long long&gt; {
<a name="l00222"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01long_01_4.html#a7b602db6607df96209684528695772d9">00222</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>  <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01long_01_4.html#a7b602db6607df96209684528695772d9">size_type</a>;
<a name="l00223"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01long_01_4.html#a24047fa1c0e3058c2b62f5019893f372">00223</a>     <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>           <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01long_01_4.html#a24047fa1c0e3058c2b62f5019893f372">difference_type</a>;
<a name="l00224"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01long_01_4.html#aa78755a0eb5e94e59e4cb17330f97bc3">00224</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01unsigned_01long_01long_01_4.html#a7b602db6607df96209684528695772d9">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a005352314ba62448f8710051b705a058" title="The maximum allowable size for any Array_&lt;T,X&gt; that uses this type X as its index type...">max_size</a>() 
<a name="l00225"></a>00225                                     {<span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)LLONG_MAX;}
<a name="l00226"></a>00226 };
<a name="l00227"></a>00227 
<a name="l00230"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01long_01_4.html">00230</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>&lt;long long&gt; {
<a name="l00231"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01long_01_4.html#a63463de30930d8e0eb4b06090f040565">00231</a>     <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>           <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01long_01_4.html#a63463de30930d8e0eb4b06090f040565">size_type</a>;
<a name="l00232"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01long_01_4.html#a3e50f35657d6bafe0a4560ffbc96d004">00232</a>     <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>           <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01long_01_4.html#a3e50f35657d6bafe0a4560ffbc96d004">difference_type</a>;
<a name="l00233"></a><a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01long_01_4.html#a63eb3c3105e144e7ba26623dd7bfac93">00233</a>     <span class="keyword">static</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01long_01_4.html#a63463de30930d8e0eb4b06090f040565">size_type</a>            <a class="code" href="structSimTK_1_1ArrayIndexTraits_3_01long_01long_01_4.html#a63eb3c3105e144e7ba26623dd7bfac93">max_size</a>() {<span class="keywordflow">return</span> LLONG_MAX;}
<a name="l00234"></a>00234 };
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="comment">// Don&#39;t show this in Doxygen.</span>
<a name="l00238"></a>00238 <span class="comment"></span><span class="comment">// This helper class decides what integral type we should use to best pack</span>
<a name="l00239"></a>00239 <span class="comment">// the index type&#39;s size_type representation. The idea is to pack the whole</span>
<a name="l00240"></a>00240 <span class="comment">// Array_ structure into 8 bytes on a 32 bit machine, 16 bytes on a 64 bit</span>
<a name="l00241"></a>00241 <span class="comment">// machine, using the largest integral type that will work, giving a layout</span>
<a name="l00242"></a>00242 <span class="comment">// like this:          |       data pointer     |</span>
<a name="l00243"></a>00243 <span class="comment">//                     |   nUsed   | nAllocated |</span>
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="comment">// The default implementation just uses the integral type itself.</span>
<a name="l00246"></a>00246 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Integral, <span class="keyword">class</span> is64Bit&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper 
<a name="l00247"></a>00247 {   <span class="keyword">typedef</span> Integral packed_size_type;};
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="comment">// On 32 bit machine, pack anything smaller than a short into a short.</span>
<a name="l00250"></a>00250 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;bool,FalseType&gt; 
<a name="l00251"></a>00251 {   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> packed_size_type;};
<a name="l00252"></a>00252 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;char,FalseType&gt; 
<a name="l00253"></a>00253 {   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> packed_size_type;};
<a name="l00254"></a>00254 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;unsigned char,FalseType&gt; 
<a name="l00255"></a>00255 {   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> packed_size_type;};
<a name="l00256"></a>00256 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;signed char,FalseType&gt; 
<a name="l00257"></a>00257 {   <span class="keyword">typedef</span> <span class="keywordtype">short</span> packed_size_type;};
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="comment">// On 64 bit machine, pack anything smaller than an int into an int.</span>
<a name="l00260"></a>00260 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;bool,TrueType&gt; 
<a name="l00261"></a>00261 {   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packed_size_type;};
<a name="l00262"></a>00262 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;char,TrueType&gt; 
<a name="l00263"></a>00263 {   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packed_size_type;};
<a name="l00264"></a>00264 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;unsigned char,TrueType&gt; 
<a name="l00265"></a>00265 {   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packed_size_type;};
<a name="l00266"></a>00266 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;signed char,TrueType&gt; 
<a name="l00267"></a>00267 {   <span class="keyword">typedef</span> <span class="keywordtype">int</span> packed_size_type;};
<a name="l00268"></a>00268 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;unsigned short,TrueType&gt; 
<a name="l00269"></a>00269 {   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packed_size_type;};
<a name="l00270"></a>00270 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>ArrayIndexPackTypeHelper&lt;short,TrueType&gt; 
<a name="l00271"></a>00271 {   <span class="keyword">typedef</span> <span class="keywordtype">int</span> packed_size_type;};
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Integral&gt; <span class="keyword">struct </span>ArrayIndexPackType
<a name="l00274"></a>00274 {   <span class="keyword">typedef</span> <span class="keyword">typename</span> ArrayIndexPackTypeHelper&lt;Integral,Is64BitPlatformType&gt;
<a name="l00275"></a>00275                         ::packed_size_type  packed_size_type;};
<a name="l00283"></a>00283 <span class="comment">//==============================================================================</span>
<a name="l00284"></a>00284 <span class="comment">//                            CLASS ArrayViewConst_</span>
<a name="l00285"></a>00285 <span class="comment">//==============================================================================</span>
<a name="l00312"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html">00312</a> <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">class </span><a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> {
<a name="l00313"></a>00313 <span class="keyword">public</span>:
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00323"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">00323</a> <span class="comment"></span><span class="keyword">typedef</span> T           <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660" title="The type of object stored in this container.">value_type</a>;
<a name="l00325"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">00325</a> <span class="keyword">typedef</span> X           <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a>;
<a name="l00327"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">00327</a> <span class="keyword">typedef</span> T*          <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e" title="A writable pointer to a value_type.">pointer</a>;
<a name="l00329"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">00329</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T*    <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b" title="A const pointer to a value_type.">const_pointer</a>;
<a name="l00331"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">00331</a> <span class="keyword">typedef</span> T&amp;          <a class="code" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c" title="A writable value_type reference.">reference</a>;
<a name="l00333"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">00333</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;    <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a" title="A const value_type reference.">const_reference</a>;
<a name="l00335"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">00335</a> <span class="keyword">typedef</span> T*          <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23" title="A writable iterator for this container (same as pointer here).">iterator</a>;
<a name="l00337"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">00337</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T*    <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963" title="A const iterator for this container (same as const_pointer here).">const_iterator</a>;
<a name="l00339"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">00339</a> <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;                 <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce" title="A writable reverse iterator for this container.">reverse_iterator</a>;
<a name="l00341"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">00341</a> <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;           <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a>;
<a name="l00343"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">00343</a> <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a8a52ff7e685e2a6fa1d715475fbffa12" title="The signed or unsigned integral type to which an object of index type X can be converted without prod...">ArrayIndexTraits&lt;X&gt;::size_type</a>         <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a>;
<a name="l00346"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">00346</a> <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a3f2218d2538016278c51f8f9d8be5dc9" title="A signed integral type large enough to hold the full range of possible signed differences i-j between...">ArrayIndexTraits&lt;X&gt;::difference_type</a>   <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e" title="A signed integral type that can represent the difference between any two legitimate index values for ...">difference_type</a>;
<a name="l00348"></a>00348 <span class="keyword">typedef</span> <span class="keyword">typename</span> ArrayIndexPackType&lt;size_type&gt;::packed_size_type 
<a name="l00349"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">00349</a>                                                         <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>;
<a name="l00353"></a>00353 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00359"></a>00359 <span class="comment"></span>
<a name="l00361"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59">00361</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59" title="Default constructor allocates no heap space and is very fast.">ArrayViewConst_</a>() : pData(0), nUsed(0), nAllocated(0) {}
<a name="l00362"></a>00362 
<a name="l00372"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a5412fa0b837f5e090f343180b2dbcdc8">00372</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59" title="Default constructor allocates no heap space and is very fast.">ArrayViewConst_</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>&amp; src) 
<a name="l00373"></a>00373 :   pData(0), nUsed(src.nUsed), nAllocated(0) {
<a name="l00374"></a>00374     <span class="keywordflow">if</span> (nUsed) pData = <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(src.pData);
<a name="l00375"></a>00375 } 
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="comment">// Copy assignment is suppressed.</span>
<a name="l00378"></a>00378 
<a name="l00401"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#aba351ab4073da6f9d4c13855b039df6b">00401</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59" title="Default constructor allocates no heap space and is very fast.">ArrayViewConst_</a>(<span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last1) 
<a name="l00402"></a>00402 :   pData(0),nUsed(0),nAllocated(0) { 
<a name="l00403"></a>00403     <span class="keywordflow">if</span> (last1==first) <span class="keywordflow">return</span>; <span class="comment">// empty</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>((first&amp;&amp;last1)||(first==last1), 
<a name="l00406"></a>00406         <span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;(first,last1)&quot;</span>, 
<a name="l00407"></a>00407         <span class="stringliteral">&quot;One of the source pointers was null (0); either both must be&quot;</span>
<a name="l00408"></a>00408         <span class="stringliteral">&quot; non-null or both must be null.&quot;</span>);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(this-&gt;isSizeOK(last1-first), 
<a name="l00411"></a>00411         <span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;(first,last1)&quot;</span>,
<a name="l00412"></a>00412         <span class="stringliteral">&quot;The source data&#39;s size %llu is too big for this array which&quot;</span>
<a name="l00413"></a>00413         <span class="stringliteral">&quot; is limited to %llu elements by its index type %s.&quot;</span>,
<a name="l00414"></a>00414         this-&gt;ull(last1-first), ullMaxSize(), indexName());
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     pData = <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(first); 
<a name="l00417"></a>00417     nUsed = <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>(last1-first); 
<a name="l00418"></a>00418     <span class="comment">// nAllocated is already zero</span>
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
<a name="l00448"></a>00448 <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l00449"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#acbb823ad8bafa05dae5c1a06b426c4a8">00449</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59" title="Default constructor allocates no heap space and is very fast.">ArrayViewConst_</a>(<span class="keyword">const</span> std::vector&lt;T,A&gt;&amp; src) 
<a name="l00450"></a>00450 :   pData(0),nUsed(0),nAllocated(0) { 
<a name="l00451"></a>00451     <span class="keywordflow">if</span> (src.empty()) <span class="keywordflow">return</span>;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(this-&gt;isSizeOK(src.size()),
<a name="l00454"></a>00454         <span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;::ctor(std::vector&lt;T&gt;)&quot;</span>,
<a name="l00455"></a>00455         <span class="stringliteral">&quot;The source std::vector&#39;s size %llu is too big for this array which&quot;</span>
<a name="l00456"></a>00456         <span class="stringliteral">&quot; is limited to %llu elements by its index type %s.&quot;</span>,
<a name="l00457"></a>00457         this-&gt;ull(src.size()), ullMaxSize(), indexName());
<a name="l00458"></a>00458 
<a name="l00459"></a>00459     pData = <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(&amp;src.front()); 
<a name="l00460"></a>00460     nUsed = <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>(src.size()); 
<a name="l00461"></a>00461     <span class="comment">// nAllocated is already zero</span>
<a name="l00462"></a>00462 }
<a name="l00465"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a00cef62772e0c408bd3e0529417b8948">00465</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a00cef62772e0c408bd3e0529417b8948" title="This is an implicit conversion to const ArrayView_&lt;T,X&gt;&amp;, which is harmless since the const result ...">operator const ArrayView_&lt;T,X&gt;&amp;</a>()<span class="keyword"> const</span>
<a name="l00466"></a>00466 <span class="keyword"></span>{   <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T,X&gt;</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00469"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a306a0b84ff4f9dd8981c5a978e2750f5">00469</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a306a0b84ff4f9dd8981c5a978e2750f5" title="This is an implicit conversion to const Array_&lt;T,X&gt;&amp;, which is harmless since the const result can&#39;...">operator const Array_&lt;T,X&gt;&amp;</a>()<span class="keyword"> const</span>
<a name="l00470"></a>00470 <span class="keyword"></span>{   <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00471"></a>00471 
<a name="l00477"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643">00477</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect</a>() {
<a name="l00478"></a>00478     <a class="code" href="ExceptionMacros_8h.html#a58ccb1c936683d43f791f03b4f52845f">SimTK_ASSERT</a>(nAllocated==0,
<a name="l00479"></a>00479         <span class="stringliteral">&quot;ArrayViewConst_::deallocate(): called on an owner Array_&quot;</span>);
<a name="l00480"></a>00480     nUsed = 0;
<a name="l00481"></a>00481     pData = 0;
<a name="l00482"></a>00482 }
<a name="l00483"></a>00483 
<a name="l00486"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839">00486</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839" title="The destructor just disconnects the array view handle from its data; see disconnect() for more inform...">~ArrayViewConst_</a>() {
<a name="l00487"></a>00487     <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect</a>();
<a name="l00488"></a>00488 }
<a name="l00492"></a>00492 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00499"></a>00499 <span class="comment"></span>
<a name="l00501"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3">00501</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(nUsed);}
<a name="l00503"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea">00503</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea" title="Return the maximum allowable size for this array.">max_size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea" title="Return the maximum allowable size for this array.">ArrayIndexTraits&lt;X&gt;::max_size</a>();}
<a name="l00506"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c">00506</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c" title="Return true if there are no elements currently stored in this array.">empty</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> nUsed==0;}
<a name="l00511"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f">00511</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(nAllocated?nAllocated:nUsed);}
<a name="l00515"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3c1c27ea8ca7b9f3411d438693fd8a2a">00515</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3c1c27ea8ca7b9f3411d438693fd8a2a" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(nAllocated);}
<a name="l00521"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a30c40081730e9681d6102972f42904f1">00521</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a30c40081730e9681d6102972f42904f1" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> nAllocated || pData==0;}
<a name="l00522"></a>00522 <span class="comment">/*}*/</span>
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00532"></a>00532 <span class="comment"></span>
<a name="l00539"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#afa06a13341105ac7773a9c6bcd6a851c">00539</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayViewConst__.html#afa06a13341105ac7773a9c6bcd6a851c" title="Select an element by its index, returning a const reference.">operator[]</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{
<a name="l00540"></a>00540     <a class="code" href="ExceptionMacros_8h.html#a08ad120f4789e305ecb734e01c0f66f5">SimTK_INDEXCHECK</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(i),<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">size</a>(),<span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;::operator[]()&quot;</span>);
<a name="l00541"></a>00541     <span class="keywordflow">return</span> pData[i];
<a name="l00542"></a>00542 }
<a name="l00547"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b5d31ec735550ba4b262b8e5f387020">00547</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b5d31ec735550ba4b262b8e5f387020" title="Same as operator[] but always range-checked, even in a Release build.">at</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{
<a name="l00548"></a>00548     <a class="code" href="ExceptionMacros_8h.html#a3dd90b0a70e47be10dbe6b753615e658">SimTK_INDEXCHECK_ALWAYS</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(i),<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">size</a>(),<span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;::at()&quot;</span>);
<a name="l00549"></a>00549     <span class="keywordflow">return</span> pData[i];
<a name="l00550"></a>00550 }
<a name="l00553"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a2af8a30f98edabfef434169ac33831e2">00553</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a2af8a30f98edabfef434169ac33831e2" title="Same as the const form of operator[]; exists to provide a non-operator method for element access in c...">getElt</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{
<a name="l00554"></a>00554     <a class="code" href="ExceptionMacros_8h.html#a08ad120f4789e305ecb734e01c0f66f5">SimTK_INDEXCHECK</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(i),<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">size</a>(),<span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;::getElt()&quot;</span>);
<a name="l00555"></a>00555     <span class="keywordflow">return</span> pData[i];
<a name="l00556"></a>00556 }
<a name="l00562"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554">00562</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554" title="Return a const reference to the first element in this array, which must not be empty (we&#39;ll check in ...">front</a>()<span class="keyword"> const </span>
<a name="l00563"></a>00563 <span class="keyword"></span>{   <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(!<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c" title="Return true if there are no elements currently stored in this array.">empty</a>(), <span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;::front()&quot;</span>, <span class="stringliteral">&quot;Array was empty.&quot;</span>);
<a name="l00564"></a>00564     <span class="keywordflow">return</span> pData[0]; }
<a name="l00570"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a26683b980dcd87bafd5c6446d8f8b25b">00570</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a26683b980dcd87bafd5c6446d8f8b25b" title="Return a const reference to the last element in this array, which must not be empty (we&#39;ll check in a...">back</a>()<span class="keyword"> const </span>
<a name="l00571"></a>00571 <span class="keyword"></span>{   <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(!<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c" title="Return true if there are no elements currently stored in this array.">empty</a>(), <span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;::back()&quot;</span>, <span class="stringliteral">&quot;Array was empty.&quot;</span>);
<a name="l00572"></a>00572     <span class="keywordflow">return</span> pData[nUsed-1]; }
<a name="l00573"></a>00573 
<a name="l00592"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab1816a17c6b643eb0967f954cdd96635">00592</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab1816a17c6b643eb0967f954cdd96635" title="Select a contiguous subarray of the elements of this array and create another ArrayViewConst_ that re...">operator()</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> index, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> length)<span class="keyword"> const </span>{
<a name="l00593"></a>00593     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> ix(index);
<a name="l00594"></a>00594     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(isSizeInRange(ix, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">size</a>()), <span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;(index,length)&quot;</span>,
<a name="l00595"></a>00595         <span class="stringliteral">&quot;For this operator, we must have 0 &lt;= index &lt;= size(), but&quot;</span>
<a name="l00596"></a>00596         <span class="stringliteral">&quot; index==%llu and size==%llu.&quot;</span>, this-&gt;ull(ix), ullSize());
<a name="l00597"></a>00597     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(isSizeInRange(length, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">size</a>()-ix)), 
<a name="l00598"></a>00598         <span class="stringliteral">&quot;ArrayViewConst_&lt;T&gt;(index,length)&quot;</span>, 
<a name="l00599"></a>00599         <span class="stringliteral">&quot;This operator requires 0 &lt;= length &lt;= size()-index, but&quot;</span>
<a name="l00600"></a>00600         <span class="stringliteral">&quot; length==%llu and size()-index==%llu.&quot;</span>,this-&gt;ull(length),this-&gt;ull(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">size</a>()-ix));
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59" title="Default constructor allocates no heap space and is very fast.">ArrayViewConst_</a>(pData+ix, pData+ix+length);
<a name="l00603"></a>00603 }
<a name="l00606"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a288833be443e0f02d958f5cfe74312ba">00606</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a288833be443e0f02d958f5cfe74312ba" title="Same as const form of operator()(index,length); exists to provide non-operator access to that functio...">getSubArray</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> index, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> length)<span class="keyword"> const</span>
<a name="l00607"></a>00607 <span class="keyword"></span>{   <span class="keywordflow">return</span> (*<span class="keyword">this</span>)(index,length); }
<a name="l00608"></a>00608 
<a name="l00612"></a>00612 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00621"></a>00621 <span class="comment"></span>
<a name="l00626"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b">00626</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">cbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> pData;}
<a name="l00631"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4">00631</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> pData + nUsed;}
<a name="l00633"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108">00633</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin().">begin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> pData;}
<a name="l00635"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8">00635</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend().">end</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> pData + nUsed;}
<a name="l00636"></a>00636 
<a name="l00639"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824">00639</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>());}
<a name="l00643"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b">00643</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">cbegin</a>());}
<a name="l00645"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256">00645</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256" title="The const version of rbegin() is the same as crbegin().">rbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin</a>();} 
<a name="l00647"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c">00647</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c" title="The const version of rend() is the same as crend().">rend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend</a>();}
<a name="l00648"></a>00648 
<a name="l00655"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388">00655</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> pData;}
<a name="l00657"></a><a class="code" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d">00657</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d" title="The const version of the data() method is identical to cdata().">data</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> pData;}
<a name="l00661"></a>00661 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00662"></a>00662                                  <span class="keyword">protected</span>:
<a name="l00663"></a>00663 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00664"></a>00664 <span class="comment">// The remainder of this class is for the use of the ArrayView_&lt;T,X&gt; and</span>
<a name="l00665"></a>00665 <span class="comment">// Array_&lt;T,X&gt; derived classes only and should not be documented for users to </span>
<a name="l00666"></a>00666 <span class="comment">// see. </span>
<a name="l00667"></a>00667                                      
<a name="l00668"></a>00668 <span class="comment">// Don&#39;t let doxygen see any of this.</span>
<a name="l00670"></a>00670 <span class="comment"></span><a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a> psize()<span class="keyword"> const </span>{<span class="keywordflow">return</span> nUsed;}
<a name="l00671"></a>00671 <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a> pallocated()<span class="keyword"> const </span>{<span class="keywordflow">return</span> nAllocated;}
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="comment">// These provide direct access to the data members for our trusted friends.</span>
<a name="l00674"></a>00674 <span class="keywordtype">void</span> setData(<span class="keyword">const</span> T* p)        {pData = <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(p);}
<a name="l00675"></a>00675 <span class="keywordtype">void</span> setSize(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n)       {nUsed = <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>(n);}
<a name="l00676"></a>00676 <span class="keywordtype">void</span> incrSize()                 {++nUsed;}
<a name="l00677"></a>00677 <span class="keywordtype">void</span> decrSize()                 {--nUsed;}
<a name="l00678"></a>00678 <span class="keywordtype">void</span> setAllocated(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n)  {nAllocated = <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>(n);}
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="comment">// Check whether a given size is the same as the current size of this array,</span>
<a name="l00681"></a>00681 <span class="comment">// avoiding any compiler warnings due to mismatched integral types.</span>
<a name="l00682"></a>00682 <span class="keyword">template</span> &lt;<span class="keyword">class</span> S&gt; 
<a name="l00683"></a>00683 <span class="keywordtype">bool</span> isSameSize(S sz)<span class="keyword"> const</span>
<a name="l00684"></a>00684 <span class="keyword"></span>{   <span class="keywordflow">return</span> ull(sz) == ullSize(); }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="comment">// Check that a source object&#39;s size will fit in the array being careful to</span>
<a name="l00687"></a>00687 <span class="comment">// avoid overflow and warnings in the comparison.</span>
<a name="l00688"></a>00688 <span class="keyword">template</span> &lt;<span class="keyword">class</span> S&gt; 
<a name="l00689"></a>00689 <span class="keywordtype">bool</span> isSizeOK(S srcSz)<span class="keyword"> const</span>
<a name="l00690"></a>00690 <span class="keyword"></span>{   <span class="keywordflow">return</span> ull(srcSz) &lt;= ullMaxSize(); }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="comment">// This is identical in function to std::distance() (reports how many </span>
<a name="l00693"></a>00693 <span class="comment">// elements lie between two iterators) but avoids any slow </span>
<a name="l00694"></a>00694 <span class="comment">// Release-build bugcatchers that Microsoft may have felt compelled to add.</span>
<a name="l00695"></a>00695 <span class="comment">// The implementation is specialized for random access iterators because</span>
<a name="l00696"></a>00696 <span class="comment">// they can measure distance very fast.</span>
<a name="l00697"></a>00697 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iter&gt; <span class="keyword">static</span>
<a name="l00698"></a>00698 <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::difference_type
<a name="l00699"></a>00699 iterDistance(<span class="keyword">const</span> Iter&amp; first, <span class="keyword">const</span> Iter&amp; last1) {
<a name="l00700"></a>00700     <span class="keywordflow">return</span> iterDistanceImpl(first,last1,
<a name="l00701"></a>00701                 <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::iterator_category());
<a name="l00702"></a>00702 }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 <span class="comment">// Generic slow implementation for non-random access iterators. This is fine</span>
<a name="l00705"></a>00705 <span class="comment">// for forward and bidirectional iterators, but it will *consume* input</span>
<a name="l00706"></a>00706 <span class="comment">// iterators so is useless for them.</span>
<a name="l00707"></a>00707 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iter&gt; <span class="keyword">static</span>
<a name="l00708"></a>00708 <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::difference_type
<a name="l00709"></a>00709 iterDistanceImpl(<span class="keyword">const</span> Iter&amp; first, <span class="keyword">const</span> Iter&amp; last1, std::input_iterator_tag) {
<a name="l00710"></a>00710     <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::difference_type d = 0;
<a name="l00711"></a>00711     <span class="keywordflow">for</span> (Iter src=first; src != last1; ++src, ++d)
<a name="l00712"></a>00712         ;
<a name="l00713"></a>00713     <span class="keywordflow">return</span> d;
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="comment">// Fast specialization for random access iterators (including ordinary</span>
<a name="l00717"></a>00717 <span class="comment">// pointers) -- just subtract.</span>
<a name="l00718"></a>00718 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iter&gt; <span class="keyword">static</span>
<a name="l00719"></a>00719 <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::difference_type
<a name="l00720"></a>00720 iterDistanceImpl(<span class="keyword">const</span> Iter&amp; first, <span class="keyword">const</span> Iter&amp; last1, 
<a name="l00721"></a>00721                  std::random_access_iterator_tag) {
<a name="l00722"></a>00722     <span class="keywordflow">return</span> last1 - first;
<a name="l00723"></a>00723 }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 <span class="comment">// This method attempts to determine whether any elements in the iterator range</span>
<a name="l00726"></a>00726 <span class="comment">// [first,last1) overlap with the elements stored in this array. This is used </span>
<a name="l00727"></a>00727 <span class="comment">// for error checks for operations where source is not permitted to overlap the</span>
<a name="l00728"></a>00728 <span class="comment">// destination. For random access iterators (including ordinary pointers), we </span>
<a name="l00729"></a>00729 <span class="comment">// can answer this question definitively because we expect the data to be </span>
<a name="l00730"></a>00730 <span class="comment">// consecutive in memory. For other kinds of iterators, we will just assume</span>
<a name="l00731"></a>00731 <span class="comment">// there is no overlap. Note that null ranges do not overlap even if the</span>
<a name="l00732"></a>00732 <span class="comment">// pair of equal iterators points within the other range -- what matters is</span>
<a name="l00733"></a>00733 <span class="comment">// the number of overlapping elements.</span>
<a name="l00734"></a>00734 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iter&gt; <span class="keywordtype">bool</span>
<a name="l00735"></a>00735 overlapsWithData(<span class="keyword">const</span> Iter&amp; first, <span class="keyword">const</span> Iter&amp; last1) {
<a name="l00736"></a>00736     <span class="keywordflow">return</span> overlapsWithDataImpl(first,last1,
<a name="l00737"></a>00737                 <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::iterator_category());
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 <span class="comment">// This is a partial specialization of the above where the data is given</span>
<a name="l00741"></a>00741 <span class="comment">// with ordinary pointers.</span>
<a name="l00742"></a>00742 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt; <span class="keywordtype">bool</span>
<a name="l00743"></a>00743 overlapsWithData(<span class="keyword">const</span> T2* first, <span class="keyword">const</span> T2* last1) {
<a name="l00744"></a>00744     <span class="comment">// Find the start and end+1 of the alleged overlap region. There is</span>
<a name="l00745"></a>00745     <span class="comment">// overlap iff end+1 &gt; start. Note that this works if either range </span>
<a name="l00746"></a>00746     <span class="comment">// is [0,0) or [p,p), or if last1 is illegally less than first (we just</span>
<a name="l00747"></a>00747     <span class="comment">// want to report no overlap in that case -- it is someone else&#39;s business</span>
<a name="l00748"></a>00748     <span class="comment">// to complain).</span>
<a name="l00749"></a>00749     <span class="keyword">const</span> T* obegin = <a class="code" href="namespaceSimTK.html#a5e54f17d86aeb08126d641bea4ba6f86">std::max</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">cbegin</a>(), (<span class="keyword">const</span> T*)first);
<a name="l00750"></a>00750     <span class="keyword">const</span> T* oend1  = <a class="code" href="namespaceSimTK.html#a6c0a4de5068fb7373703f25a368760da">std::min</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>(),   (<span class="keyword">const</span> T*)last1);
<a name="l00751"></a>00751 
<a name="l00752"></a>00752     <span class="keywordflow">return</span> obegin &lt; oend1;
<a name="l00753"></a>00753 }
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 <span class="comment">// This is the generic implementation for any type of input iterator other than</span>
<a name="l00756"></a>00756 <span class="comment">// random access (i.e., bidirectional, forward, or input) -- assume no overlap.</span>
<a name="l00757"></a>00757 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iter&gt; <span class="keywordtype">bool</span>
<a name="l00758"></a>00758 overlapsWithDataImpl(<span class="keyword">const</span> Iter&amp;, <span class="keyword">const</span> Iter&amp;, std::input_iterator_tag) 
<a name="l00759"></a>00759 {   <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 <span class="comment">// Here we can actually test for overlap since we have random access iterators.</span>
<a name="l00762"></a>00762 <span class="comment">// We convert them to pointers and then look for memory overlap.</span>
<a name="l00763"></a>00763 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iter&gt; <span class="keywordtype">bool</span>
<a name="l00764"></a>00764 overlapsWithDataImpl(<span class="keyword">const</span> Iter&amp; first, <span class="keyword">const</span> Iter&amp; last1, 
<a name="l00765"></a>00765                      std::random_access_iterator_tag) {
<a name="l00766"></a>00766     <span class="comment">// We must check that the input iterators span a non-zero range before</span>
<a name="l00767"></a>00767     <span class="comment">// assuming we can dereference them.</span>
<a name="l00768"></a>00768     <span class="keywordflow">if</span> (last1 &lt;= first)
<a name="l00769"></a>00769         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// zero or malformed source range: no overlap</span>
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     <span class="comment">// We now know we can dereference first and last1-1 (can&#39;t safely </span>
<a name="l00772"></a>00772     <span class="comment">// dereference last1 but we can use pointer arithmetic to point past</span>
<a name="l00773"></a>00773     <span class="comment">// the (last-1)th element in memory). We then take the dereferenced</span>
<a name="l00774"></a>00774     <span class="comment">// object&#39;s address to get ordinary pointers that we can use to </span>
<a name="l00775"></a>00775     <span class="comment">// watch for illegal overlap.</span>
<a name="l00776"></a>00776     <span class="keywordflow">return</span> overlapsWithData(&amp;*first, &amp;*(last1-1)); <span class="comment">// use pointer overload</span>
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="comment">// Cast an integral type to maximal-width unsigned long long to avoid accidental</span>
<a name="l00780"></a>00780 <span class="comment">// overflows that might otherwise occur due to wraparound that can happen </span>
<a name="l00781"></a>00781 <span class="comment">// with small index types.</span>
<a name="l00782"></a>00782 <span class="keyword">template</span> &lt;<span class="keyword">class</span> S&gt;
<a name="l00783"></a>00783 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ull(S sz)
<a name="l00784"></a>00784 {   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)sz; }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="comment">// Return size(), capacity(), and max_size() cast to unsigned long long.</span>
<a name="l00787"></a>00787 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullSize()<span class="keyword">     const </span>{<span class="keywordflow">return</span> ull(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">size</a>());}
<a name="l00788"></a>00788 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullCapacity()<span class="keyword"> const </span>{<span class="keywordflow">return</span> ull(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>());}
<a name="l00789"></a>00789 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullMaxSize()<span class="keyword">  const </span>{<span class="keywordflow">return</span> ull(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea" title="Return the maximum allowable size for this array.">max_size</a>());}
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 <span class="comment">// Useful in error messages for explaining why something was too big.</span>
<a name="l00792"></a>00792 <span class="keyword">const</span> <span class="keywordtype">char</span>* indexName()<span class="keyword"> const </span>{<span class="keywordflow">return</span> NiceTypeName&lt;X&gt;::name();}
<a name="l00793"></a>00793 
<a name="l00796"></a>00796 <span class="keyword">private</span>:
<a name="l00797"></a>00797 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00798"></a>00798 <span class="comment">//                               DATA MEMBERS</span>
<a name="l00799"></a>00799 <span class="comment">// These are the only data members and this layout is guaranteed not to change</span>
<a name="l00800"></a>00800 <span class="comment">// from release to release. If data is null, then nUsed==nAllocated==0.</span>
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 T*                  pData;      <span class="comment">// ptr to data referenced here, or 0 if none</span>
<a name="l00803"></a>00803 <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>    nUsed;      <span class="comment">// number of elements currently present (size)</span>
<a name="l00804"></a>00804 <a class="code" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>    nAllocated; <span class="comment">// heap allocation; 0 if pData is not owned</span>
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59" title="Default constructor allocates no heap space and is very fast.">ArrayViewConst_</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59" title="Default constructor allocates no heap space and is very fast.">ArrayViewConst_</a>&amp; src); <span class="comment">// suppressed</span>
<a name="l00807"></a>00807 };
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 
<a name="l00810"></a>00810 
<a name="l00811"></a>00811 
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 <span class="comment">//==============================================================================</span>
<a name="l00815"></a>00815 <span class="comment">//                            CLASS ArrayView_</span>
<a name="l00816"></a>00816 <span class="comment">//==============================================================================</span>
<a name="l00828"></a><a class="code" href="classSimTK_1_1ArrayView__.html">00828</a> <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">class </span><a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> : <span class="keyword">public</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>&lt;T,X&gt; {
<a name="l00829"></a>00829 <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T,X&gt;</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">CBase</a>;
<a name="l00830"></a>00830 <span class="keyword">public</span>:
<a name="l00831"></a>00831 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00836"></a>00836 <span class="comment"></span><span class="comment">/*{*/</span>
<a name="l00837"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aeb29ff328a71341945e442234f50e253">00837</a> <span class="keyword">typedef</span> T                                               <a class="code" href="classSimTK_1_1ArrayView__.html#aeb29ff328a71341945e442234f50e253" title="The type of object stored in this container.">value_type</a>;
<a name="l00838"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ae79baa909a71d2f8c75b1120776ccca3">00838</a> <span class="keyword">typedef</span> X                                               <a class="code" href="classSimTK_1_1ArrayView__.html#ae79baa909a71d2f8c75b1120776ccca3" title="The index type (an extension).">index_type</a>;
<a name="l00839"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a3950fd72f5f77716f823f8c0a9a87974">00839</a> <span class="keyword">typedef</span> T*                                              <a class="code" href="classSimTK_1_1ArrayView__.html#a3950fd72f5f77716f823f8c0a9a87974" title="A writable pointer to a value_type.">pointer</a>;
<a name="l00840"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ad6e8dabb125276c7fcdaa215b23f808f">00840</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T*                                        <a class="code" href="classSimTK_1_1ArrayView__.html#ad6e8dabb125276c7fcdaa215b23f808f" title="A const pointer to a value_type.">const_pointer</a>;
<a name="l00841"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ab4b4b454ffabc27881011e3dcfea4014">00841</a> <span class="keyword">typedef</span> T&amp;                                              <a class="code" href="classSimTK_1_1ArrayView__.html#ab4b4b454ffabc27881011e3dcfea4014" title="A writable value_type reference.">reference</a>;
<a name="l00842"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a611de0d81f0e43b256704e817d63ae47">00842</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                                        <a class="code" href="classSimTK_1_1ArrayView__.html#a611de0d81f0e43b256704e817d63ae47" title="A const value_type reference.">const_reference</a>;
<a name="l00843"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a6566e08689eb53ae89a2b000ed4a4140">00843</a> <span class="keyword">typedef</span> T*                                              <a class="code" href="classSimTK_1_1ArrayView__.html#a6566e08689eb53ae89a2b000ed4a4140" title="A writable iterator for this container (same as pointer here).">iterator</a>;
<a name="l00844"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a14185eed75d43f044775a366c02590c0">00844</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T*                                        <a class="code" href="classSimTK_1_1ArrayView__.html#a14185eed75d43f044775a366c02590c0" title="A const iterator for this container (same as const_pointer here).">const_iterator</a>;
<a name="l00845"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a704e9c961a4621efd1bfe21bf099ca77">00845</a> <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;                 <a class="code" href="classSimTK_1_1ArrayView__.html#a704e9c961a4621efd1bfe21bf099ca77" title="A writable reverse iterator for this container.">reverse_iterator</a>;
<a name="l00846"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ac1232d267e9b8c139cca1512b412a6d1">00846</a> <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;           <a class="code" href="classSimTK_1_1ArrayView__.html#ac1232d267e9b8c139cca1512b412a6d1" title="A const reverse iterator for this container.">const_reverse_iterator</a>;
<a name="l00847"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b">00847</a> <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a8a52ff7e685e2a6fa1d715475fbffa12" title="The signed or unsigned integral type to which an object of index type X can be converted without prod...">ArrayIndexTraits&lt;X&gt;::size_type</a>         <a class="code" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b" title="An integral type suitable for all indices and sizes for this array.">size_type</a>;
<a name="l00848"></a><a class="code" href="classSimTK_1_1ArrayView__.html#abad962ee7e4110ac6c20bdfa340f81dc">00848</a> <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a3f2218d2538016278c51f8f9d8be5dc9" title="A signed integral type large enough to hold the full range of possible signed differences i-j between...">ArrayIndexTraits&lt;X&gt;::difference_type</a>   <a class="code" href="classSimTK_1_1ArrayView__.html#abad962ee7e4110ac6c20bdfa340f81dc" title="A signed integral type that can represent the difference between any two legitimate index values for ...">difference_type</a>;
<a name="l00849"></a>00849 <span class="keyword">typedef</span> <span class="keyword">typename</span> ArrayIndexPackType&lt;size_type&gt;::packed_size_type 
<a name="l00850"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a9536141dcc61cfc646bb1f2062e5e558">00850</a>                                                         <a class="code" href="classSimTK_1_1ArrayView__.html#a9536141dcc61cfc646bb1f2062e5e558" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>;
<a name="l00851"></a>00851 <span class="comment">/*}*/</span>
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 
<a name="l00854"></a>00854 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00860"></a>00860 <span class="comment"></span>
<a name="l00862"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980">00862</a> <a class="code" href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980" title="Default constructor allocates no heap space and is very fast.">ArrayView_</a>() : <a class="code" href="classSimTK_1_1ArrayViewConst__.html">CBase</a>() {}
<a name="l00863"></a>00863 
<a name="l00865"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ad1ddf75311833fc599a934c3f3d5a57d">00865</a> <a class="code" href="classSimTK_1_1ArrayView__.html#ad1ddf75311833fc599a934c3f3d5a57d" title="Copy constructor is shallow.">ArrayView_</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; src) : <a class="code" href="classSimTK_1_1ArrayViewConst__.html">CBase</a>(src) {}
<a name="l00866"></a>00866 
<a name="l00868"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a8e6104f869055379b0fbd146aeefa919">00868</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a8e6104f869055379b0fbd146aeefa919" title="Construct from a range of writable memory.">ArrayView_</a>(T* first, <span class="keyword">const</span> T* last1) : <a class="code" href="classSimTK_1_1ArrayViewConst__.html">CBase</a>(first,last1) {} 
<a name="l00869"></a>00869 
<a name="l00871"></a>00871 <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l00872"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a176653cfecc6ee9dd5cbb08f53725a34">00872</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a176653cfecc6ee9dd5cbb08f53725a34" title="Construct to reference memory owned by a writable std::vector.">ArrayView_</a>(std::vector&lt;T,A&gt;&amp; v) : <a class="code" href="classSimTK_1_1ArrayViewConst__.html">CBase</a>(v) {}
<a name="l00873"></a>00873 
<a name="l00875"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aee82e038ccd001ede9b1104969fdfa3c">00875</a> <a class="code" href="classSimTK_1_1ArrayView__.html#aee82e038ccd001ede9b1104969fdfa3c" title="Implicit conversion of const ArrayView_ to const Array_&amp; (zero cost).">operator const Array_&lt;T,X&gt;&amp;</a>()<span class="keyword"> const </span>
<a name="l00876"></a>00876 <span class="keyword"></span>{   <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }  
<a name="l00877"></a>00877 
<a name="l00879"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a6ef7f785e236628b37192a5380d0a479">00879</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a6ef7f785e236628b37192a5380d0a479" title="Implicit conversion of non-const ArrayView_ to Array_&amp; (zero cost).">operator Array_&lt;T,X&gt;&amp;</a>() 
<a name="l00880"></a>00880 {   <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); } 
<a name="l00881"></a>00881 
<a name="l00884"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc">00884</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method -- clears the handle without doing anything to the data...">disconnect</a>() {this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">CBase::disconnect</a>();}
<a name="l00885"></a>00885 
<a name="l00888"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a509b38ff0b42a6ff6b38cd3b26f4096f">00888</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a509b38ff0b42a6ff6b38cd3b26f4096f" title="The destructor just disconnects the array view handle from its data; see ArrayViewConst_&lt;T,X&gt;::disconnect() for more information.">~ArrayView_</a>() {this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">CBase::disconnect</a>();}
<a name="l00892"></a>00892 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00904"></a>00904 <span class="comment"></span>
<a name="l00906"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180">00906</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180" title="Copy assignment; source must be the same size as this array.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; src) {
<a name="l00907"></a>00907     <span class="keywordflow">if</span> (&amp;src != <span class="keyword">this</span>)
<a name="l00908"></a>00908         avAssignIteratorDispatch(src.<a class="code" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5" title="Return a const pointer to the first element of this array if any, otherwise end(), which may be null (0) in that case but does not have to be.">cbegin</a>(), src.<a class="code" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>(),
<a name="l00909"></a>00909                                  std::random_access_iterator_tag(),
<a name="l00910"></a>00910                                  <span class="stringliteral">&quot;ArrayView_&lt;T&gt;::operator=(ArrayView_&lt;T&gt;)&quot;</span>);
<a name="l00911"></a>00911     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00912"></a>00912 }
<a name="l00913"></a>00913 
<a name="l00914"></a>00914 
<a name="l00917"></a>00917 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt;
<a name="l00918"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a7f8826e1792377e63d47b9c9a3c53584">00918</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a7f8826e1792377e63d47b9c9a3c53584" title="Assignment from any other array object is allowed as long as the number of elements matches and the t...">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; src) {
<a name="l00919"></a>00919     <span class="keywordflow">if</span> ((<span class="keyword">const</span> <span class="keywordtype">void</span>*)&amp;src != (<span class="keywordtype">void</span>*)<span class="keyword">this</span>)
<a name="l00920"></a>00920         avAssignIteratorDispatch(src.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">cbegin</a>(), src.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>(),
<a name="l00921"></a>00921                                  std::random_access_iterator_tag(),
<a name="l00922"></a>00922                                  <span class="stringliteral">&quot;ArrayView_&lt;T&gt;::operator=(Array_&lt;T2&gt;)&quot;</span>);
<a name="l00923"></a>00923     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00924"></a>00924 }
<a name="l00925"></a>00925 
<a name="l00926"></a>00926 <span class="comment">// Help out dumb compilers struggling to match the template arguments and</span>
<a name="l00927"></a>00927 <span class="comment">// promote the Array_ or ArrayView_ to ArrayConstView_ at the same time.</span>
<a name="l00928"></a>00928 
<a name="l00931"></a>00931 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt;
<a name="l00932"></a><a class="code" href="classSimTK_1_1ArrayView__.html#acb5dc46e5a1126a8e30882e53a86c62d">00932</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180" title="Copy assignment; source must be the same size as this array.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T2,X2&gt;</a>&amp; src)
<a name="l00933"></a>00933 {   <span class="keywordflow">return</span> *<span class="keyword">this</span> = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp;<span class="keyword">&gt;</span>(src); }
<a name="l00936"></a>00936 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt;
<a name="l00937"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a45bc77b91b7751a909ca6524346c9e8d">00937</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180" title="Copy assignment; source must be the same size as this array.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T2,X2&gt;</a>&amp; src)
<a name="l00938"></a>00938 {   <span class="keywordflow">return</span> *<span class="keyword">this</span> = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp;<span class="keyword">&gt;</span>(src); }
<a name="l00939"></a>00939 
<a name="l00942"></a>00942 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> A2&gt;
<a name="l00943"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a68daffa0f934e5f3d6f75adcb5d93367">00943</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a68daffa0f934e5f3d6f75adcb5d93367" title="Assignment from any std::vector object is allowed as long as the number of elements matches and the t...">operator=</a>(<span class="keyword">const</span> std::vector&lt;T2,A2&gt;&amp; src) {
<a name="l00944"></a>00944     avAssignIteratorDispatch(src.begin(), src.end(),
<a name="l00945"></a>00945                              std::random_access_iterator_tag(),
<a name="l00946"></a>00946                              <span class="stringliteral">&quot;ArrayView_&lt;T&gt;::operator=(std::vector&lt;T2&gt;)&quot;</span>);
<a name="l00947"></a>00947     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00948"></a>00948 }
<a name="l00949"></a>00949 
<a name="l00951"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a29e6a21ecbf455765267d5d12bde8628">00951</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180" title="Copy assignment; source must be the same size as this array.">operator=</a>(<span class="keyword">const</span> T&amp; fillValue) 
<a name="l00952"></a>00952 {   <a class="code" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill</a>(fillValue); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00953"></a>00953 
<a name="l00959"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2">00959</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill</a>(<span class="keyword">const</span> T&amp; fillValue) {
<a name="l00960"></a>00960     <span class="keywordflow">for</span> (T* d = <a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">begin</a>(); d != <a class="code" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d" title="The const version of end() is the same as cend().">end</a>(); ++d)
<a name="l00961"></a>00961         *d = fillValue; <span class="comment">// using T::operator=(T)</span>
<a name="l00962"></a>00962     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00963"></a>00963 }
<a name="l00964"></a>00964 
<a name="l00968"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c">00968</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n, <span class="keyword">const</span> T&amp; fillValue) {
<a name="l00969"></a>00969     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(n == <a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>(), <span class="stringliteral">&quot;ArrayView_&lt;T&gt;::assign(n,value)&quot;</span>,
<a name="l00970"></a>00970         <span class="stringliteral">&quot;Assignment to an ArrayView is permitted only if the source&quot;</span>
<a name="l00971"></a>00971         <span class="stringliteral">&quot; is the same size. Here n==%llu element(s) but the&quot;</span>
<a name="l00972"></a>00972         <span class="stringliteral">&quot; ArrayView has a fixed size of %llu.&quot;</span>, 
<a name="l00973"></a>00973         this-&gt;ull(n), this-&gt;ull(<a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>()));
<a name="l00974"></a>00974 
<a name="l00975"></a>00975     <a class="code" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill</a>(fillValue);
<a name="l00976"></a>00976 }
<a name="l00977"></a>00977 
<a name="l00995"></a>00995 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l00996"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a39312ebedf1ce457f129b39c69d4515a">00996</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1ArrayView__.html#a39312ebedf1ce457f129b39c69d4515a" title="Assign to this array to make it a copy of the elements in range [first,last1) given by ordinary point...">assign</a>(<span class="keyword">const</span> T2* first, <span class="keyword">const</span> T2* last1) {
<a name="l00997"></a>00997     <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName = <span class="stringliteral">&quot;ArrayView_&lt;T&gt;::assign(T2* first, T2* last1)&quot;</span>;
<a name="l00998"></a>00998     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>((first&amp;&amp;last1)||(first==last1), methodName, 
<a name="l00999"></a>00999         <span class="stringliteral">&quot;One of the source pointers was null (0); either both must be&quot;</span>
<a name="l01000"></a>01000         <span class="stringliteral">&quot; non-null or both must be null.&quot;</span>);
<a name="l01001"></a>01001     <span class="comment">// Valid pointers are random access iterators.</span>
<a name="l01002"></a>01002     avAssignIteratorDispatch(first, last1, std::random_access_iterator_tag(),
<a name="l01003"></a>01003                              methodName);
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 
<a name="l01035"></a>01035 <span class="comment">// Watch out for integral types matching this signature -- they must be</span>
<a name="l01036"></a>01036 <span class="comment">// forwarded to the assign(n, fillValue) signature instead.</span>
<a name="l01037"></a>01037 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iter&gt;
<a name="l01038"></a><a class="code" href="classSimTK_1_1ArrayView__.html#afb5c2516d03bb21d24ea4e87af777136">01038</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign</a>(<span class="keyword">const</span> Iter&amp; first, <span class="keyword">const</span> Iter&amp; last1)
<a name="l01039"></a>01039 {   avAssignDispatch(first,last1,<span class="keyword">typename</span> IsIntegralType&lt;Iter&gt;::Result(),
<a name="l01040"></a>01040                      <span class="stringliteral">&quot;ArrayView_&lt;T&gt;::assign(Iter first, Iter last1)&quot;</span>); }
<a name="l01044"></a>01044 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01051"></a>01051 <span class="comment"></span>
<a name="l01058"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a1802aff86a94788eab5bf63e5fd704df">01058</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a1802aff86a94788eab5bf63e5fd704df" title="Select an element by its index, returning a const reference.">operator[]</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#afa06a13341105ac7773a9c6bcd6a851c" title="Select an element by its index, returning a const reference.">CBase::operator[]</a>(i);}
<a name="l01059"></a>01059 
<a name="l01067"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a943c9a87081523151ddbf1d22a853e4e">01067</a> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a943c9a87081523151ddbf1d22a853e4e" title="Select an element by its index, returning a writable (lvalue) reference.">operator[]</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i) {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#afa06a13341105ac7773a9c6bcd6a851c" title="Select an element by its index, returning a const reference.">CBase::operator[]</a>(i));}
<a name="l01068"></a>01068 
<a name="l01073"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a99cae4892293f33c0ffb5e615beda7a5">01073</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a99cae4892293f33c0ffb5e615beda7a5" title="Same as operator[] but always range-checked, even in a Release build.">at</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b5d31ec735550ba4b262b8e5f387020" title="Same as operator[] but always range-checked, even in a Release build.">CBase::at</a>(i);}
<a name="l01074"></a>01074 
<a name="l01079"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ab93f3650f5d31037f0051431eb02b57b">01079</a> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#ab93f3650f5d31037f0051431eb02b57b" title="Same as operator[] but always range-checked, even in a Release build.">at</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i) {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b5d31ec735550ba4b262b8e5f387020" title="Same as operator[] but always range-checked, even in a Release build.">CBase::at</a>(i));}
<a name="l01080"></a>01080 
<a name="l01083"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ae9514b4dc81e3aee1fcf2d5b8acc3973">01083</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#ae9514b4dc81e3aee1fcf2d5b8acc3973" title="Same as the const form of operator[]; exists to provide a non-operator method for element access in c...">getElt</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a2af8a30f98edabfef434169ac33831e2" title="Same as the const form of operator[]; exists to provide a non-operator method for element access in c...">CBase::getElt</a>(i);}
<a name="l01086"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5">01086</a> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5" title="Same as the non-const form of operator[]; exists to provide a non-operator method for element access ...">updElt</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i) {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a2af8a30f98edabfef434169ac33831e2" title="Same as the const form of operator[]; exists to provide a non-operator method for element access in c...">CBase::getElt</a>(i));}
<a name="l01087"></a>01087 
<a name="l01093"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a95912a09cf7bd29259ef8d4473720424">01093</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a95912a09cf7bd29259ef8d4473720424" title="Return a const reference to the first element in this array, which must not be empty.">front</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554" title="Return a const reference to the first element in this array, which must not be empty (we&#39;ll check in ...">CBase::front</a>();} 
<a name="l01094"></a>01094 
<a name="l01100"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a1c3c26db7d7178a3e3c0b4603c7d0fcd">01100</a> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a1c3c26db7d7178a3e3c0b4603c7d0fcd" title="Return a writable reference to the first element in this array, which must not be empty...">front</a>() {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554" title="Return a const reference to the first element in this array, which must not be empty (we&#39;ll check in ...">CBase::front</a>());}
<a name="l01101"></a>01101 
<a name="l01107"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a0460ec7ea1179ddf927e473d5bae34e1">01107</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#a0460ec7ea1179ddf927e473d5bae34e1" title="Return a const reference to the last element in this array, which must not be empty.">back</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a26683b980dcd87bafd5c6446d8f8b25b" title="Return a const reference to the last element in this array, which must not be empty (we&#39;ll check in a...">CBase::back</a>();}
<a name="l01108"></a>01108 
<a name="l01114"></a><a class="code" href="classSimTK_1_1ArrayView__.html#abf707303e5e68fb5147fa36862c2bc57">01114</a> T&amp; <a class="code" href="classSimTK_1_1ArrayView__.html#abf707303e5e68fb5147fa36862c2bc57" title="Return a writable reference to the last element in this array, which must not be empty.">back</a>() {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a26683b980dcd87bafd5c6446d8f8b25b" title="Return a const reference to the last element in this array, which must not be empty (we&#39;ll check in a...">CBase::back</a>());}
<a name="l01115"></a>01115 
<a name="l01134"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7">01134</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> <a class="code" href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7" title="Select a contiguous subarray of the elements of this array and create another ArrayView_ that refers ...">operator()</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> index, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> length) {
<a name="l01135"></a>01135     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> ix(index);
<a name="l01136"></a>01136     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(isSizeInRange(ix, <a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>()), <span class="stringliteral">&quot;ArrayView_&lt;T&gt;(index,length)&quot;</span>,
<a name="l01137"></a>01137         <span class="stringliteral">&quot;For this operator, we must have 0 &lt;= index &lt;= size(), but&quot;</span>
<a name="l01138"></a>01138         <span class="stringliteral">&quot; index==%llu and size==%llu.&quot;</span>, this-&gt;ull(ix), ullSize());
<a name="l01139"></a>01139     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(isSizeInRange(length, <a class="code" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(<a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>()-ix)), 
<a name="l01140"></a>01140         <span class="stringliteral">&quot;ArrayView_&lt;T&gt;(index,length)&quot;</span>, 
<a name="l01141"></a>01141         <span class="stringliteral">&quot;This operator requires 0 &lt;= length &lt;= size()-index, but&quot;</span>
<a name="l01142"></a>01142         <span class="stringliteral">&quot; length==%llu and size()-index==%llu.&quot;</span>,this-&gt;ull(length),this-&gt;ull(<a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>()-ix));
<a name="l01143"></a>01143 
<a name="l01144"></a>01144     <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980" title="Default constructor allocates no heap space and is very fast.">ArrayView_</a>(<a class="code" href="classSimTK_1_1ArrayView__.html#a7a6a58e82529049f52e953a347aeb30e" title="The const version of the data() method is identical to cdata().">data</a>()+ix, <a class="code" href="classSimTK_1_1ArrayView__.html#a7a6a58e82529049f52e953a347aeb30e" title="The const version of the data() method is identical to cdata().">data</a>()+ix+length);
<a name="l01145"></a>01145 }
<a name="l01148"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15">01148</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15" title="Same as non-const operator()(index,length); exists to provide non-operator access to that functionali...">updSubArray</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> index, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> length)
<a name="l01149"></a>01149 {   <span class="keywordflow">return</span> (*<span class="keyword">this</span>)(index,length); }
<a name="l01153"></a>01153 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01162"></a>01162 <span class="comment"></span>
<a name="l01167"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5">01167</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5" title="Return a const pointer to the first element of this array if any, otherwise end(), which may be null (0) in that case but does not have to be.">cbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">CBase::cbegin</a>();}
<a name="l01169"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e">01169</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">begin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">CBase::cbegin</a>();}
<a name="l01174"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608">01174</a> T* <a class="code" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end().">begin</a>() {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">CBase::cbegin</a>());}
<a name="l01175"></a>01175 
<a name="l01180"></a><a class="code" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936">01180</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">CBase::cend</a>();}
<a name="l01182"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d">01182</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d" title="The const version of end() is the same as cend().">end</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">CBase::cend</a>();}
<a name="l01187"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb">01187</a> T* <a class="code" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end</a>() {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">CBase::cend</a>());}
<a name="l01188"></a>01188 
<a name="l01191"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a444e0272a509be58aa47bd4a661924ca">01191</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a444e0272a509be58aa47bd4a661924ca" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">CBase::crbegin</a>();}
<a name="l01193"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aa4d11403e60b499d439790bde90ffaeb">01193</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayView__.html#aa4d11403e60b499d439790bde90ffaeb" title="The const version of rbegin() is the same as crbegin().">rbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">CBase::crbegin</a>();} 
<a name="l01196"></a><a class="code" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d">01196</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce" title="A writable reverse iterator for this container.">reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin</a>() {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayView__.html#a704e9c961a4621efd1bfe21bf099ca77" title="A writable reverse iterator for this container.">reverse_iterator</a>(<a class="code" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d" title="The const version of end() is the same as cend().">end</a>());}
<a name="l01197"></a>01197 
<a name="l01201"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0">01201</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">CBase::crend</a>();}
<a name="l01203"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aee6852373084f7377944ead91c6f1ab4">01203</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayView__.html#aee6852373084f7377944ead91c6f1ab4" title="The const version of rend() is the same as crend().">rend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">CBase::crend</a>();}
<a name="l01207"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145">01207</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce" title="A writable reverse iterator for this container.">reverse_iterator</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend</a>() {<span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayView__.html#a704e9c961a4621efd1bfe21bf099ca77" title="A writable reverse iterator for this container.">reverse_iterator</a>(<a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">begin</a>());}
<a name="l01208"></a>01208 
<a name="l01215"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a1e0ee8a10102bcd47f53fe0e6c28d64c">01215</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayView__.html#a1e0ee8a10102bcd47f53fe0e6c28d64c" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">CBase::cdata</a>();}
<a name="l01218"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a7a6a58e82529049f52e953a347aeb30e">01218</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1ArrayView__.html#a7a6a58e82529049f52e953a347aeb30e" title="The const version of the data() method is identical to cdata().">data</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">CBase::cdata</a>();}
<a name="l01222"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24">01222</a> T* <a class="code" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data</a>() {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">CBase::cdata</a>());}
<a name="l01226"></a>01226 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01232"></a>01232 <span class="comment"></span>
<a name="l01233"></a>01233 <span class="comment">// Note: these have to be explicitly forwarded to the base class methods</span>
<a name="l01234"></a>01234 <span class="comment">// in order to keep gcc from complaining. Note that the &quot;this-&gt;&quot; is </span>
<a name="l01235"></a>01235 <span class="comment">// apparently necessary in order to permit delayed definition of templatized </span>
<a name="l01236"></a>01236 <span class="comment">// methods. Doxygen picks up the comments from the base class.</span>
<a name="l01237"></a>01237 
<a name="l01238"></a><a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">01238</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>()<span class="keyword">      const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">CBase::size</a>();}
<a name="l01239"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aa35a88ad9923d73872f79308600821f1">01239</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1ArrayView__.html#aa35a88ad9923d73872f79308600821f1" title="Return the maximum allowable size for this array.">max_size</a>()<span class="keyword">  const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea" title="Return the maximum allowable size for this array.">CBase::max_size</a>();}
<a name="l01240"></a><a class="code" href="classSimTK_1_1ArrayView__.html#ab75af4aca965b5170efc9b38956cac7c">01240</a> <span class="keywordtype">bool</span>      <a class="code" href="classSimTK_1_1ArrayView__.html#ab75af4aca965b5170efc9b38956cac7c" title="Return true if there are no elements currently stored in this array.">empty</a>()<span class="keyword">     const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c" title="Return true if there are no elements currently stored in this array.">CBase::empty</a>();}
<a name="l01241"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a51052b7d71f1ba291a6a1dcfbafa6e80">01241</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a51052b7d71f1ba291a6a1dcfbafa6e80" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>()<span class="keyword">  const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation.">CBase::capacity</a>();}
<a name="l01242"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aa573c73360997d8e1beb0a22f6b8452f">01242</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1ArrayView__.html#aa573c73360997d8e1beb0a22f6b8452f" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3c1c27ea8ca7b9f3411d438693fd8a2a" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">CBase::allocated</a>();}
<a name="l01243"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a9aa22264fa554e99c1266d9404404e32">01243</a> <span class="keywordtype">bool</span>      <a class="code" href="classSimTK_1_1ArrayView__.html#a9aa22264fa554e99c1266d9404404e32" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>()<span class="keyword">   const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a30c40081730e9681d6102972f42904f1" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">CBase::isOwner</a>();}
<a name="l01247"></a>01247 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01248"></a>01248                                    <span class="keyword">private</span>:
<a name="l01249"></a>01249 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01250"></a>01250 <span class="comment">// no data members are allowed</span>
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01253"></a>01253 <span class="comment">//                       ARRAY VIEW ASSIGN DISPATCH</span>
<a name="l01254"></a>01254 <span class="comment">// This is the assign() implementation for ArrayView_ when the class that </span>
<a name="l01255"></a>01255 <span class="comment">// matched the alleged InputIterator template argument turned out to be one of </span>
<a name="l01256"></a>01256 <span class="comment">// the integral types in which case this should match the assign(n, fillValue) </span>
<a name="l01257"></a>01257 <span class="comment">// signature.</span>
<a name="l01258"></a>01258 <span class="keyword">template</span> &lt;<span class="keyword">class</span> IntegralType&gt;
<a name="l01259"></a>01259 <span class="keywordtype">void</span> avAssignDispatch(IntegralType n, IntegralType v, TrueType isIntegralType,
<a name="l01260"></a>01260                       <span class="keyword">const</span> <span class="keywordtype">char</span>*) 
<a name="l01261"></a>01261 {   <a class="code" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign</a>(<a class="code" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(n), <a class="code" href="classSimTK_1_1ArrayView__.html#aeb29ff328a71341945e442234f50e253" title="The type of object stored in this container.">value_type</a>(v)); }
<a name="l01262"></a>01262 
<a name="l01263"></a>01263 <span class="comment">// This is the assign() implementation for ArrayView_ when the class that </span>
<a name="l01264"></a>01264 <span class="comment">// matched the alleged InputIterator template argument is NOT an integral type </span>
<a name="l01265"></a>01265 <span class="comment">// and may very well be an iterator. </span>
<a name="l01266"></a>01266 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt; 
<a name="l01267"></a>01267 <span class="keywordtype">void</span> avAssignDispatch(<span class="keyword">const</span> InputIterator&amp; first, <span class="keyword">const</span> InputIterator&amp; last1, 
<a name="l01268"></a>01268                       FalseType isIntegralType, <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l01269"></a>01269 {   avAssignIteratorDispatch(first, last1, 
<a name="l01270"></a>01270         <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::iterator_category(),
<a name="l01271"></a>01271         methodName); }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273 <span class="comment">// This is the assign() implementation for a plain input_iterator</span>
<a name="l01274"></a>01274 <span class="comment">// (i.e., not a forward, bidirectional, or random access iterator). These</span>
<a name="l01275"></a>01275 <span class="comment">// have the unfortunate property that we can&#39;t count the elements in advance.</span>
<a name="l01276"></a>01276 <span class="comment">// Here we&#39;re going to complain if there aren&#39;t enough; but will simply stop</span>
<a name="l01277"></a>01277 <span class="comment">// when we get size() elements and not insist that the input stream reached</span>
<a name="l01278"></a>01278 <span class="comment">// the supplied last1 iterator. Semantics is elementwise assignment.</span>
<a name="l01279"></a>01279 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l01280"></a>01280 <span class="keywordtype">void</span> avAssignIteratorDispatch(<span class="keyword">const</span> InputIterator&amp; first, 
<a name="l01281"></a>01281                               <span class="keyword">const</span> InputIterator&amp; last1, 
<a name="l01282"></a>01282                               std::input_iterator_tag, 
<a name="l01283"></a>01283                               <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l01284"></a>01284 {
<a name="l01285"></a>01285     T* p = <a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l01286"></a>01286     InputIterator src = first;
<a name="l01287"></a>01287     <span class="keywordflow">while</span> (src != last1 &amp;&amp; p != <a class="code" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d" title="The const version of end() is the same as cend().">end</a>())
<a name="l01288"></a>01288         *p++ = *src++; <span class="comment">// call T&#39;s assignment operator</span>
<a name="l01289"></a>01289 
<a name="l01290"></a>01290     <span class="comment">// p now points just after the last element that was copied.</span>
<a name="l01291"></a>01291     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b" title="An integral type suitable for all indices and sizes for this array.">size_type</a> nCopied = <a class="code" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(p - <a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">begin</a>());
<a name="l01292"></a>01292     <a class="code" href="ExceptionMacros_8h.html#a1726730864a3e4319cdd1dab8f41786f">SimTK_ERRCHK2_ALWAYS</a>(nCopied == <a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>(), methodName,
<a name="l01293"></a>01293         <span class="stringliteral">&quot;The supplied input_iterator provided only %llu elements but this&quot;</span>
<a name="l01294"></a>01294         <span class="stringliteral">&quot; ArrayView has a fixed size of %llu elements.&quot;</span>,
<a name="l01295"></a>01295         this-&gt;ull(nCopied), ullSize());
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="comment">// We don&#39;t care if there are still more input elements available.</span>
<a name="l01298"></a>01298 }
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <span class="comment">// This is the assign() implementation that works for forward and bidirectional</span>
<a name="l01301"></a>01301 <span class="comment">// iterators, but is not used for random_access_iterators. Here we&#39;ll count</span>
<a name="l01302"></a>01302 <span class="comment">// the elements as we copy them and complain at the end if there were too</span>
<a name="l01303"></a>01303 <span class="comment">// few or too many.</span>
<a name="l01304"></a>01304 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt;
<a name="l01305"></a>01305 <span class="keywordtype">void</span> avAssignIteratorDispatch(<span class="keyword">const</span> ForwardIterator&amp; first, 
<a name="l01306"></a>01306                               <span class="keyword">const</span> ForwardIterator&amp; last1,
<a name="l01307"></a>01307                               std::forward_iterator_tag, 
<a name="l01308"></a>01308                               <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l01309"></a>01309 {
<a name="l01310"></a>01310     T* p = <a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l01311"></a>01311     ForwardIterator src = first;
<a name="l01312"></a>01312     <span class="keywordflow">while</span> (src != last1 &amp;&amp; p != <a class="code" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d" title="The const version of end() is the same as cend().">end</a>())
<a name="l01313"></a>01313         *p++ = *src++; <span class="comment">// call T&#39;s assignment operator</span>
<a name="l01314"></a>01314 
<a name="l01315"></a>01315     <span class="comment">// p now points just after the last element that was copied.</span>
<a name="l01316"></a>01316     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b" title="An integral type suitable for all indices and sizes for this array.">size_type</a> nCopied = <a class="code" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(p - <a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">begin</a>());
<a name="l01317"></a>01317     <a class="code" href="ExceptionMacros_8h.html#a1726730864a3e4319cdd1dab8f41786f">SimTK_ERRCHK2_ALWAYS</a>(nCopied == <a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>(), methodName,
<a name="l01318"></a>01318         <span class="stringliteral">&quot;The supplied forward_ or bidirectional_iterator source range provided&quot;</span>
<a name="l01319"></a>01319         <span class="stringliteral">&quot; only %llu elements but this ArrayView has a fixed size of&quot;</span>
<a name="l01320"></a>01320         <span class="stringliteral">&quot; %llu elements.&quot;</span>, this-&gt;ull(nCopied), ullSize());
<a name="l01321"></a>01321 
<a name="l01322"></a>01322     <span class="comment">// Make sure we ran out of source elements.</span>
<a name="l01323"></a>01323     <a class="code" href="ExceptionMacros_8h.html#a8db8890acc243640d3c7f1159959ad53">SimTK_ERRCHK1_ALWAYS</a>(src == last1, methodName,
<a name="l01324"></a>01324         <span class="stringliteral">&quot;The supplied forward_ or bidirectional_iterator source range&quot;</span>
<a name="l01325"></a>01325         <span class="stringliteral">&quot; contained too many elements; this ArrayView has a fixed size of&quot;</span>
<a name="l01326"></a>01326         <span class="stringliteral">&quot; %llu elements.&quot;</span>, ullSize());
<a name="l01327"></a>01327 }
<a name="l01328"></a>01328 
<a name="l01329"></a>01329 <span class="comment">// This is the assign() implementation that works for random_access_iterators</span>
<a name="l01330"></a>01330 <span class="comment">// including ordinary pointers. Here we check the number of elements in advance</span>
<a name="l01331"></a>01331 <span class="comment">// and complain if the source and destination aren&#39;t the same size. The </span>
<a name="l01332"></a>01332 <span class="comment">// copying loop can be done faster in this case.</span>
<a name="l01333"></a>01333 <span class="keyword">template</span> &lt;<span class="keyword">class</span> RandomAccessIterator&gt;
<a name="l01334"></a>01334 <span class="keywordtype">void</span> avAssignIteratorDispatch(<span class="keyword">const</span> RandomAccessIterator&amp; first, 
<a name="l01335"></a>01335                               <span class="keyword">const</span> RandomAccessIterator&amp; last1,
<a name="l01336"></a>01336                               std::random_access_iterator_tag, 
<a name="l01337"></a>01337                               <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l01338"></a>01338 {
<a name="l01339"></a>01339     <a class="code" href="ExceptionMacros_8h.html#a1726730864a3e4319cdd1dab8f41786f">SimTK_ERRCHK2_ALWAYS</a>(this-&gt;isSameSize(last1-first), methodName,
<a name="l01340"></a>01340         <span class="stringliteral">&quot;Assignment to an ArrayView is permitted only if the source&quot;</span>
<a name="l01341"></a>01341         <span class="stringliteral">&quot; is the same size. Here the source had %llu element(s) but the&quot;</span>
<a name="l01342"></a>01342         <span class="stringliteral">&quot; ArrayView has a fixed size of %llu.&quot;</span>, 
<a name="l01343"></a>01343         this-&gt;ull(last1-first), this-&gt;ull(<a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>()));
<a name="l01344"></a>01344 
<a name="l01345"></a>01345     <a class="code" href="ExceptionMacros_8h.html#a1f664766e58e13ba0b71fc3fc46df3d5">SimTK_ERRCHK_ALWAYS</a>(!this-&gt;overlapsWithData(first,last1), methodName,
<a name="l01346"></a>01346         <span class="stringliteral">&quot;Source range can&#39;t overlap with the destination data.&quot;</span>);
<a name="l01347"></a>01347 
<a name="l01348"></a>01348     T* p = <a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l01349"></a>01349     RandomAccessIterator src = first;
<a name="l01350"></a>01350     <span class="keywordflow">while</span> (p != <a class="code" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d" title="The const version of end() is the same as cend().">end</a>())
<a name="l01351"></a>01351         *p++ = *src++; <span class="comment">// call T&#39;s assignment operator</span>
<a name="l01352"></a>01352 }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 
<a name="l01355"></a>01355 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01356"></a>01356 <span class="comment">// The following private methods are protected methods in the ArrayViewConst_ </span>
<a name="l01357"></a>01357 <span class="comment">// base class, so they should not need repeating here. However, we explicitly </span>
<a name="l01358"></a>01358 <span class="comment">// forward to the base methods to avoid gcc errors. The gcc complaint</span>
<a name="l01359"></a>01359 <span class="comment">// is due to their not depending on any template parameters; the &quot;this-&gt;&quot;</span>
<a name="l01360"></a>01360 <span class="comment">// apparently fixes that problem.</span>
<a name="l01361"></a>01361 
<a name="l01362"></a>01362 <a class="code" href="classSimTK_1_1ArrayView__.html#a9536141dcc61cfc646bb1f2062e5e558" title="The integral type we actually use internally to store size_type values.">packed_size_type</a> psize()<span class="keyword">      const </span>{<span class="keywordflow">return</span> this-&gt;CBase::psize();}
<a name="l01363"></a>01363 <a class="code" href="classSimTK_1_1ArrayView__.html#a9536141dcc61cfc646bb1f2062e5e558" title="The integral type we actually use internally to store size_type values.">packed_size_type</a> pallocated()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;CBase::pallocated();}
<a name="l01364"></a>01364 
<a name="l01365"></a>01365 <span class="comment">// This just cast sizes to unsigned long long so that we can do comparisons</span>
<a name="l01366"></a>01366 <span class="comment">// without getting warnings.</span>
<a name="l01367"></a>01367 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullSize()<span class="keyword">     const </span>{<span class="keywordflow">return</span> this-&gt;CBase::ullSize();}
<a name="l01368"></a>01368 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullCapacity()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;CBase::ullCapacity();}
<a name="l01369"></a>01369 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullMaxSize()<span class="keyword">  const </span>{<span class="keywordflow">return</span> this-&gt;CBase::ullMaxSize();}
<a name="l01370"></a>01370 <span class="comment">// This is the index type name and is handy for error messages to explain</span>
<a name="l01371"></a>01371 <span class="comment">// why some size was too big.</span>
<a name="l01372"></a>01372 <span class="keyword">const</span> <span class="keywordtype">char</span>* indexName()<span class="keyword"> const   </span>{<span class="keywordflow">return</span> this-&gt;CBase::indexName();}
<a name="l01373"></a>01373 };
<a name="l01374"></a>01374 
<a name="l01375"></a>01375 
<a name="l01376"></a>01376 
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 
<a name="l01379"></a>01379 <span class="comment">//==============================================================================</span>
<a name="l01380"></a>01380 <span class="comment">//                               CLASS Array_</span>
<a name="l01381"></a>01381 <span class="comment">//==============================================================================</span>
<a name="l01484"></a><a class="code" href="classSimTK_1_1Array__.html">01484</a> <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">class </span><a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> : <span class="keyword">public</span> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>&lt;T,X&gt; {
<a name="l01485"></a>01485     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T,X&gt;</a>      <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">Base</a>;
<a name="l01486"></a>01486     <span class="keyword">typedef</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T,X&gt;</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">CBase</a>;
<a name="l01487"></a>01487 <span class="keyword">public</span>:
<a name="l01488"></a>01488 
<a name="l01489"></a>01489 
<a name="l01490"></a>01490 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01496"></a>01496 <span class="comment"></span><span class="comment">// Doxygen picks up individual descriptions from the base class.</span>
<a name="l01497"></a>01497 <span class="comment">/*{*/</span>
<a name="l01498"></a><a class="code" href="classSimTK_1_1Array__.html#ac67020459c021a6a6e076839105b1dd8">01498</a> <span class="keyword">typedef</span> T                                               <a class="code" href="classSimTK_1_1Array__.html#ac67020459c021a6a6e076839105b1dd8" title="The type of object stored in this container.">value_type</a>;
<a name="l01499"></a><a class="code" href="classSimTK_1_1Array__.html#a3aed3ed93a6d406a35da0225352694b1">01499</a> <span class="keyword">typedef</span> X                                               <a class="code" href="classSimTK_1_1Array__.html#a3aed3ed93a6d406a35da0225352694b1" title="The index type (an extension).">index_type</a>;
<a name="l01500"></a><a class="code" href="classSimTK_1_1Array__.html#adfe40f48092df9a7deafe32ef1ec39fb">01500</a> <span class="keyword">typedef</span> T*                                              <a class="code" href="classSimTK_1_1Array__.html#adfe40f48092df9a7deafe32ef1ec39fb" title="A writable pointer to a value_type.">pointer</a>;
<a name="l01501"></a><a class="code" href="classSimTK_1_1Array__.html#a1e344836dca88d0070ee505da9a628bb">01501</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T*                                        <a class="code" href="classSimTK_1_1Array__.html#a1e344836dca88d0070ee505da9a628bb" title="A const pointer to a value_type.">const_pointer</a>;
<a name="l01502"></a><a class="code" href="classSimTK_1_1Array__.html#ae5efd5cd3092babe7a107b8efa664204">01502</a> <span class="keyword">typedef</span> T&amp;                                              <a class="code" href="classSimTK_1_1Array__.html#ae5efd5cd3092babe7a107b8efa664204" title="A writable value_type reference.">reference</a>;
<a name="l01503"></a><a class="code" href="classSimTK_1_1Array__.html#a3e967f4929d463e32202d34158f3e22f">01503</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                                        <a class="code" href="classSimTK_1_1Array__.html#a3e967f4929d463e32202d34158f3e22f" title="A const value_type reference.">const_reference</a>;
<a name="l01504"></a><a class="code" href="classSimTK_1_1Array__.html#a05144fefe932d1c76e2e0dcaedddcd03">01504</a> <span class="keyword">typedef</span> T*                                              <a class="code" href="classSimTK_1_1Array__.html#a05144fefe932d1c76e2e0dcaedddcd03" title="A writable iterator for this container (same as pointer here).">iterator</a>;
<a name="l01505"></a><a class="code" href="classSimTK_1_1Array__.html#a47a140d8babac3edb92ff620e77245d0">01505</a> <span class="keyword">typedef</span> <span class="keyword">const</span> T*                                        <a class="code" href="classSimTK_1_1Array__.html#a47a140d8babac3edb92ff620e77245d0" title="A const iterator for this container (same as const_pointer here).">const_iterator</a>;
<a name="l01506"></a><a class="code" href="classSimTK_1_1Array__.html#a9a9e2010641fb5df3c7e47c62a6db774">01506</a> <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;                 <a class="code" href="classSimTK_1_1Array__.html#a9a9e2010641fb5df3c7e47c62a6db774" title="A writable reverse iterator for this container.">reverse_iterator</a>;
<a name="l01507"></a><a class="code" href="classSimTK_1_1Array__.html#a96b19c88ae09eec0ff5288e8e824d498">01507</a> <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;           <a class="code" href="classSimTK_1_1Array__.html#a96b19c88ae09eec0ff5288e8e824d498" title="A const reverse iterator for this container.">const_reverse_iterator</a>;
<a name="l01508"></a><a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913">01508</a> <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a8a52ff7e685e2a6fa1d715475fbffa12" title="The signed or unsigned integral type to which an object of index type X can be converted without prod...">ArrayIndexTraits&lt;X&gt;::size_type</a>         <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>;
<a name="l01509"></a><a class="code" href="classSimTK_1_1Array__.html#a3a5ca3b32f612044bed7552b7dc96164">01509</a> <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structSimTK_1_1ArrayIndexTraits.html#a3f2218d2538016278c51f8f9d8be5dc9" title="A signed integral type large enough to hold the full range of possible signed differences i-j between...">ArrayIndexTraits&lt;X&gt;::difference_type</a>   <a class="code" href="classSimTK_1_1Array__.html#a3a5ca3b32f612044bed7552b7dc96164" title="A signed integral type that can represent the difference between any two legitimate index values for ...">difference_type</a>;
<a name="l01510"></a>01510 <span class="keyword">typedef</span> <span class="keyword">typename</span> ArrayIndexPackType&lt;size_type&gt;::packed_size_type 
<a name="l01511"></a><a class="code" href="classSimTK_1_1Array__.html#ab1b7dc77f42cab3244ec808e5d4d3ee3">01511</a>                                                         <a class="code" href="classSimTK_1_1Array__.html#ab1b7dc77f42cab3244ec808e5d4d3ee3" title="The integral type we actually use internally to store size_type values.">packed_size_type</a>;
<a name="l01512"></a>01512 <span class="comment">/*}*/</span>
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01521"></a>01521 <span class="comment"></span><span class="comment">/*{*/</span>
<a name="l01522"></a>01522 
<a name="l01524"></a><a class="code" href="classSimTK_1_1Array__.html#adc75b3e8df6112d5ea6fd77ad024bcc3">01524</a> <a class="code" href="classSimTK_1_1Array__.html#adc75b3e8df6112d5ea6fd77ad024bcc3" title="Default constructor allocates no heap space and is very fast.">Array_</a>() : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>() {}
<a name="l01525"></a>01525 
<a name="l01530"></a><a class="code" href="classSimTK_1_1Array__.html#a7a9e625487e34b5255619a492514926d">01530</a> <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Array__.html#a7a9e625487e34b5255619a492514926d" title="Construct an array containing n default-constructed elements.">Array_</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>() {
<a name="l01531"></a>01531     <a class="code" href="ExceptionMacros_8h.html#aec2d5db30b462322ef0013a50387ec96">SimTK_SIZECHECK</a>(n, <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::ctor(n)&quot;</span>);
<a name="l01532"></a>01532     allocateNoConstruct(n);
<a name="l01533"></a>01533     defaultConstruct(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>(), <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()+n);
<a name="l01534"></a>01534     setSize(n);
<a name="l01535"></a>01535 }
<a name="l01536"></a>01536 
<a name="l01540"></a><a class="code" href="classSimTK_1_1Array__.html#ad758f8ef3bb565989a22c5456a34f3b6">01540</a> <a class="code" href="classSimTK_1_1Array__.html#ad758f8ef3bb565989a22c5456a34f3b6" title="Construct an array containing n elements each set to a copy of the given initial value.">Array_</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n, <span class="keyword">const</span> T&amp; initVal) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>() {
<a name="l01541"></a>01541     <a class="code" href="ExceptionMacros_8h.html#aec2d5db30b462322ef0013a50387ec96">SimTK_SIZECHECK</a>(n, <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::ctor(n,T)&quot;</span>);
<a name="l01542"></a>01542     setSize(n);
<a name="l01543"></a>01543     allocateNoConstruct(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>());
<a name="l01544"></a>01544     fillConstruct(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>(), <a class="code" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>(), initVal);
<a name="l01545"></a>01545 }
<a name="l01561"></a>01561 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIter&gt;
<a name="l01562"></a><a class="code" href="classSimTK_1_1Array__.html#a730175ab17a18e5d87974ea97c712e3e">01562</a> <a class="code" href="classSimTK_1_1Array__.html#a730175ab17a18e5d87974ea97c712e3e" title="Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of iterators...">Array_</a>(<span class="keyword">const</span> InputIter&amp; first, <span class="keyword">const</span> InputIter&amp; last1) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>() {
<a name="l01563"></a>01563     ctorDispatch(first,last1,<span class="keyword">typename</span> IsIntegralType&lt;InputIter&gt;::Result());
<a name="l01564"></a>01564 }
<a name="l01565"></a>01565 
<a name="l01571"></a>01571 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l01572"></a><a class="code" href="classSimTK_1_1Array__.html#a782b385c4c710cf60fc4205371c7d5cc">01572</a> <a class="code" href="classSimTK_1_1Array__.html#a782b385c4c710cf60fc4205371c7d5cc" title="Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of ordinary pointers t...">Array_</a>(<span class="keyword">const</span> T2* first, <span class="keyword">const</span> T2* last1) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>() {
<a name="l01573"></a>01573     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>((first&amp;&amp;last1)||(first==last1), <span class="stringliteral">&quot;Array_&lt;T&gt;(first,last1)&quot;</span>, 
<a name="l01574"></a>01574         <span class="stringliteral">&quot;Pointers must be non-null unless they are both null.&quot;</span>);
<a name="l01575"></a>01575     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(this-&gt;isSizeOK(last1-first), <span class="stringliteral">&quot;Array_&lt;T&gt;(first,last1)&quot;</span>,
<a name="l01576"></a>01576         <span class="stringliteral">&quot;Source has %llu elements but this array is limited to %llu&quot;</span>
<a name="l01577"></a>01577         <span class="stringliteral">&quot; elements by its index type %s.&quot;</span>,
<a name="l01578"></a>01578         this-&gt;ull(last1-first), ullMaxSize(), indexName());
<a name="l01579"></a>01579 
<a name="l01580"></a>01580     setSize(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(last1-first));
<a name="l01581"></a>01581     allocateNoConstruct(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>());
<a name="l01582"></a>01582     copyConstruct(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>(), <a class="code" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>(), first);
<a name="l01583"></a>01583 }
<a name="l01584"></a>01584 
<a name="l01589"></a>01589 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l01590"></a><a class="code" href="classSimTK_1_1Array__.html#a40d3d7fccc13d4d892ce52ebccdf4acc">01590</a> <span class="keyword">explicit</span> <a class="code" href="classSimTK_1_1Array__.html#a40d3d7fccc13d4d892ce52ebccdf4acc" title="Construct an Array_&lt;T&gt; by copying from an std::vector&lt;T2&gt;, where T2 may be the same type as T but doesn&#39;t...">Array_</a>(<span class="keyword">const</span> std::vector&lt;T2&gt;&amp; v) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>() { 
<a name="l01591"></a>01591     <span class="keywordflow">if</span> (v.empty()) <span class="keywordflow">return</span>;
<a name="l01592"></a>01592 
<a name="l01593"></a>01593     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(this-&gt;isSizeOK(v.size()), <span class="stringliteral">&quot;Array_&lt;T&gt;::ctor(std::vector&lt;T2&gt;)&quot;</span>,
<a name="l01594"></a>01594         <span class="stringliteral">&quot;The source std::vector&#39;s size %llu is too big for this array which&quot;</span>
<a name="l01595"></a>01595         <span class="stringliteral">&quot; is limited to %llu elements by its index type %s.&quot;</span>,
<a name="l01596"></a>01596         this-&gt;ull(v.size()), ullMaxSize(), indexName());
<a name="l01597"></a>01597 
<a name="l01598"></a>01598     <span class="comment">// Call the above constructor, making sure to use pointers into the</span>
<a name="l01599"></a>01599     <span class="comment">// vector&#39;s data rather than the iterators begin() and end() in case</span>
<a name="l01600"></a>01600     <span class="comment">// they are different types.</span>
<a name="l01601"></a>01601     <span class="keyword">new</span> (<span class="keyword">this</span>) <a class="code" href="classSimTK_1_1Array__.html#adc75b3e8df6112d5ea6fd77ad024bcc3" title="Default constructor allocates no heap space and is very fast.">Array_</a>(&amp;v.front(), (&amp;v.back())+1);
<a name="l01602"></a>01602 }
<a name="l01603"></a>01603 
<a name="l01608"></a><a class="code" href="classSimTK_1_1Array__.html#afe60949157ed425b6b81b7ff0e11ca29">01608</a> <a class="code" href="classSimTK_1_1Array__.html#afe60949157ed425b6b81b7ff0e11ca29" title="Copy constructor allocates exactly as much memory as is in use in the source (not its capacity) and c...">Array_</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; src) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>() {
<a name="l01609"></a>01609     setSize(src.<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>());
<a name="l01610"></a>01610     allocateNoConstruct(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>());
<a name="l01611"></a>01611     copyConstruct(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>(), <a class="code" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>(), src.<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>());
<a name="l01612"></a>01612 }
<a name="l01613"></a>01613 
<a name="l01620"></a>01620 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt;
<a name="l01621"></a><a class="code" href="classSimTK_1_1Array__.html#af66a2741c555a387d09742b9a5517314">01621</a> <a class="code" href="classSimTK_1_1Array__.html#af66a2741c555a387d09742b9a5517314" title="Construct this Array_&lt;T,X&gt; as a copy of another Array_&lt;T2,X2&gt; where T2!=T or X2!=X.">Array_</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T2,X2&gt;</a>&amp; src) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>() {
<a name="l01622"></a>01622     <span class="keyword">new</span> (<span class="keyword">this</span>) <a class="code" href="classSimTK_1_1Array__.html#adc75b3e8df6112d5ea6fd77ad024bcc3" title="Default constructor allocates no heap space and is very fast.">Array_</a>(src.<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>(), src.<a class="code" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>()); <span class="comment">// see above</span>
<a name="l01623"></a>01623 }
<a name="l01624"></a>01624 
<a name="l01654"></a><a class="code" href="classSimTK_1_1Array__.html#a53d115efe0bc7dafba02b3d04562dd92">01654</a> <a class="code" href="classSimTK_1_1Array__.html#a53d115efe0bc7dafba02b3d04562dd92" title="Construct an Array_&lt;T&gt; by referencing (sharing) a given range of data [first,last1), without copying that data; better to use the corresponding ArrayView_&lt;T&gt; constructor if you can.">Array_</a>(T* first, <span class="keyword">const</span> T* last1, <span class="keyword">const</span> DontCopy&amp;) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>(first,last1) {}
<a name="l01655"></a>01655 
<a name="l01683"></a>01683 <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l01684"></a><a class="code" href="classSimTK_1_1Array__.html#a3331ee7155535eeac08b7297da16ebe3">01684</a> <a class="code" href="classSimTK_1_1Array__.html#a3331ee7155535eeac08b7297da16ebe3" title="Construct an Array_&lt;T&gt; by referencing (sharing) the data in an std::vector&lt;T&gt;, without copying the da...">Array_</a>(std::vector&lt;T,A&gt;&amp; v, <span class="keyword">const</span> DontCopy&amp;) : <a class="code" href="classSimTK_1_1ArrayView__.html">Base</a>(v) {}
<a name="l01685"></a>01685 
<a name="l01689"></a><a class="code" href="classSimTK_1_1Array__.html#ad55d3b71e2acdaa0f2bb8be2617c894f">01689</a> <a class="code" href="classSimTK_1_1Array__.html#ad55d3b71e2acdaa0f2bb8be2617c894f" title="The destructor performs a deallocate() operation which may result in element destruction and freeing ...">~Array_</a>() {
<a name="l01690"></a>01690     <a class="code" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate</a>();
<a name="l01691"></a>01691 }
<a name="l01692"></a>01692 
<a name="l01701"></a><a class="code" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38">01701</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; <a class="code" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate</a>() {
<a name="l01702"></a>01702     <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>()) { <span class="comment">// owner with non-zero allocation</span>
<a name="l01703"></a>01703         <a class="code" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa" title="Erase all the elements currently in this array without changing the capacity; equivalent to erase(beg...">clear</a>(); <span class="comment">// each element is destructed; size()=0; allocated() unchanged</span>
<a name="l01704"></a>01704         deallocateNoDestruct(); <span class="comment">// free data(); allocated()=0</span>
<a name="l01705"></a>01705     }
<a name="l01706"></a>01706     this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method -- clears the handle without doing anything to the data...">Base::disconnect</a>(); <span class="comment">// clear the handle</span>
<a name="l01707"></a>01707     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01708"></a>01708 }
<a name="l01709"></a>01709 
<a name="l01713"></a>01713 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l01748"></a>01748 <span class="comment"></span>
<a name="l01766"></a><a class="code" href="classSimTK_1_1Array__.html#a136a03677c28d7ee697df7e09b7aa2e2">01766</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a136a03677c28d7ee697df7e09b7aa2e2" title="Set this array to be n copies of the supplied fillValue.">assign</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n, <span class="keyword">const</span> T&amp; fillValue) {
<a name="l01767"></a>01767     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(this-&gt;isSizeOK(n), <span class="stringliteral">&quot;Array_&lt;T&gt;::assign(n,value)&quot;</span>,
<a name="l01768"></a>01768         <span class="stringliteral">&quot;Requested size %llu is too big for this array which is limited&quot;</span>
<a name="l01769"></a>01769         <span class="stringliteral">&quot; to %llu elements by its index type %s.&quot;</span>,
<a name="l01770"></a>01770         this-&gt;ull(n), ullMaxSize(), indexName());
<a name="l01771"></a>01771 
<a name="l01772"></a>01772     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>() || n==<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::assign(n,value)&quot;</span>,
<a name="l01773"></a>01773         <span class="stringliteral">&quot;Requested size %llu is not allowed because this is a non-owner&quot;</span>
<a name="l01774"></a>01774         <span class="stringliteral">&quot; array of fixed size %llu.&quot;</span>, this-&gt;ull(n), this-&gt;ull(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()));
<a name="l01775"></a>01775 
<a name="l01776"></a>01776     <span class="keywordflow">if</span> (!<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>())
<a name="l01777"></a>01777         this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">Base::fill</a>(fillValue);
<a name="l01778"></a>01778     <span class="keywordflow">else</span> {
<a name="l01779"></a>01779         <a class="code" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa" title="Erase all the elements currently in this array without changing the capacity; equivalent to erase(beg...">clear</a>(); <span class="comment">// all elements destructed; allocation unchanged</span>
<a name="l01780"></a>01780         reallocateIfAdvisable(n); <span class="comment">// change size if too small or too big</span>
<a name="l01781"></a>01781         fillConstruct(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>(), <a class="code" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata</a>()+n, fillValue);
<a name="l01782"></a>01782         setSize(n);
<a name="l01783"></a>01783     }
<a name="l01784"></a>01784 }
<a name="l01785"></a>01785 
<a name="l01800"></a><a class="code" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab">01800</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue.">fill</a>(<span class="keyword">const</span> T&amp; fillValue) {this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">Base::fill</a>(fillValue);}
<a name="l01801"></a>01801 
<a name="l01802"></a>01802 
<a name="l01824"></a>01824 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l01825"></a><a class="code" href="classSimTK_1_1Array__.html#a1614ce819a2a4221c0a072ffbc2a0935">01825</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a1614ce819a2a4221c0a072ffbc2a0935" title="Assign to this array to to make it a copy of the elements in range [first,last1) given by ordinary po...">assign</a>(<span class="keyword">const</span> T2* first, <span class="keyword">const</span> T2* last1) {
<a name="l01826"></a>01826     <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName = <span class="stringliteral">&quot;Array_&lt;T&gt;::assign(T2* first, T2* last1)&quot;</span>;
<a name="l01827"></a>01827     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>((first&amp;&amp;last1)||(first==last1), methodName, 
<a name="l01828"></a>01828         <span class="stringliteral">&quot;Pointers must be non-null unless they are both null.&quot;</span>);
<a name="l01829"></a>01829     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(!this-&gt;overlapsWithData(first,last1), methodName,
<a name="l01830"></a>01830         <span class="stringliteral">&quot;Source range can&#39;t overlap the current array contents.&quot;</span>);
<a name="l01831"></a>01831     <span class="comment">// Pointers are random access iterators.</span>
<a name="l01832"></a>01832     assignIteratorDispatch(first,last1,std::random_access_iterator_tag(),
<a name="l01833"></a>01833                            methodName);
<a name="l01834"></a>01834 }
<a name="l01835"></a>01835 
<a name="l01836"></a>01836 
<a name="l01872"></a>01872 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iter&gt;
<a name="l01873"></a><a class="code" href="classSimTK_1_1Array__.html#ab0fbbed70bc0fdb3ec5c188193503bb8">01873</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#ab0fbbed70bc0fdb3ec5c188193503bb8" title="Assign this array from a range [first,last1) given by non-pointer iterators.">assign</a>(<span class="keyword">const</span> Iter&amp; first, <span class="keyword">const</span> Iter&amp; last1) {
<a name="l01874"></a>01874     assignDispatch(first,last1,<span class="keyword">typename</span> IsIntegralType&lt;Iter&gt;::Result(),
<a name="l01875"></a>01875                    <span class="stringliteral">&quot;Array_&lt;T&gt;::assign(Iter first, Iter last1)&quot;</span>);
<a name="l01876"></a>01876 }
<a name="l01877"></a>01877 
<a name="l01883"></a><a class="code" href="classSimTK_1_1Array__.html#a17aa8ec53fbbd5af9d8311040b4e215a">01883</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; <a class="code" href="classSimTK_1_1Array__.html#a17aa8ec53fbbd5af9d8311040b4e215a" title="Copy assignment operator destructs the current contents of this array and then makes it a copy of the...">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; src) {
<a name="l01884"></a>01884     <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;src)
<a name="l01885"></a>01885         assignIteratorDispatch(src.<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>(), src.<a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(), 
<a name="l01886"></a>01886                                std::random_access_iterator_tag(),
<a name="l01887"></a>01887                                <span class="stringliteral">&quot;Array_&lt;T&gt;::operator=(Array_&lt;T&gt;)&quot;</span>);
<a name="l01888"></a>01888     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01889"></a>01889 }
<a name="l01890"></a>01890 
<a name="l01896"></a>01896 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt;
<a name="l01897"></a><a class="code" href="classSimTK_1_1Array__.html#a31782606c119d1db301ef14a930abd22">01897</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; <a class="code" href="classSimTK_1_1Array__.html#a31782606c119d1db301ef14a930abd22" title="This is assignment from a source array whose element type T2 and/or index type X2 are different from ...">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T2,X2&gt;</a>&amp; src) {
<a name="l01898"></a>01898     assignIteratorDispatch(src.<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>(), src.<a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(), 
<a name="l01899"></a>01899                            std::random_access_iterator_tag(),
<a name="l01900"></a>01900                            <span class="stringliteral">&quot;Array_&lt;T&gt;::operator=(Array_&lt;T2,X2&gt;)&quot;</span>);
<a name="l01901"></a>01901     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01902"></a>01902 }
<a name="l01903"></a>01903 
<a name="l01904"></a>01904 
<a name="l01909"></a>01909 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> A&gt;
<a name="l01910"></a><a class="code" href="classSimTK_1_1Array__.html#abada82afde9d55dbde8b44052ce1fda1">01910</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; <a class="code" href="classSimTK_1_1Array__.html#abada82afde9d55dbde8b44052ce1fda1" title="This is assignment from a source std::vector&lt;T2&gt;.">operator=</a>(<span class="keyword">const</span> std::vector&lt;T2,A&gt;&amp; src) {
<a name="l01911"></a>01911     assignIteratorDispatch(src.begin(), src.end(), 
<a name="l01912"></a>01912                            std::random_access_iterator_tag(),
<a name="l01913"></a>01913                            <span class="stringliteral">&quot;Array_&lt;T&gt;::operator=(std::vector)&quot;</span>);
<a name="l01914"></a>01914     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01915"></a>01915 }
<a name="l01916"></a>01916 
<a name="l01923"></a><a class="code" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92">01923</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92" title="This is a specialized algorithm providing constant time exchange of data with another array that has ...">swap</a>(<a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; other) {
<a name="l01924"></a>01924     T* <span class="keyword">const</span> pTmp=<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>(); setData(other.<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()); other.setData(pTmp);
<a name="l01925"></a>01925     <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> nTmp=<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(); setSize(other.<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()); other.setSize(nTmp);
<a name="l01926"></a>01926     nTmp=<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>(); setAllocated(other.<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>()); other.setAllocated(nTmp);
<a name="l01927"></a>01927 }
<a name="l01928"></a>01928 
<a name="l01934"></a><a class="code" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a">01934</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; <a class="code" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a" title="This dangerous extension allows you to supply your own already-allocated heap space for use by this a...">adoptData</a>(T* newData, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> dataSize, 
<a name="l01935"></a>01935                   <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> dataCapacity) 
<a name="l01936"></a>01936 {
<a name="l01937"></a>01937     <a class="code" href="ExceptionMacros_8h.html#aec2d5db30b462322ef0013a50387ec96">SimTK_SIZECHECK</a>(dataCapacity, <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::adoptData()&quot;</span>);
<a name="l01938"></a>01938     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(dataSize &lt;= dataCapacity, <span class="stringliteral">&quot;Array_&lt;T&gt;::adoptData()&quot;</span>, 
<a name="l01939"></a>01939         <span class="stringliteral">&quot;Specified data size %llu was greater than the specified data&quot;</span>
<a name="l01940"></a>01940         <span class="stringliteral">&quot; capacity of %llu.&quot;</span>, this-&gt;ull(dataSize), this-&gt;ull(dataCapacity));
<a name="l01941"></a>01941     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(newData || dataCapacity==0, <span class="stringliteral">&quot;Array_&lt;T&gt;::adoptData()&quot;</span>,
<a name="l01942"></a>01942         <span class="stringliteral">&quot;A null data pointer is allowed only if the size and capacity are&quot;</span>
<a name="l01943"></a>01943         <span class="stringliteral">&quot; specified as zero.&quot;</span>);
<a name="l01944"></a>01944     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(!this-&gt;overlapsWithData(newData, newData+dataSize), 
<a name="l01945"></a>01945         <span class="stringliteral">&quot;Array_&lt;T&gt;::adoptData()&quot;</span>,
<a name="l01946"></a>01946         <span class="stringliteral">&quot;The new data can&#39;t overlap with the old data.&quot;</span>);
<a name="l01947"></a>01947 
<a name="l01948"></a>01948     <a class="code" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate</a>();
<a name="l01949"></a>01949     setData(newData);
<a name="l01950"></a>01950     setSize(dataSize);
<a name="l01951"></a>01951     setAllocated(dataCapacity);
<a name="l01952"></a>01952     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01953"></a>01953 }
<a name="l01956"></a><a class="code" href="classSimTK_1_1Array__.html#a37550aafe7e3c54f9604ff80479153e9">01956</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; <a class="code" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a" title="This dangerous extension allows you to supply your own already-allocated heap space for use by this a...">adoptData</a>(T* newData, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> dataSize) 
<a name="l01957"></a>01957 {   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Array__.html#a37550aafe7e3c54f9604ff80479153e9" title="A variant of adoptData() that assumes the capacity is the same as the current size.">adoptData</a>(newData, dataSize, dataSize); }
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 
<a name="l01973"></a><a class="code" href="classSimTK_1_1Array__.html#a3e51e9d13453755cb0cce47af007d3c7">01973</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; <a class="code" href="classSimTK_1_1Array__.html#a3e51e9d13453755cb0cce47af007d3c7" title="This dangerous extension allows you to make this array handle refer to someone else&#39;s data without co...">shareData</a>(T* newData, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> dataSize) {
<a name="l01974"></a>01974     <a class="code" href="ExceptionMacros_8h.html#aec2d5db30b462322ef0013a50387ec96">SimTK_SIZECHECK</a>(dataSize, <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::shareData()&quot;</span>);
<a name="l01975"></a>01975     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(newData || dataSize==0, <span class="stringliteral">&quot;Array_&lt;T&gt;::shareData()&quot;</span>,
<a name="l01976"></a>01976         <span class="stringliteral">&quot;A null data pointer is allowed only if the size is zero.&quot;</span>);
<a name="l01977"></a>01977     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(!this-&gt;overlapsWithData(newData, newData+dataSize), 
<a name="l01978"></a>01978         <span class="stringliteral">&quot;Array_&lt;T&gt;::shareData()&quot;</span>,
<a name="l01979"></a>01979         <span class="stringliteral">&quot;The new data can&#39;t overlap with the old data.&quot;</span>);
<a name="l01980"></a>01980 
<a name="l01981"></a>01981     <a class="code" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate</a>();
<a name="l01982"></a>01982     setData(newData);
<a name="l01983"></a>01983     setSize(dataSize);
<a name="l01984"></a>01984     setAllocated(0); <span class="comment">// indicates shared data</span>
<a name="l01985"></a>01985     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01986"></a>01986 }
<a name="l01987"></a>01987 
<a name="l01990"></a><a class="code" href="classSimTK_1_1Array__.html#aa780ca6f8edd609cd461b0a90fbbca64">01990</a> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; <a class="code" href="classSimTK_1_1Array__.html#aa780ca6f8edd609cd461b0a90fbbca64" title="Same as shareData(data,size) but uses a pointer range [first,last1) to identify the data to be refere...">shareData</a>(T* first, <span class="keyword">const</span> T* last1) {
<a name="l01991"></a>01991     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(this-&gt;isSizeOK(last1-first), <span class="stringliteral">&quot;Array_&lt;T&gt;::shareData(first,last1)&quot;</span>,
<a name="l01992"></a>01992         <span class="stringliteral">&quot;Requested size %llu is too big for this array which is limited&quot;</span>
<a name="l01993"></a>01993         <span class="stringliteral">&quot; to %llu elements by its index type %s.&quot;</span>,
<a name="l01994"></a>01994         this-&gt;ull(last1-first), ullMaxSize(), indexName());
<a name="l01995"></a>01995     <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Array__.html#a3e51e9d13453755cb0cce47af007d3c7" title="This dangerous extension allows you to make this array handle refer to someone else&#39;s data without co...">shareData</a>(first, <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(last1-first));
<a name="l01996"></a>01996 }
<a name="l01997"></a>01997 
<a name="l02001"></a>02001 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l02007"></a>02007 <span class="comment"></span>
<a name="l02008"></a>02008 <span class="comment">// Note: these have to be explicitly forwarded to the base class methods</span>
<a name="l02009"></a>02009 <span class="comment">// in order to keep gcc from complaining. Note that the &quot;this-&gt;&quot; is </span>
<a name="l02010"></a>02010 <span class="comment">// apparently necessary in order to permit delayed definition of templatized </span>
<a name="l02011"></a>02011 <span class="comment">// methods.</span>
<a name="l02012"></a>02012 
<a name="l02014"></a><a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a">02014</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array.">CBase::size</a>();}
<a name="l02016"></a><a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046">02016</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea" title="Return the maximum allowable size for this array.">CBase::max_size</a>();}
<a name="l02019"></a><a class="code" href="classSimTK_1_1Array__.html#a41c0aa10d7095ff4a6c385a5f408b170">02019</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Array__.html#a41c0aa10d7095ff4a6c385a5f408b170" title="Return true if there are no elements currently stored in this array.">empty</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c" title="Return true if there are no elements currently stored in this array.">CBase::empty</a>();}
<a name="l02024"></a><a class="code" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb">02024</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation.">CBase::capacity</a>();}
<a name="l02025"></a>02025 
<a name="l02030"></a><a class="code" href="classSimTK_1_1Array__.html#a3ef48cf9aac351db79f747c2ddd23bf4">02030</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a3ef48cf9aac351db79f747c2ddd23bf4" title="Change the size of this Array, preserving all the elements that will still fit, and default construct...">resize</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n) {
<a name="l02031"></a>02031     <span class="keywordflow">if</span> (n == <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()) <span class="keywordflow">return</span>;
<a name="l02032"></a>02032 
<a name="l02033"></a>02033     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::resize(n)&quot;</span>,
<a name="l02034"></a>02034         <span class="stringliteral">&quot;Requested size change to %llu is not allowed because this is a&quot;</span>
<a name="l02035"></a>02035         <span class="stringliteral">&quot; non-owner array of fixed size %llu.&quot;</span>, this-&gt;ull(n), this-&gt;ull(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()));
<a name="l02036"></a>02036 
<a name="l02037"></a>02037     <span class="keywordflow">if</span> (n &lt; <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()) {
<a name="l02038"></a>02038         <a class="code" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase</a>(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()+n, <a class="code" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>());
<a name="l02039"></a>02039         <span class="keywordflow">return</span>;
<a name="l02040"></a>02040     }
<a name="l02041"></a>02041     <span class="comment">// n &gt; size()</span>
<a name="l02042"></a>02042     <a class="code" href="classSimTK_1_1Array__.html#a18b9cb15ea07f2da45d9b45a8f12429e" title="Ensure that this array has enough allocated capacity to hold the indicated number of elements...">reserve</a>(n);
<a name="l02043"></a>02043     defaultConstruct(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()+<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(), <a class="code" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata</a>()+n); <span class="comment">// data() has changed</span>
<a name="l02044"></a>02044     setSize(n);
<a name="l02045"></a>02045 }
<a name="l02046"></a>02046 
<a name="l02051"></a><a class="code" href="classSimTK_1_1Array__.html#ab839b023c760816f9580d4feea2c9136">02051</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#ab839b023c760816f9580d4feea2c9136" title="Change the size of this array, preserving all the elements that will still fit, and initializing any ...">resize</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n, <span class="keyword">const</span> T&amp; initVal) {
<a name="l02052"></a>02052     <span class="keywordflow">if</span> (n == <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()) <span class="keywordflow">return</span>;
<a name="l02053"></a>02053 
<a name="l02054"></a>02054     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::resize(n,value)&quot;</span>,
<a name="l02055"></a>02055         <span class="stringliteral">&quot;Requested size change to %llu is not allowed because this is a&quot;</span>
<a name="l02056"></a>02056         <span class="stringliteral">&quot; non-owner array of fixed size %llu.&quot;</span>, this-&gt;ull(n), this-&gt;ull(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()));
<a name="l02057"></a>02057 
<a name="l02058"></a>02058     <span class="keywordflow">if</span> (n &lt; <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()) {
<a name="l02059"></a>02059         <a class="code" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase</a>(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()+n, <a class="code" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>());
<a name="l02060"></a>02060         <span class="keywordflow">return</span>;
<a name="l02061"></a>02061     }
<a name="l02062"></a>02062     <span class="comment">// n &gt; size()</span>
<a name="l02063"></a>02063     <a class="code" href="classSimTK_1_1Array__.html#a18b9cb15ea07f2da45d9b45a8f12429e" title="Ensure that this array has enough allocated capacity to hold the indicated number of elements...">reserve</a>(n);
<a name="l02064"></a>02064     fillConstruct(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()+<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(), <a class="code" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata</a>()+n, initVal);
<a name="l02065"></a>02065     setSize(n);
<a name="l02066"></a>02066 }
<a name="l02067"></a>02067 
<a name="l02074"></a><a class="code" href="classSimTK_1_1Array__.html#a18b9cb15ea07f2da45d9b45a8f12429e">02074</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a18b9cb15ea07f2da45d9b45a8f12429e" title="Ensure that this array has enough allocated capacity to hold the indicated number of elements...">reserve</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n) {
<a name="l02075"></a>02075     <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>() &gt;= n)
<a name="l02076"></a>02076         <span class="keywordflow">return</span>;
<a name="l02077"></a>02077 
<a name="l02078"></a>02078     <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::reserve()&quot;</span>,
<a name="l02079"></a>02079         <span class="stringliteral">&quot;Requested capacity change to %llu is not allowed because this is a&quot;</span>
<a name="l02080"></a>02080         <span class="stringliteral">&quot; non-owner array of fixed size %llu.&quot;</span>, this-&gt;ull(n), this-&gt;ull(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()));
<a name="l02081"></a>02081 
<a name="l02082"></a>02082     T* newData = allocN(n); <span class="comment">// no construction yet</span>
<a name="l02083"></a>02083     copyConstructThenDestructSource(newData, newData+<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(), <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>());
<a name="l02084"></a>02084     freeN(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>());
<a name="l02085"></a>02085     setData(newData);
<a name="l02086"></a>02086     setAllocated(n);
<a name="l02087"></a>02087 }
<a name="l02088"></a>02088 
<a name="l02109"></a><a class="code" href="classSimTK_1_1Array__.html#aad5af2017b0c5a1a2160104d98a59294">02109</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#aad5af2017b0c5a1a2160104d98a59294" title="Request that the capacity of this array be reduced to the minimum necessary to hold the number of ele...">shrink_to_fit</a>() {
<a name="l02110"></a>02110     <span class="comment">// Allow 25% slop, but note that if size()==0 this will always reallocate</span>
<a name="l02111"></a>02111     <span class="comment">// unless capacity is already zero.</span>
<a name="l02112"></a>02112     <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>() - <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()/4 &lt;= <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()) <span class="comment">// avoid overflow if size() near max</span>
<a name="l02113"></a>02113         <span class="keywordflow">return</span>;
<a name="l02114"></a>02114     T* newData = allocN(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>());
<a name="l02115"></a>02115     copyConstructThenDestructSource(newData, newData+<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(), <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>());
<a name="l02116"></a>02116     deallocateNoDestruct(); <span class="comment">// data()=0, allocated()=0, size() unchanged</span>
<a name="l02117"></a>02117     setData(newData);
<a name="l02118"></a>02118     setAllocated(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>());
<a name="l02119"></a>02119 }
<a name="l02120"></a>02120 
<a name="l02124"></a><a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41">02124</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> <a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a3c1c27ea8ca7b9f3411d438693fd8a2a" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">CBase::allocated</a>();}
<a name="l02130"></a><a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d">02130</a> <span class="keywordtype">bool</span> <a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a30c40081730e9681d6102972f42904f1" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">CBase::isOwner</a>();}
<a name="l02134"></a>02134 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l02143"></a>02143 <span class="comment"></span>
<a name="l02148"></a><a class="code" href="classSimTK_1_1Array__.html#a1f009675fdf90d112f15279b35da6688">02148</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1Array__.html#a1f009675fdf90d112f15279b35da6688" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">cbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">CBase::cbegin</a>();}
<a name="l02150"></a><a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0">02150</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be.">CBase::cbegin</a>();}
<a name="l02155"></a><a class="code" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f">02155</a> T* <a class="code" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end().">begin</a>() {<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e" title="The const version of begin() is the same as cbegin().">Base::begin</a>();}
<a name="l02156"></a>02156 
<a name="l02161"></a><a class="code" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253">02161</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1Array__.html#a3758a3dc3ecebc1eeea89d389c049253" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">CBase::cend</a>();}
<a name="l02163"></a><a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08">02163</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">CBase::cend</a>();}
<a name="l02168"></a><a class="code" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec">02168</a> T* <a class="code" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end</a>() {<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d" title="The const version of end() is the same as cend().">Base::end</a>();}
<a name="l02169"></a>02169 
<a name="l02172"></a><a class="code" href="classSimTK_1_1Array__.html#af9f884619b7afeb2c4e31be0ac9a5c96">02172</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1Array__.html#af9f884619b7afeb2c4e31be0ac9a5c96" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">CBase::crbegin</a>();}
<a name="l02174"></a><a class="code" href="classSimTK_1_1Array__.html#a09a9b5657f95c864088caa629bbb14c8">02174</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1Array__.html#a09a9b5657f95c864088caa629bbb14c8" title="The const version of rbegin() is the same as crbegin().">rbegin</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">CBase::crbegin</a>();} 
<a name="l02177"></a><a class="code" href="classSimTK_1_1Array__.html#aab002eb8f193aea7d6b4ab3683ff89aa">02177</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce" title="A writable reverse iterator for this container.">reverse_iterator</a> <a class="code" href="classSimTK_1_1Array__.html#aab002eb8f193aea7d6b4ab3683ff89aa" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin</a>() {<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#aa4d11403e60b499d439790bde90ffaeb" title="The const version of rbegin() is the same as crbegin().">Base::rbegin</a>();}
<a name="l02178"></a>02178 
<a name="l02182"></a><a class="code" href="classSimTK_1_1Array__.html#a936220808b01ffe9e5080cf97cf67409">02182</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1Array__.html#a936220808b01ffe9e5080cf97cf67409" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">CBase::crend</a>();}
<a name="l02184"></a><a class="code" href="classSimTK_1_1Array__.html#af6614217a1df42b91aa38cb3ea7ec61d">02184</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40" title="A const reverse iterator for this container.">const_reverse_iterator</a> <a class="code" href="classSimTK_1_1Array__.html#af6614217a1df42b91aa38cb3ea7ec61d" title="The const version of rend() is the same as crend().">rend</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">CBase::crend</a>();}
<a name="l02188"></a><a class="code" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d">02188</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce" title="A writable reverse iterator for this container.">reverse_iterator</a> <a class="code" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend</a>() {<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#aee6852373084f7377944ead91c6f1ab4" title="The const version of rend() is the same as crend().">Base::rend</a>();}
<a name="l02189"></a>02189 
<a name="l02196"></a><a class="code" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b">02196</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">CBase::cdata</a>();}
<a name="l02199"></a><a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26">02199</a> <span class="keyword">const</span> T* <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">CBase::cdata</a>();}
<a name="l02203"></a><a class="code" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277">02203</a> T* <a class="code" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data</a>() {<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a7a6a58e82529049f52e953a347aeb30e" title="The const version of the data() method is identical to cdata().">Base::data</a>();}
<a name="l02211"></a>02211 
<a name="l02218"></a><a class="code" href="classSimTK_1_1Array__.html#ac6db339c90590b6a6c230c2ebaa63141">02218</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1Array__.html#ac6db339c90590b6a6c230c2ebaa63141" title="Select an element by its index, returning a const reference.">operator[]</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#afa06a13341105ac7773a9c6bcd6a851c" title="Select an element by its index, returning a const reference.">CBase::operator[]</a>(i);}
<a name="l02219"></a>02219 
<a name="l02227"></a><a class="code" href="classSimTK_1_1Array__.html#a52dc3c8d6816f2cc3d9e42caa2688993">02227</a> T&amp; <a class="code" href="classSimTK_1_1Array__.html#a52dc3c8d6816f2cc3d9e42caa2688993" title="Select an element by its index, returning a writable (lvalue) reference.">operator[]</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i) {<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a1802aff86a94788eab5bf63e5fd704df" title="Select an element by its index, returning a const reference.">Base::operator[]</a>(i);}
<a name="l02228"></a>02228 
<a name="l02233"></a><a class="code" href="classSimTK_1_1Array__.html#ab62d24dae1b22b621da114318134d55e">02233</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1Array__.html#ab62d24dae1b22b621da114318134d55e" title="Same as operator[] but always range-checked, even in a Release build.">at</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a4b5d31ec735550ba4b262b8e5f387020" title="Same as operator[] but always range-checked, even in a Release build.">CBase::at</a>(i);}
<a name="l02234"></a>02234 
<a name="l02239"></a><a class="code" href="classSimTK_1_1Array__.html#aa8a43460f045aeb40cc0e1ca44aacbc1">02239</a> T&amp; <a class="code" href="classSimTK_1_1Array__.html#aa8a43460f045aeb40cc0e1ca44aacbc1" title="Same as operator[] but always range-checked, even in a Release build.">at</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i) {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a99cae4892293f33c0ffb5e615beda7a5" title="Same as operator[] but always range-checked, even in a Release build.">Base::at</a>(i));}
<a name="l02240"></a>02240 
<a name="l02243"></a><a class="code" href="classSimTK_1_1Array__.html#a9e442e44a784734db4d3750c24d17ac1">02243</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1Array__.html#a9e442e44a784734db4d3750c24d17ac1" title="Same as the const form of operator[]; exists to provide a non-operator method for element access in c...">getElt</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i)<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a2af8a30f98edabfef434169ac33831e2" title="Same as the const form of operator[]; exists to provide a non-operator method for element access in c...">CBase::getElt</a>(i);}
<a name="l02246"></a><a class="code" href="classSimTK_1_1Array__.html#aa17ec9fa947bdc8b7aa75a0d09b36214">02246</a> T&amp; <a class="code" href="classSimTK_1_1Array__.html#aa17ec9fa947bdc8b7aa75a0d09b36214" title="Same as the non-const form of operator[]; exists to provide a non-operator method for element access ...">updElt</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> i) {<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5" title="Same as the non-const form of operator[]; exists to provide a non-operator method for element access ...">Base::updElt</a>(i);}
<a name="l02247"></a>02247 
<a name="l02253"></a><a class="code" href="classSimTK_1_1Array__.html#a8d24987c3a2d57c2ceb5e0d3f15f73b7">02253</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1Array__.html#a8d24987c3a2d57c2ceb5e0d3f15f73b7" title="Return a const reference to the first element in this array, which must not be empty.">front</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554" title="Return a const reference to the first element in this array, which must not be empty (we&#39;ll check in ...">CBase::front</a>();} 
<a name="l02254"></a>02254 
<a name="l02260"></a><a class="code" href="classSimTK_1_1Array__.html#a3e306ed9d706676046787b8f8c049480">02260</a> T&amp; <a class="code" href="classSimTK_1_1Array__.html#a3e306ed9d706676046787b8f8c049480" title="Return a writable reference to the first element in this array, which must not be empty...">front</a>() {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a95912a09cf7bd29259ef8d4473720424" title="Return a const reference to the first element in this array, which must not be empty.">Base::front</a>());}
<a name="l02261"></a>02261 
<a name="l02267"></a><a class="code" href="classSimTK_1_1Array__.html#a251212be7a0d7adaa5f9f72d8a694a64">02267</a> <span class="keyword">const</span> T&amp; <a class="code" href="classSimTK_1_1Array__.html#a251212be7a0d7adaa5f9f72d8a694a64" title="Return a const reference to the last element in this array, which must not be empty.">back</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a26683b980dcd87bafd5c6446d8f8b25b" title="Return a const reference to the last element in this array, which must not be empty (we&#39;ll check in a...">CBase::back</a>();}
<a name="l02268"></a>02268 
<a name="l02274"></a><a class="code" href="classSimTK_1_1Array__.html#af001d2418473e4e149969b0aea2ac96a">02274</a> T&amp; <a class="code" href="classSimTK_1_1Array__.html#af001d2418473e4e149969b0aea2ac96a" title="Return a writable reference to the last element in this array, which must not be empty.">back</a>() {<span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T&amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classSimTK_1_1ArrayView__.html#a0460ec7ea1179ddf927e473d5bae34e1" title="Return a const reference to the last element in this array, which must not be empty.">Base::back</a>());}
<a name="l02275"></a>02275 
<a name="l02278"></a><a class="code" href="classSimTK_1_1Array__.html#a88a623121405c9896be85477f4cb4953">02278</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T,X&gt;</a> <a class="code" href="classSimTK_1_1Array__.html#a88a623121405c9896be85477f4cb4953" title="Select a subrange of this const array by starting index and length, and return a ArrayViewConst_ refe...">operator()</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> index, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> length)<span class="keyword"> const</span>
<a name="l02279"></a>02279 <span class="keyword"></span>{   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#ab1816a17c6b643eb0967f954cdd96635" title="Select a contiguous subarray of the elements of this array and create another ArrayViewConst_ that re...">CBase::operator()</a>(index,length); }
<a name="l02282"></a><a class="code" href="classSimTK_1_1Array__.html#a8471d7b2c924d3704fbd54ab10451c19">02282</a> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T,X&gt;</a> <a class="code" href="classSimTK_1_1Array__.html#a8471d7b2c924d3704fbd54ab10451c19" title="Same as const form of operator()(index,length); exists to provide non-operator access to that functio...">getSubArray</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> index, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> length)<span class="keyword"> const</span>
<a name="l02283"></a>02283 <span class="keyword"></span>{   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#a288833be443e0f02d958f5cfe74312ba" title="Same as const form of operator()(index,length); exists to provide non-operator access to that functio...">CBase::getSubArray</a>(index,length); }
<a name="l02284"></a>02284 
<a name="l02287"></a><a class="code" href="classSimTK_1_1Array__.html#a9cbd317755142dd7707305ba1dd36c4b">02287</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T,X&gt;</a> <a class="code" href="classSimTK_1_1Array__.html#a88a623121405c9896be85477f4cb4953" title="Select a subrange of this const array by starting index and length, and return a ArrayViewConst_ refe...">operator()</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> index, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> length)
<a name="l02288"></a>02288 {   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7" title="Select a contiguous subarray of the elements of this array and create another ArrayView_ that refers ...">Base::operator()</a>(index,length); }
<a name="l02291"></a><a class="code" href="classSimTK_1_1Array__.html#a223502957a0d38152ea9bda9ac194829">02291</a> <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T,X&gt;</a> <a class="code" href="classSimTK_1_1Array__.html#a223502957a0d38152ea9bda9ac194829" title="Same as non-const operator()(index,length); exists to provide non-operator access to that functionali...">updSubArray</a>(<a class="code" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded" title="The index type (an extension).">index_type</a> index, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> length)
<a name="l02292"></a>02292 {   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15" title="Same as non-const operator()(index,length); exists to provide non-operator access to that functionali...">Base::updSubArray</a>(index,length); }
<a name="l02296"></a>02296 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l02302"></a>02302 <span class="comment"></span>
<a name="l02329"></a><a class="code" href="classSimTK_1_1Array__.html#a13b95bc701e5bd09dad7ee38e069b669">02329</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a13b95bc701e5bd09dad7ee38e069b669" title="This method increases the size of the Array by one element at the end and initializes that element by...">push_back</a>(<span class="keyword">const</span> T&amp; value) {
<a name="l02330"></a>02330     <span class="keywordflow">if</span> (pallocated() == psize())
<a name="l02331"></a>02331         growAtEnd(1,<span class="stringliteral">&quot;Array_&lt;T&gt;::push_back(value)&quot;</span>);
<a name="l02332"></a>02332     copyConstruct(<a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(), value);
<a name="l02333"></a>02333     incrSize();
<a name="l02334"></a>02334 }
<a name="l02335"></a>02335 
<a name="l02349"></a><a class="code" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5">02349</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back</a>() {
<a name="l02350"></a>02350     <span class="keywordflow">if</span> (pallocated() == psize())
<a name="l02351"></a>02351         growAtEnd(1,<span class="stringliteral">&quot;Array_&lt;T&gt;::push_back()&quot;</span>);
<a name="l02352"></a>02352     defaultConstruct(<a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>());
<a name="l02353"></a>02353     incrSize();
<a name="l02354"></a>02354 }
<a name="l02355"></a>02355 
<a name="l02371"></a><a class="code" href="classSimTK_1_1Array__.html#a7ceb31ef48594914eaef9ddcec92791c">02371</a> T* <a class="code" href="classSimTK_1_1Array__.html#a7ceb31ef48594914eaef9ddcec92791c" title="This dangerous method increases the Array&#39;s size by one element at the end but doesn&#39;t perform any co...">raw_push_back</a>() {
<a name="l02372"></a>02372     <span class="keywordflow">if</span> (pallocated() == psize())
<a name="l02373"></a>02373         growAtEnd(1,<span class="stringliteral">&quot;Array_&lt;T&gt;::raw_push_back()&quot;</span>);
<a name="l02374"></a>02374     T* <span class="keyword">const</span> p = <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>();
<a name="l02375"></a>02375     incrSize();
<a name="l02376"></a>02376     <span class="keywordflow">return</span> p;
<a name="l02377"></a>02377 }
<a name="l02378"></a>02378 
<a name="l02381"></a><a class="code" href="classSimTK_1_1Array__.html#a54b5b478c9ac203ed767eadf7828ffcd">02381</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#a54b5b478c9ac203ed767eadf7828ffcd" title="Remove the last element from this array, which must not be empty.">pop_back</a>() {
<a name="l02382"></a>02382     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(!<a class="code" href="classSimTK_1_1Array__.html#a41c0aa10d7095ff4a6c385a5f408b170" title="Return true if there are no elements currently stored in this array.">empty</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::pop_back()&quot;</span>, <span class="stringliteral">&quot;Array was empty.&quot;</span>);
<a name="l02383"></a>02383     destruct(&amp;<a class="code" href="classSimTK_1_1Array__.html#a251212be7a0d7adaa5f9f72d8a694a64" title="Return a const reference to the last element in this array, which must not be empty.">back</a>());
<a name="l02384"></a>02384     decrSize();
<a name="l02385"></a>02385 }
<a name="l02386"></a>02386 
<a name="l02404"></a><a class="code" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01">02404</a> T* <a class="code" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase</a>(T* first, <span class="keyword">const</span> T* last1) {
<a name="l02405"></a>02405     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>() &lt;= first &amp;&amp; first &lt;= last1 &amp;&amp; last1 &lt;= <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(),
<a name="l02406"></a>02406     <span class="stringliteral">&quot;Array&lt;T&gt;::erase(first,last1)&quot;</span>, <span class="stringliteral">&quot;Pointers out of range or out of order.&quot;</span>);
<a name="l02407"></a>02407 
<a name="l02408"></a>02408     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> nErased = <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(last1-first);
<a name="l02409"></a>02409     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>() || nErased==0, <span class="stringliteral">&quot;Array&lt;T&gt;::erase(first,last1)&quot;</span>,
<a name="l02410"></a>02410         <span class="stringliteral">&quot;No elements can be erased from a non-owner array.&quot;</span>);
<a name="l02411"></a>02411 
<a name="l02412"></a>02412     <span class="keywordflow">if</span> (nErased) {
<a name="l02413"></a>02413         destruct(first, last1); <span class="comment">// Destruct the elements we&#39;re erasing.</span>
<a name="l02414"></a>02414         moveElementsDown(first+nErased, nErased); <span class="comment">// Compress followers into the gap.</span>
<a name="l02415"></a>02415         setSize(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()-nErased);
<a name="l02416"></a>02416     }
<a name="l02417"></a>02417     <span class="keywordflow">return</span> first;
<a name="l02418"></a>02418 }
<a name="l02419"></a>02419 
<a name="l02439"></a><a class="code" href="classSimTK_1_1Array__.html#a818361e237b91adc12d2122f119c579c">02439</a> T* <a class="code" href="classSimTK_1_1Array__.html#a818361e237b91adc12d2122f119c579c" title="Erase just one element, moving all subsequent elements down one slot and reducing the array&#39;s size by...">erase</a>(T* p) {
<a name="l02440"></a>02440     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>() &lt;= p &amp;&amp; p &lt; <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(),
<a name="l02441"></a>02441         <span class="stringliteral">&quot;Array&lt;T&gt;::erase(p)&quot;</span>, <span class="stringliteral">&quot;Pointer must point to a valid element.&quot;</span>);
<a name="l02442"></a>02442     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>(), <span class="stringliteral">&quot;Array&lt;T&gt;::erase(p)&quot;</span>,
<a name="l02443"></a>02443         <span class="stringliteral">&quot;No elements can be erased from a non-owner array.&quot;</span>);
<a name="l02444"></a>02444 
<a name="l02445"></a>02445     destruct(p);              <span class="comment">// Destruct the element we&#39;re erasing.</span>
<a name="l02446"></a>02446     moveElementsDown(p+1, 1); <span class="comment">// Compress followers into the gap.</span>
<a name="l02447"></a>02447     decrSize();
<a name="l02448"></a>02448     <span class="keywordflow">return</span> p;
<a name="l02449"></a>02449 }
<a name="l02450"></a>02450 
<a name="l02451"></a>02451 
<a name="l02472"></a><a class="code" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6">02472</a> T* <a class="code" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6" title="Be careful with this non-standard extension; it erases one element and then moves the last one in its...">eraseFast</a>(T* p) {
<a name="l02473"></a>02473     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>() &lt;= p &amp;&amp; p &lt; <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(),
<a name="l02474"></a>02474         <span class="stringliteral">&quot;Array&lt;T&gt;::eraseFast(p)&quot;</span>, <span class="stringliteral">&quot;Pointer must point to a valid element.&quot;</span>);
<a name="l02475"></a>02475     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>(), <span class="stringliteral">&quot;Array&lt;T&gt;::eraseFast(p)&quot;</span>,
<a name="l02476"></a>02476         <span class="stringliteral">&quot;No elements can be erased from a non-owner array.&quot;</span>);
<a name="l02477"></a>02477 
<a name="l02478"></a>02478     destruct(p);
<a name="l02479"></a>02479     <span class="keywordflow">if</span> (p+1 != <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>()) 
<a name="l02480"></a>02480         moveOneElement(p, &amp;<a class="code" href="classSimTK_1_1Array__.html#a251212be7a0d7adaa5f9f72d8a694a64" title="Return a const reference to the last element in this array, which must not be empty.">back</a>());
<a name="l02481"></a>02481     decrSize();
<a name="l02482"></a>02482     <span class="keywordflow">return</span> p;
<a name="l02483"></a>02483 }
<a name="l02484"></a>02484 
<a name="l02492"></a><a class="code" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa">02492</a> <span class="keywordtype">void</span> <a class="code" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa" title="Erase all the elements currently in this array without changing the capacity; equivalent to erase(beg...">clear</a>() {
<a name="l02493"></a>02493     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>() || <a class="code" href="classSimTK_1_1Array__.html#a41c0aa10d7095ff4a6c385a5f408b170" title="Return true if there are no elements currently stored in this array.">empty</a>(), <span class="stringliteral">&quot;Array_&lt;T&gt;::clear()&quot;</span>, 
<a name="l02494"></a>02494         <span class="stringliteral">&quot;clear() is not allowed for a non-owner array.&quot;</span>);
<a name="l02495"></a>02495     destruct(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>(), <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>());
<a name="l02496"></a>02496     setSize(0);
<a name="l02497"></a>02497 }
<a name="l02498"></a>02498 
<a name="l02499"></a>02499 
<a name="l02526"></a><a class="code" href="classSimTK_1_1Array__.html#a7c6c04b85ed597b657f4cd244c02c52d">02526</a> T* <a class="code" href="classSimTK_1_1Array__.html#a7c6c04b85ed597b657f4cd244c02c52d" title="Insert n copies of a given value at a particular location within this array, moving all following ele...">insert</a>(T* p, <a class="code" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n, <span class="keyword">const</span> T&amp; value) {
<a name="l02527"></a>02527     T* <span class="keyword">const</span> gap = insertGapAt(p, n, <span class="stringliteral">&quot;Array&lt;T&gt;::insert(p,n,value)&quot;</span>);
<a name="l02528"></a>02528     <span class="comment">// Copy construct into the inserted elements and note the size change.</span>
<a name="l02529"></a>02529     fillConstruct(gap, gap+n, value);
<a name="l02530"></a>02530     setSize(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()+n);
<a name="l02531"></a>02531     <span class="keywordflow">return</span> gap;
<a name="l02532"></a>02532 }
<a name="l02533"></a>02533 
<a name="l02538"></a><a class="code" href="classSimTK_1_1Array__.html#a1de9710bd314b227b6d7fb9b1e2e5013">02538</a> T* <a class="code" href="classSimTK_1_1Array__.html#a1de9710bd314b227b6d7fb9b1e2e5013" title="Insert a new element at a given location within this array, initializing it to a copy of a given valu...">insert</a>(T* p, <span class="keyword">const</span> T&amp; value)  {
<a name="l02539"></a>02539     T* <span class="keyword">const</span> gap = insertGapAt(p, 1, <span class="stringliteral">&quot;Array&lt;T&gt;::insert(p,value)&quot;</span>);
<a name="l02540"></a>02540     <span class="comment">// Copy construct into the inserted element and note the size change.</span>
<a name="l02541"></a>02541     copyConstruct(gap, value);
<a name="l02542"></a>02542     incrSize();
<a name="l02543"></a>02543     <span class="keywordflow">return</span> gap;
<a name="l02544"></a>02544 }
<a name="l02545"></a>02545 
<a name="l02575"></a>02575 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T2&gt;
<a name="l02576"></a><a class="code" href="classSimTK_1_1Array__.html#a9e597a8ecd02706680bf8920c5a15f29">02576</a> T* <a class="code" href="classSimTK_1_1Array__.html#a9e597a8ecd02706680bf8920c5a15f29" title="Insert elements in a range [first,last1) into this array at a given position p, moving all following ...">insert</a>(T* p, <span class="keyword">const</span> T2* first, <span class="keyword">const</span> T2* last1) {
<a name="l02577"></a>02577     <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName = <span class="stringliteral">&quot;Array_&lt;T&gt;::insert(T* p, T2* first, T2* last1)&quot;</span>;
<a name="l02578"></a>02578     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>((first&amp;&amp;last1) || (first==last1), methodName, 
<a name="l02579"></a>02579         <span class="stringliteral">&quot;One of first or last1 was null; either both or neither must be null.&quot;</span>);
<a name="l02580"></a>02580     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(!this-&gt;overlapsWithData(first,last1), methodName,
<a name="l02581"></a>02581         <span class="stringliteral">&quot;Source range can&#39;t overlap with the current array contents.&quot;</span>);
<a name="l02582"></a>02582     <span class="comment">// Pointers are random access iterators.</span>
<a name="l02583"></a>02583     <span class="keywordflow">return</span> insertIteratorDispatch(p, first, last1,
<a name="l02584"></a>02584                                   std::random_access_iterator_tag(),
<a name="l02585"></a>02585                                   methodName);
<a name="l02586"></a>02586 }
<a name="l02587"></a>02587 
<a name="l02590"></a>02590 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iter&gt;
<a name="l02591"></a><a class="code" href="classSimTK_1_1Array__.html#ae2abd8e9d2146f344a88f96d1f839db0">02591</a> T* <a class="code" href="classSimTK_1_1Array__.html#ae2abd8e9d2146f344a88f96d1f839db0" title="Insert elements in a range [first,last1) where the range is given by non-pointer iterators.">insert</a>(T* p, <span class="keyword">const</span> Iter&amp; first, <span class="keyword">const</span> Iter&amp; last1) {
<a name="l02592"></a>02592     <span class="keywordflow">return</span> insertDispatch(p, first, last1,
<a name="l02593"></a>02593                           <span class="keyword">typename</span> IsIntegralType&lt;Iter&gt;::Result(),
<a name="l02594"></a>02594                           <span class="stringliteral">&quot;Array_&lt;T&gt;::insert(T* p, Iter first, Iter last1)&quot;</span>);
<a name="l02595"></a>02595 }
<a name="l02600"></a>02600 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l02601"></a>02601                                   <span class="keyword">private</span>:
<a name="l02602"></a>02602 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l02603"></a>02603 
<a name="l02604"></a>02604 
<a name="l02605"></a>02605 <span class="comment">// This method is used when we have already decided we need to make room for </span>
<a name="l02606"></a>02606 <span class="comment">// some new elements by reallocation, by creating a gap somewhere within the</span>
<a name="l02607"></a>02607 <span class="comment">// existing data. We&#39;ll issue an error message if this would violate the  </span>
<a name="l02608"></a>02608 <span class="comment">// max_size restriction (we can afford to do that even in a Release build since</span>
<a name="l02609"></a>02609 <span class="comment">// we don&#39;t expect to grow very often). Otherwise we&#39;ll allocate some more space</span>
<a name="l02610"></a>02610 <span class="comment">// and copy construct the existing elements into the new space, leaving a gap </span>
<a name="l02611"></a>02611 <span class="comment">// where indicated. Note that this method does not change the current size but</span>
<a name="l02612"></a>02612 <span class="comment">// does change the capacity.</span>
<a name="l02613"></a>02613 <span class="comment">//</span>
<a name="l02614"></a>02614 <span class="comment">// The gapPos must point within the existing data with null OK if the array</span>
<a name="l02615"></a>02615 <span class="comment">// itself is null, and end() being OK any time although you should use the</span>
<a name="l02616"></a>02616 <span class="comment">// more specialized growAtEnd() method if you know that&#39;s what&#39;s happening.</span>
<a name="l02617"></a>02617 <span class="comment">//</span>
<a name="l02618"></a>02618 <span class="comment">// Don&#39;t call this with a gapSz of zero.</span>
<a name="l02619"></a>02619 T* growWithGap(T* gapPos, <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> gapSz, <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) {
<a name="l02620"></a>02620     assert(gapSz &gt; 0); <span class="comment">// &lt;= 0 is a bug, not a user error</span>
<a name="l02621"></a>02621 
<a name="l02622"></a>02622     <span class="comment">// Note that gapPos may be null if begin() and end() are also.</span>
<a name="l02623"></a>02623     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>() &lt;= gapPos &amp;&amp; gapPos &lt;= <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(), methodName, 
<a name="l02624"></a>02624         <span class="stringliteral">&quot;Given insertion point is not valid for this array.&quot;</span>);
<a name="l02625"></a>02625 
<a name="l02626"></a>02626     <span class="comment">// Get some new space of a reasonable size.</span>
<a name="l02627"></a>02627     setAllocated(calcNewCapacityForGrowthBy(gapSz, methodName));
<a name="l02628"></a>02628     T* newData   = allocN(<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>());
<a name="l02629"></a>02629 
<a name="l02630"></a>02630     <span class="comment">// How many elements will be before the gap?</span>
<a name="l02631"></a>02631     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> nBefore = (<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>)(gapPos-<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>());
<a name="l02632"></a>02632 
<a name="l02633"></a>02633     <span class="comment">// Locate the gap in the new space allocation.</span>
<a name="l02634"></a>02634     T* newGap    = newData + nBefore;
<a name="l02635"></a>02635     T* newGapEnd = newGap  + gapSz; <span class="comment">// one past the last element in the gap</span>
<a name="l02636"></a>02636 
<a name="l02637"></a>02637     <span class="comment">// Copy elements before insertion point; destruct source as we go.</span>
<a name="l02638"></a>02638     copyConstructThenDestructSource(newData,   newGap,        <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>());
<a name="l02639"></a>02639     <span class="comment">// Copy/destruct elements at and after insertion pt; leave gapSz gap.</span>
<a name="l02640"></a>02640     copyConstructThenDestructSource(newGapEnd, newData+<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(), gapPos);
<a name="l02641"></a>02641 
<a name="l02642"></a>02642     <span class="comment">// Throw away the old data and switch to the new.</span>
<a name="l02643"></a>02643     freeN(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()); setData(newData);
<a name="l02644"></a>02644     <span class="keywordflow">return</span> newGap;
<a name="l02645"></a>02645 }
<a name="l02646"></a>02646 
<a name="l02647"></a>02647 <span class="comment">// Same as growWithGap(end(), n, methodName); see above.</span>
<a name="l02648"></a>02648 <span class="keywordtype">void</span> growAtEnd(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n, <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) {
<a name="l02649"></a>02649     assert(n &gt; 0); <span class="comment">// &lt;= 0 is a bug, not a user error</span>
<a name="l02650"></a>02650     <span class="comment">// Get some new space of a reasonable size.</span>
<a name="l02651"></a>02651     setAllocated(calcNewCapacityForGrowthBy(n, methodName));
<a name="l02652"></a>02652     T* newData   = allocN(<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>());
<a name="l02653"></a>02653     <span class="comment">// Copy all the elements; destruct source as we go.</span>
<a name="l02654"></a>02654     copyConstructThenDestructSource(newData, newData+<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(), <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>());
<a name="l02655"></a>02655     <span class="comment">// Throw away the old data and switch to the new.</span>
<a name="l02656"></a>02656     freeN(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()); setData(newData);
<a name="l02657"></a>02657 }
<a name="l02658"></a>02658 
<a name="l02659"></a>02659 <span class="comment">// This method determines how much we should increase the array&#39;s capacity</span>
<a name="l02660"></a>02660 <span class="comment">// when asked to insert n elements, due to an insertion or push_back. We will</span>
<a name="l02661"></a>02661 <span class="comment">// generally allocate more new space than requested, in anticipation of</span>
<a name="l02662"></a>02662 <span class="comment">// further insertions. This has to be based on the current size so that only</span>
<a name="l02663"></a>02663 <span class="comment">// log(n) reallocations are performed to insert n elements one at a time. Our</span>
<a name="l02664"></a>02664 <span class="comment">// policy here is to at least double the capacity unless that would exceed </span>
<a name="l02665"></a>02665 <span class="comment">// max_size(). There is also a minimum amount of allocation we&#39;ll do if the </span>
<a name="l02666"></a>02666 <span class="comment">// current size is zero or very small. </span>
<a name="l02667"></a>02667 <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> calcNewCapacityForGrowthBy(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n, <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName)<span class="keyword"> const </span>{
<a name="l02668"></a>02668     <a class="code" href="ExceptionMacros_8h.html#a06b646bcfe15dfac013393d6b3c2ad64">SimTK_ERRCHK3_ALWAYS</a>(isGrowthOK(n), methodName,
<a name="l02669"></a>02669         <span class="stringliteral">&quot;Can&#39;t grow this Array by %llu element(s) because it would&quot;</span>
<a name="l02670"></a>02670         <span class="stringliteral">&quot; then exceed the max_size of %llu set by its index type %s.&quot;</span>,
<a name="l02671"></a>02671         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)n, ullMaxSize(), indexName());
<a name="l02672"></a>02672 
<a name="l02673"></a>02673     <span class="comment">// At this point we know that capacity()+n &lt;= max_size().</span>
<a name="l02674"></a>02674     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> mustHave = <a class="code" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>() + n;
<a name="l02675"></a>02675 
<a name="l02676"></a>02676     <span class="comment">// Be careful not to overflow size_type as you could if you </span>
<a name="l02677"></a>02677     <span class="comment">// double capacity() rather than halving max_size().</span>
<a name="l02678"></a>02678     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> wantToHave = <a class="code" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>() &lt;= <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>()/2 
<a name="l02679"></a>02679                                     ? 2*<a class="code" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>() 
<a name="l02680"></a>02680                                     : <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>();
<a name="l02681"></a>02681 
<a name="l02682"></a>02682     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> newCapacity = <a class="code" href="namespaceSimTK.html#a5e54f17d86aeb08126d641bea4ba6f86">std::max</a>(<a class="code" href="namespaceSimTK.html#a5e54f17d86aeb08126d641bea4ba6f86">std::max</a>(mustHave,wantToHave),
<a name="l02683"></a>02683                                            minAlloc());
<a name="l02684"></a>02684     <span class="keywordflow">return</span> newCapacity;
<a name="l02685"></a>02685 }
<a name="l02686"></a>02686 
<a name="l02687"></a>02687 <span class="comment">// Insert an unconstructed gap of size n beginning at position p. The return</span>
<a name="l02688"></a>02688 <span class="comment">// value is a pointer to the first element in the gap. It will be p if no</span>
<a name="l02689"></a>02689 <span class="comment">// reallocation occurred, otherwise it will be pointing into the new data.</span>
<a name="l02690"></a>02690 <span class="comment">// On return size() will be unchanged although allocated() may be bigger.</span>
<a name="l02691"></a>02691 T* insertGapAt(T* p, <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n, <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) {
<a name="l02692"></a>02692     <span class="comment">// Note that p may be null if begin() and end() are also.</span>
<a name="l02693"></a>02693     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>() &lt;= p &amp;&amp; p &lt;= <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(), methodName, 
<a name="l02694"></a>02694         <span class="stringliteral">&quot;Given insertion point is not valid for this Array.&quot;</span>);
<a name="l02695"></a>02695 
<a name="l02696"></a>02696     <span class="keywordflow">if</span> (n==0) <span class="keywordflow">return</span> p; <span class="comment">// nothing to do</span>
<a name="l02697"></a>02697 
<a name="l02698"></a>02698     <a class="code" href="ExceptionMacros_8h.html#a1f664766e58e13ba0b71fc3fc46df3d5">SimTK_ERRCHK_ALWAYS</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>(), methodName,
<a name="l02699"></a>02699         <span class="stringliteral">&quot;No elements can be inserted into a non-owner array.&quot;</span>);
<a name="l02700"></a>02700 
<a name="l02701"></a>02701     <span class="comment">// Determine the number of elements before the insertion point and</span>
<a name="l02702"></a>02702     <span class="comment">// the number at or afterwards (those must be moved up by one slot).</span>
<a name="l02703"></a>02703     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> before = (<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>)(p-<a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>()), after = (<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>)(<a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>()-p);
<a name="l02704"></a>02704 
<a name="l02705"></a>02705     <span class="comment">// Grow the container if necessary. Note that if we have to grow we</span>
<a name="l02706"></a>02706     <span class="comment">// can create the gap at the same time we copy the old elements over</span>
<a name="l02707"></a>02707     <span class="comment">// to the new space.</span>
<a name="l02708"></a>02708     <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a7d905825b941637a97453cba165f0feb" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity</a>() &gt;= <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()+n) {
<a name="l02709"></a>02709         moveElementsUp(p, n); <span class="comment">// leave a gap at p</span>
<a name="l02710"></a>02710     } <span class="keywordflow">else</span> { <span class="comment">// need to grow</span>
<a name="l02711"></a>02711         setAllocated(calcNewCapacityForGrowthBy(n, methodName));
<a name="l02712"></a>02712         T* newdata = allocN(<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>());
<a name="l02713"></a>02713         <span class="comment">// Copy the elements before the insertion point, and destroy source.</span>
<a name="l02714"></a>02714         copyConstructThenDestructSource(newdata, newdata+before, <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>());
<a name="l02715"></a>02715         <span class="comment">// Copy the elements at and after the insertion point, leaving a gap</span>
<a name="l02716"></a>02716         <span class="comment">// of n elements.</span>
<a name="l02717"></a>02717         copyConstructThenDestructSource(newdata+before+n,
<a name="l02718"></a>02718                                         newdata+before+n+after,
<a name="l02719"></a>02719                                         p); <span class="comment">// i.e., pData+before</span>
<a name="l02720"></a>02720         p = newdata + before; <span class="comment">// points into newdata now</span>
<a name="l02721"></a>02721         freeN(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>());
<a name="l02722"></a>02722         setData(newdata);
<a name="l02723"></a>02723     }
<a name="l02724"></a>02724 
<a name="l02725"></a>02725     <span class="keywordflow">return</span> p;
<a name="l02726"></a>02726 }
<a name="l02727"></a>02727 
<a name="l02728"></a>02728 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l02729"></a>02729 <span class="comment">//                           CTOR DISPATCH</span>
<a name="l02730"></a>02730 <span class="comment">// This is the constructor implementation for when the class that matches</span>
<a name="l02731"></a>02731 <span class="comment">// the alleged InputIterator type turns out to be one of the integral types</span>
<a name="l02732"></a>02732 <span class="comment">// in which case this should be the ctor(n, initValue) constructor.</span>
<a name="l02733"></a>02733 <span class="keyword">template</span> &lt;<span class="keyword">class</span> IntegralType&gt; <span class="keywordtype">void</span>
<a name="l02734"></a>02734 ctorDispatch(IntegralType n, IntegralType v, TrueType isIntegralType) {
<a name="l02735"></a>02735     <span class="keyword">new</span>(<span class="keyword">this</span>) <a class="code" href="classSimTK_1_1Array__.html#adc75b3e8df6112d5ea6fd77ad024bcc3" title="Default constructor allocates no heap space and is very fast.">Array_</a>(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(n), <a class="code" href="classSimTK_1_1Array__.html#ac67020459c021a6a6e076839105b1dd8" title="The type of object stored in this container.">value_type</a>(v));
<a name="l02736"></a>02736 }
<a name="l02737"></a>02737 
<a name="l02738"></a>02738 <span class="comment">// This is the constructor implementation for when the class that matches</span>
<a name="l02739"></a>02739 <span class="comment">// the alleged InputIterator type is NOT an integral type and may very well</span>
<a name="l02740"></a>02740 <span class="comment">// be an iterator. In that case we split into iterators for which we can</span>
<a name="l02741"></a>02741 <span class="comment">// determine the number of elements in advance (forward, bidirectional,</span>
<a name="l02742"></a>02742 <span class="comment">// random access) and input iterators, for which we can&#39;t. Note: iterator</span>
<a name="l02743"></a>02743 <span class="comment">// types are arranged hierarchically random-&gt;bi-&gt;forward-&gt;input with each</span>
<a name="l02744"></a>02744 <span class="comment">// deriving from the one on its right, so the forward iterator tag also</span>
<a name="l02745"></a>02745 <span class="comment">// matches bi and random.</span>
<a name="l02746"></a>02746 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt; <span class="keywordtype">void</span>
<a name="l02747"></a>02747 ctorDispatch(<span class="keyword">const</span> InputIterator&amp; first, <span class="keyword">const</span> InputIterator&amp; last1, 
<a name="l02748"></a>02748              FalseType isIntegralType) 
<a name="l02749"></a>02749 {   ctorIteratorDispatch(first, last1, 
<a name="l02750"></a>02750         <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::iterator_category()); }
<a name="l02751"></a>02751 
<a name="l02752"></a>02752 <span class="comment">// This is the slow generic ctor implementation for any iterator that can&#39;t</span>
<a name="l02753"></a>02753 <span class="comment">// make it up to forward_iterator capability (that is, an input_iterator).</span>
<a name="l02754"></a>02754 <span class="comment">// The issue here is that we can&#39;t advance the iterator to count the number</span>
<a name="l02755"></a>02755 <span class="comment">// of elements before allocating because input_iterators are consumed when</span>
<a name="l02756"></a>02756 <span class="comment">// reference so we can&#39;t go back to look. That means we may have to reallocate</span>
<a name="l02757"></a>02757 <span class="comment">// memory log n times as we &quot;push back&quot; these elements onto the array.</span>
<a name="l02758"></a>02758 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt; <span class="keywordtype">void</span>
<a name="l02759"></a>02759 ctorIteratorDispatch(<span class="keyword">const</span> InputIterator&amp; first, <span class="keyword">const</span> InputIterator&amp; last1, 
<a name="l02760"></a>02760                      std::input_iterator_tag) 
<a name="l02761"></a>02761 {
<a name="l02762"></a>02762     InputIterator src = first;
<a name="l02763"></a>02763     <span class="keywordflow">while</span> (src != last1) {
<a name="l02764"></a>02764         <span class="comment">// We can afford to check this always since we are probably doing I/O.</span>
<a name="l02765"></a>02765         <span class="comment">// Throwing an exception in a constructor is tricky, though -- this</span>
<a name="l02766"></a>02766         <span class="comment">// won&#39;t go through the Array_ destructor although it will call the</span>
<a name="l02767"></a>02767         <span class="comment">// Base (ArrayView_) destructor. Since we have already allocated</span>
<a name="l02768"></a>02768         <span class="comment">// some space, we must call deallocate() manually.</span>
<a name="l02769"></a>02769         <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>() == <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>()) {
<a name="l02770"></a>02770             <a class="code" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate</a>();
<a name="l02771"></a>02771             <a class="code" href="ExceptionMacros_8h.html#a1726730864a3e4319cdd1dab8f41786f">SimTK_ERRCHK2_ALWAYS</a>(!<span class="stringliteral">&quot;too many elements&quot;</span>,
<a name="l02772"></a>02772                 <span class="stringliteral">&quot;Array_::ctor(InputIterator first, InputIterator last1)&quot;</span>,
<a name="l02773"></a>02773                 <span class="stringliteral">&quot;There were still source elements available when the array&quot;</span>
<a name="l02774"></a>02774                 <span class="stringliteral">&quot; reached its maximum size of %llu as determined by its index&quot;</span>
<a name="l02775"></a>02775                 <span class="stringliteral">&quot; type %s.&quot;</span>, ullMaxSize(), indexName());
<a name="l02776"></a>02776         }
<a name="l02777"></a>02777         <a class="code" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back</a>(*src++);
<a name="l02778"></a>02778     }
<a name="l02779"></a>02779 }
<a name="l02780"></a>02780 
<a name="l02781"></a>02781 <span class="comment">// This is the faster constructor implementation for iterator types for which</span>
<a name="l02782"></a>02782 <span class="comment">// we can calculate the number of elements in advance. This will be optimal</span>
<a name="l02783"></a>02783 <span class="comment">// for a random access iterator since we can count in constant time, but for</span>
<a name="l02784"></a>02784 <span class="comment">// forward or bidirectional we&#39;ll have to advance n times to count and then</span>
<a name="l02785"></a>02785 <span class="comment">// go back again to do the copy constructions.</span>
<a name="l02786"></a>02786 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt; <span class="keywordtype">void</span>
<a name="l02787"></a>02787 ctorIteratorDispatch(<span class="keyword">const</span> ForwardIterator&amp; first, <span class="keyword">const</span> ForwardIterator&amp; last1, 
<a name="l02788"></a>02788                      std::forward_iterator_tag) 
<a name="l02789"></a>02789 {
<a name="l02790"></a>02790     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIterator&gt;::difference_type
<a name="l02791"></a>02791         <a class="code" href="classSimTK_1_1Array__.html#a3a5ca3b32f612044bed7552b7dc96164" title="A signed integral type that can represent the difference between any two legitimate index values for ...">difference_type</a>;
<a name="l02792"></a>02792     <span class="comment">// iterDistance() is constant time for random access iterators, but </span>
<a name="l02793"></a>02793     <span class="comment">// O(last1-first) for forward and bidirectional since it has to increment </span>
<a name="l02794"></a>02794     <span class="comment">// to count how far apart they are.</span>
<a name="l02795"></a>02795     <span class="keyword">const</span> difference_type nInput = this-&gt;iterDistance(first,last1);
<a name="l02796"></a>02796 
<a name="l02797"></a>02797     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(nInput &gt;= 0, 
<a name="l02798"></a>02798         <span class="stringliteral">&quot;Array_(ForwardIterator first, ForwardIterator last1)&quot;</span>, 
<a name="l02799"></a>02799         <span class="stringliteral">&quot;Iterators were out of order.&quot;</span>);
<a name="l02800"></a>02800 
<a name="l02801"></a>02801     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(this-&gt;isSizeOK(nInput), 
<a name="l02802"></a>02802         <span class="stringliteral">&quot;Array_(ForwardIterator first, ForwardIterator last1)&quot;</span>,
<a name="l02803"></a>02803         <span class="stringliteral">&quot;Source has %llu elements but this array is limited to %llu&quot;</span>
<a name="l02804"></a>02804         <span class="stringliteral">&quot; elements by its index type %s.&quot;</span>,
<a name="l02805"></a>02805         this-&gt;ull(nInput), ullMaxSize(), indexName());
<a name="l02806"></a>02806 
<a name="l02807"></a>02807     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n = <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(nInput);
<a name="l02808"></a>02808     setSize(n);
<a name="l02809"></a>02809     allocateNoConstruct(n);
<a name="l02810"></a>02810     copyConstruct(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>(), <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()+n, first);
<a name="l02811"></a>02811 }
<a name="l02812"></a>02812 
<a name="l02813"></a>02813 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l02814"></a>02814 <span class="comment">//                           INSERT DISPATCH</span>
<a name="l02815"></a>02815 <span class="comment">// This is the insert() implementation for when the class that matches</span>
<a name="l02816"></a>02816 <span class="comment">// the alleged InputIterator type turns out to be one of the integral types</span>
<a name="l02817"></a>02817 <span class="comment">// in which case this should be the insert(p, n, initValue) constructor.</span>
<a name="l02818"></a>02818 <span class="keyword">template</span> &lt;<span class="keyword">class</span> IntegralType&gt; 
<a name="l02819"></a>02819 T* insertDispatch(T* p, IntegralType n, IntegralType v, 
<a name="l02820"></a>02820                   TrueType isIntegralType, <span class="keyword">const</span> <span class="keywordtype">char</span>*) 
<a name="l02821"></a>02821 {   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Array__.html#a7c6c04b85ed597b657f4cd244c02c52d" title="Insert n copies of a given value at a particular location within this array, moving all following ele...">insert</a>(p, <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(n), <a class="code" href="classSimTK_1_1Array__.html#ac67020459c021a6a6e076839105b1dd8" title="The type of object stored in this container.">value_type</a>(v)); }
<a name="l02822"></a>02822 
<a name="l02823"></a>02823 <span class="comment">// This is the insert() implementation for when the class that matches</span>
<a name="l02824"></a>02824 <span class="comment">// the alleged InputIterator type is NOT an integral type and may very well</span>
<a name="l02825"></a>02825 <span class="comment">// be an iterator. See ctorDispatch() above for more information.</span>
<a name="l02826"></a>02826 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt; 
<a name="l02827"></a>02827 T* insertDispatch(T* p, <span class="keyword">const</span> InputIterator&amp; first, <span class="keyword">const</span> InputIterator&amp; last1, 
<a name="l02828"></a>02828                   FalseType isIntegralType, <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l02829"></a>02829 {   <span class="keywordflow">return</span> insertIteratorDispatch(p, first, last1, 
<a name="l02830"></a>02830         <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::iterator_category(),
<a name="l02831"></a>02831         methodName); }
<a name="l02832"></a>02832 
<a name="l02833"></a>02833 <span class="comment">// This is the slow generic insert implementation for any iterator that can&#39;t</span>
<a name="l02834"></a>02834 <span class="comment">// make it up to forward_iterator capability (that is, an input_iterator).</span>
<a name="l02835"></a>02835 <span class="comment">// See ctorIteratorDispatch() above for more information.</span>
<a name="l02836"></a>02836 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt; 
<a name="l02837"></a>02837 T* insertIteratorDispatch(T* p, InputIterator first, InputIterator last1, 
<a name="l02838"></a>02838                           std::input_iterator_tag, <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l02839"></a>02839 {
<a name="l02840"></a>02840     <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> nInserted = 0;
<a name="l02841"></a>02841     <span class="keywordflow">while</span> (first != last1) {
<a name="l02842"></a>02842         <span class="comment">// We can afford to check this always since we are probably doing I/O.</span>
<a name="l02843"></a>02843         <a class="code" href="ExceptionMacros_8h.html#a1726730864a3e4319cdd1dab8f41786f">SimTK_ERRCHK2_ALWAYS</a>(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>() &lt; <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>(), methodName,
<a name="l02844"></a>02844             <span class="stringliteral">&quot;There were still source elements available when the array&quot;</span>
<a name="l02845"></a>02845             <span class="stringliteral">&quot; reached its maximum size of %llu as determined by its index&quot;</span>
<a name="l02846"></a>02846             <span class="stringliteral">&quot; type %s.&quot;</span>, ullMaxSize(), indexName());
<a name="l02847"></a>02847         p = <a class="code" href="classSimTK_1_1Array__.html#a7c6c04b85ed597b657f4cd244c02c52d" title="Insert n copies of a given value at a particular location within this array, moving all following ele...">insert</a>(p, *first++);  <span class="comment">// p may now point to reallocated memory</span>
<a name="l02848"></a>02848         ++p; ++nInserted;
<a name="l02849"></a>02849     }
<a name="l02850"></a>02850     <span class="comment">// p now points just after the last inserted element; subtract the</span>
<a name="l02851"></a>02851     <span class="comment">// number inserted to get a pointer to the first inserted element.</span>
<a name="l02852"></a>02852     <span class="keywordflow">return</span> p-nInserted;
<a name="l02853"></a>02853 }
<a name="l02854"></a>02854 
<a name="l02855"></a>02855 <span class="comment">// This is the faster constructor implementation for iterator types for which</span>
<a name="l02856"></a>02856 <span class="comment">// we can calculate the number of elements in advance. This will be optimal</span>
<a name="l02857"></a>02857 <span class="comment">// for a random access iterator since we can count in constant time, but for</span>
<a name="l02858"></a>02858 <span class="comment">// forward or bidirectional we&#39;ll have to advance n times to count and then</span>
<a name="l02859"></a>02859 <span class="comment">// go back again to do the copy constructions.</span>
<a name="l02860"></a>02860 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt;
<a name="l02861"></a>02861 T* insertIteratorDispatch(T* p, <span class="keyword">const</span> ForwardIterator&amp; first, 
<a name="l02862"></a>02862                                 <span class="keyword">const</span> ForwardIterator&amp; last1,
<a name="l02863"></a>02863                                 std::forward_iterator_tag,
<a name="l02864"></a>02864                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l02865"></a>02865 {
<a name="l02866"></a>02866     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIterator&gt;::difference_type
<a name="l02867"></a>02867         <a class="code" href="classSimTK_1_1Array__.html#a3a5ca3b32f612044bed7552b7dc96164" title="A signed integral type that can represent the difference between any two legitimate index values for ...">difference_type</a>;
<a name="l02868"></a>02868     <span class="comment">// iterDistance() is constant time for random access iterators, but </span>
<a name="l02869"></a>02869     <span class="comment">// O(last1-first) for forward and bidirectional since it has to increment </span>
<a name="l02870"></a>02870     <span class="comment">// to count how far apart they are.</span>
<a name="l02871"></a>02871     <span class="keyword">const</span> difference_type nInput = this-&gt;iterDistance(first,last1);
<a name="l02872"></a>02872 
<a name="l02873"></a>02873     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(nInput &gt;= 0, methodName, <span class="stringliteral">&quot;Iterators were out of order.&quot;</span>);
<a name="l02874"></a>02874 
<a name="l02875"></a>02875     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(isGrowthOK(nInput), methodName,
<a name="l02876"></a>02876         <span class="stringliteral">&quot;Source has %llu elements which would make this array exceed the %llu&quot;</span>
<a name="l02877"></a>02877         <span class="stringliteral">&quot; elements allowed by its index type %s.&quot;</span>,
<a name="l02878"></a>02878         this-&gt;ull(nInput), ullMaxSize(), indexName());
<a name="l02879"></a>02879 
<a name="l02880"></a>02880     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n = <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(nInput);
<a name="l02881"></a>02881     p = insertGapAt(p, n, methodName);
<a name="l02882"></a>02882     copyConstruct(p, p+n, first);
<a name="l02883"></a>02883     setSize(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>()+n);
<a name="l02884"></a>02884     <span class="keywordflow">return</span> p;
<a name="l02885"></a>02885 }
<a name="l02886"></a>02886 
<a name="l02887"></a>02887 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l02888"></a>02888 <span class="comment">//                           ASSIGN DISPATCH</span>
<a name="l02889"></a>02889 <span class="comment">// This is the assign() implementation for when the class that matches</span>
<a name="l02890"></a>02890 <span class="comment">// the alleged InputIterator type turns out to be one of the integral types</span>
<a name="l02891"></a>02891 <span class="comment">// in which case this should be the assign(n, initValue) constructor.</span>
<a name="l02892"></a>02892 <span class="keyword">template</span> &lt;<span class="keyword">class</span> IntegralType&gt;
<a name="l02893"></a>02893 <span class="keywordtype">void</span> assignDispatch(IntegralType n, IntegralType v, TrueType isIntegralType,
<a name="l02894"></a>02894                     <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l02895"></a>02895 {   <a class="code" href="classSimTK_1_1Array__.html#a136a03677c28d7ee697df7e09b7aa2e2" title="Set this array to be n copies of the supplied fillValue.">assign</a>(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(n), <a class="code" href="classSimTK_1_1Array__.html#ac67020459c021a6a6e076839105b1dd8" title="The type of object stored in this container.">value_type</a>(v)); }
<a name="l02896"></a>02896 
<a name="l02897"></a>02897 <span class="comment">// This is the assign() implementation for when the class that matches</span>
<a name="l02898"></a>02898 <span class="comment">// the alleged InputIterator type is NOT an integral type and may very well</span>
<a name="l02899"></a>02899 <span class="comment">// be an iterator. See ctorDispatch() above for more information.</span>
<a name="l02900"></a>02900 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt; 
<a name="l02901"></a>02901 <span class="keywordtype">void</span> assignDispatch(<span class="keyword">const</span> InputIterator&amp; first, <span class="keyword">const</span> InputIterator&amp; last1, 
<a name="l02902"></a>02902                     FalseType isIntegralType, <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l02903"></a>02903 {   assignIteratorDispatch(first, last1, 
<a name="l02904"></a>02904         <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::iterator_category(),
<a name="l02905"></a>02905         methodName); }
<a name="l02906"></a>02906 
<a name="l02907"></a>02907 <span class="comment">// This is the slow generic implementation for a plain input_iterator</span>
<a name="l02908"></a>02908 <span class="comment">// (i.e., not a forward, bidirectional, or random access iterator). These</span>
<a name="l02909"></a>02909 <span class="comment">// have the unfortunate property that we can&#39;t count the elements in advance.</span>
<a name="l02910"></a>02910 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l02911"></a>02911 <span class="keywordtype">void</span> assignIteratorDispatch(<span class="keyword">const</span> InputIterator&amp; first, 
<a name="l02912"></a>02912                             <span class="keyword">const</span> InputIterator&amp; last1, 
<a name="l02913"></a>02913                             std::input_iterator_tag, 
<a name="l02914"></a>02914                             <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l02915"></a>02915 {
<a name="l02916"></a>02916     <span class="comment">// TODO: should probably allow this and just blow up when the size()+1st</span>
<a name="l02917"></a>02917     <span class="comment">// element is seen.</span>
<a name="l02918"></a>02918     <a class="code" href="ExceptionMacros_8h.html#a1f664766e58e13ba0b71fc3fc46df3d5">SimTK_ERRCHK_ALWAYS</a>(<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>(), methodName,
<a name="l02919"></a>02919         <span class="stringliteral">&quot;Assignment to a non-owner array can only be done from a source&quot;</span>
<a name="l02920"></a>02920         <span class="stringliteral">&quot; designated with forward iterators or pointers because we&quot;</span>
<a name="l02921"></a>02921         <span class="stringliteral">&quot; must be able to verify that the source and destination sizes&quot;</span>
<a name="l02922"></a>02922         <span class="stringliteral">&quot; are the same.&quot;</span>);
<a name="l02923"></a>02923 
<a name="l02924"></a>02924     <a class="code" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa" title="Erase all the elements currently in this array without changing the capacity; equivalent to erase(beg...">clear</a>(); <span class="comment">// TODO: change space allocation here?</span>
<a name="l02925"></a>02925     InputIterator src = first;
<a name="l02926"></a>02926     <span class="keywordflow">while</span> (src != last1) {
<a name="l02927"></a>02927         <span class="comment">// We can afford to check this always since we are probably doing I/O.</span>
<a name="l02928"></a>02928         <a class="code" href="ExceptionMacros_8h.html#a1726730864a3e4319cdd1dab8f41786f">SimTK_ERRCHK2_ALWAYS</a>(<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>() &lt; <a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>(), methodName,
<a name="l02929"></a>02929             <span class="stringliteral">&quot;There were still source elements available when the array&quot;</span>
<a name="l02930"></a>02930             <span class="stringliteral">&quot; reached its maximum size of %llu as determined by its index&quot;</span>
<a name="l02931"></a>02931             <span class="stringliteral">&quot; type %s.&quot;</span>, ullMaxSize(), indexName());
<a name="l02932"></a>02932 
<a name="l02933"></a>02933         <a class="code" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="This is a non-standard version of push_back() that increases the size of the array by one default-con...">push_back</a>(*src++);
<a name="l02934"></a>02934     }
<a name="l02935"></a>02935 }
<a name="l02936"></a>02936 
<a name="l02937"></a>02937 <span class="comment">// This is the faster implementation that works for forward, bidirectional,</span>
<a name="l02938"></a>02938 <span class="comment">// and random access iterators including ordinary pointers. We can check here that the </span>
<a name="l02939"></a>02939 <span class="comment">// iterators are in the right order, and that the source is not too big to</span>
<a name="l02940"></a>02940 <span class="comment">// fit in this array. Null pointer checks should be done prior to calling,</span>
<a name="l02941"></a>02941 <span class="comment">// however, since iterators in general aren&#39;t pointers.</span>
<a name="l02942"></a>02942 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt;
<a name="l02943"></a>02943 <span class="keywordtype">void</span> assignIteratorDispatch(<span class="keyword">const</span> ForwardIterator&amp; first, 
<a name="l02944"></a>02944                             <span class="keyword">const</span> ForwardIterator&amp; last1,
<a name="l02945"></a>02945                             std::forward_iterator_tag, 
<a name="l02946"></a>02946                             <span class="keyword">const</span> <span class="keywordtype">char</span>* methodName) 
<a name="l02947"></a>02947 {
<a name="l02948"></a>02948     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIterator&gt;::difference_type
<a name="l02949"></a>02949         IterDiffType;
<a name="l02950"></a>02950     <span class="comment">// iterDistance() is constant time for random access iterators, but </span>
<a name="l02951"></a>02951     <span class="comment">// O(last1-first) for forward and bidirectional since it has to increment </span>
<a name="l02952"></a>02952     <span class="comment">// to count how far apart they are.</span>
<a name="l02953"></a>02953     <span class="keyword">const</span> IterDiffType nInput = this-&gt;iterDistance(first,last1);
<a name="l02954"></a>02954 
<a name="l02955"></a>02955     <a class="code" href="ExceptionMacros_8h.html#ab71559e3ecec1319c37bf36c9091f23a">SimTK_ERRCHK</a>(nInput &gt;= 0, methodName, <span class="stringliteral">&quot;Iterators were out of order.&quot;</span>);
<a name="l02956"></a>02956 
<a name="l02957"></a>02957     <a class="code" href="ExceptionMacros_8h.html#ab0e7127e868fb30c591df2e472bc64b2">SimTK_ERRCHK3</a>(this-&gt;isSizeOK(nInput), methodName,
<a name="l02958"></a>02958         <span class="stringliteral">&quot;Source has %llu elements but this Array is limited to %llu&quot;</span>
<a name="l02959"></a>02959         <span class="stringliteral">&quot; elements by its index type %s.&quot;</span>,
<a name="l02960"></a>02960         this-&gt;ull(nInput), ullMaxSize(), indexName());
<a name="l02961"></a>02961 
<a name="l02962"></a>02962     <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n = <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(nInput);
<a name="l02963"></a>02963     <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>()) {
<a name="l02964"></a>02964         <span class="comment">// This is an owner Array; assignment is considered deallocation</span>
<a name="l02965"></a>02965         <span class="comment">// followed by copy construction.</span>
<a name="l02966"></a>02966 
<a name="l02967"></a>02967         <a class="code" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa" title="Erase all the elements currently in this array without changing the capacity; equivalent to erase(beg...">clear</a>(); <span class="comment">// all elements destructed; allocation unchanged</span>
<a name="l02968"></a>02968         reallocateIfAdvisable(n); <span class="comment">// change allocation if too small or too big</span>
<a name="l02969"></a>02969         copyConstruct(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>(), <a class="code" href="classSimTK_1_1Array__.html#ace9ac236751f99b1663c504ae87d3a2b" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata</a>()+n, first);
<a name="l02970"></a>02970         setSize(n);
<a name="l02971"></a>02971     } <span class="keywordflow">else</span> {
<a name="l02972"></a>02972         <span class="comment">// This is a non-owner Array. Assignment can occur only if the</span>
<a name="l02973"></a>02973         <span class="comment">// source is the same size as the array, and the semantics are of</span>
<a name="l02974"></a>02974         <span class="comment">// repeated assignment using T::operator=() not destruction followed</span>
<a name="l02975"></a>02975         <span class="comment">// by copy construction.</span>
<a name="l02976"></a>02976         <a class="code" href="ExceptionMacros_8h.html#a57ba111f3c249a666b141d802807daa1">SimTK_ERRCHK2</a>(n == <a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(), methodName,
<a name="l02977"></a>02977             <span class="stringliteral">&quot;Source has %llu elements which does not match the size %llu&quot;</span>
<a name="l02978"></a>02978             <span class="stringliteral">&quot; of the non-owner array it is being assigned into.&quot;</span>,
<a name="l02979"></a>02979             this-&gt;ull(n), ullSize());
<a name="l02980"></a>02980 
<a name="l02981"></a>02981         T* p = <a class="code" href="classSimTK_1_1Array__.html#a8b25d6dc2485899425d6a4c96d574ed0" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l02982"></a>02982         ForwardIterator src = first;
<a name="l02983"></a>02983         <span class="keywordflow">while</span> (src != last1)
<a name="l02984"></a>02984             *p++ = *src++; <span class="comment">// call T&#39;s assignment operator</span>
<a name="l02985"></a>02985     }
<a name="l02986"></a>02986 }
<a name="l02987"></a>02987 
<a name="l02988"></a>02988 <span class="comment">// We are going to put a total of n elements into the Array (probably</span>
<a name="l02989"></a>02989 <span class="comment">// because of an assignment or resize) and we want the space allocation</span>
<a name="l02990"></a>02990 <span class="comment">// to be reasonable. That means of course that the allocation must be </span>
<a name="l02991"></a>02991 <span class="comment">// *at least* n, but we also don&#39;t want it to be too big. Our policy</span>
<a name="l02992"></a>02992 <span class="comment">// here is that if it is currently less than twice what we need we</span>
<a name="l02993"></a>02993 <span class="comment">// won&#39;t reallocate, otherwise we&#39;ll shrink the space. When changing</span>
<a name="l02994"></a>02994 <span class="comment">// the size to zero or something very small we&#39;ll treat the Array as</span>
<a name="l02995"></a>02995 <span class="comment">// though its current size is minAlloc, meaning we won&#39;t reallocate</span>
<a name="l02996"></a>02996 <span class="comment">// if the existing space is less than twice minAlloc.</span>
<a name="l02997"></a>02997 <span class="comment">// nAllocated will be set appropriately; size() is not touched here.</span>
<a name="l02998"></a>02998 <span class="comment">// No constructors or destructors are called.</span>
<a name="l02999"></a>02999 <span class="keywordtype">void</span> reallocateIfAdvisable(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n) {
<a name="l03000"></a>03000     <span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>() &lt; n || <a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>()/2 &gt; <a class="code" href="namespaceSimTK.html#a5e54f17d86aeb08126d641bea4ba6f86">std::max</a>(minAlloc(), n)) 
<a name="l03001"></a>03001         reallocateNoDestructOrConstruct(n);
<a name="l03002"></a>03002 }
<a name="l03003"></a>03003 
<a name="l03004"></a>03004 
<a name="l03005"></a>03005 <span class="keywordtype">void</span> allocateNoConstruct(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n) 
<a name="l03006"></a>03006 {   setData(allocN(n)); setAllocated(n); } <span class="comment">// size() left unchanged</span>
<a name="l03007"></a>03007 <span class="keywordtype">void</span> deallocateNoDestruct() 
<a name="l03008"></a>03008 {   freeN(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()); setData(0); setAllocated(0); } <span class="comment">// size() left unchanged</span>
<a name="l03009"></a>03009 <span class="keywordtype">void</span> reallocateNoDestructOrConstruct(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n)
<a name="l03010"></a>03010 {   deallocateNoDestruct(); allocateNoConstruct(n); }
<a name="l03011"></a>03011 
<a name="l03012"></a>03012 <span class="comment">// This sets the smallest allocation we&#39;ll do when growing.</span>
<a name="l03013"></a>03013 <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> minAlloc()<span class="keyword"> const </span>
<a name="l03014"></a>03014 <span class="keyword"></span>{   <span class="keywordflow">return</span> <a class="code" href="namespaceSimTK.html#a6c0a4de5068fb7373703f25a368760da">std::min</a>(<a class="code" href="classSimTK_1_1Array__.html#aa7f29e36968740e433a451cb82774046" title="Return the maximum allowable size for this array.">max_size</a>(), <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a>(4)); }
<a name="l03015"></a>03015 
<a name="l03016"></a>03016 <span class="comment">// Allocate without construction. Returns a null pointer if asked</span>
<a name="l03017"></a>03017 <span class="comment">// to allocate 0 elements. In Debug mode we&#39;ll fill memory with </span>
<a name="l03018"></a>03018 <span class="comment">// all 1&#39;s as a bug catcher.</span>
<a name="l03019"></a>03019 <span class="keyword">static</span> T* allocN(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n) {
<a name="l03020"></a>03020     <span class="keywordflow">if</span> (n==0) <span class="keywordflow">return</span> 0;
<a name="l03021"></a>03021     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* newdata = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[n * <span class="keyword">sizeof</span>(T)];
<a name="l03022"></a>03022 <span class="preprocessor">    #ifndef NDEBUG</span>
<a name="l03023"></a>03023 <span class="preprocessor"></span>        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* b=newdata; 
<a name="l03024"></a>03024         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* e=newdata+(n*<span class="keyword">sizeof</span>(T));
<a name="l03025"></a>03025         <span class="keywordflow">while</span> (b != e) *b++ = 0xff;
<a name="l03026"></a>03026 <span class="preprocessor">    #endif</span>
<a name="l03027"></a>03027 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>T*<span class="keyword">&gt;</span>(newdata);
<a name="l03028"></a>03028 }
<a name="l03029"></a>03029 
<a name="l03030"></a>03030 <span class="comment">// Free memory without calling T&#39;s destructor. Nothing happens if passed</span>
<a name="l03031"></a>03031 <span class="comment">// a null pointer.</span>
<a name="l03032"></a>03032 <span class="keyword">static</span> <span class="keywordtype">void</span> freeN(T* p) {
<a name="l03033"></a>03033     <span class="keyword">delete</span>[] <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(p);
<a name="l03034"></a>03034 }
<a name="l03035"></a>03035 
<a name="l03036"></a>03036 <span class="comment">// default construct one element</span>
<a name="l03037"></a>03037 <span class="keyword">static</span> <span class="keywordtype">void</span> defaultConstruct(T* p) {<span class="keyword">new</span>(p) T();}
<a name="l03038"></a>03038 <span class="comment">// default construct range [b,e)</span>
<a name="l03039"></a>03039 <span class="keyword">static</span> <span class="keywordtype">void</span> defaultConstruct(T* b, <span class="keyword">const</span> T* e) 
<a name="l03040"></a>03040 {   <span class="keywordflow">while</span> (b!=e) <span class="keyword">new</span>(b++) T(); }
<a name="l03041"></a>03041 
<a name="l03042"></a>03042 <span class="comment">// copy construct range [b,e) with repeats of a given value</span>
<a name="l03043"></a>03043 <span class="keyword">static</span> <span class="keywordtype">void</span> fillConstruct(T* b, <span class="keyword">const</span> T* e, <span class="keyword">const</span> T&amp; v)
<a name="l03044"></a>03044 {   <span class="keywordflow">while</span>(b!=e) <span class="keyword">new</span>(b++) T(v); }
<a name="l03045"></a>03045 
<a name="l03046"></a>03046 <span class="comment">// copy construct one element from a given value</span>
<a name="l03047"></a>03047 <span class="keyword">static</span> <span class="keywordtype">void</span> copyConstruct(T* p, <span class="keyword">const</span> T&amp; v) {<span class="keyword">new</span>(p) T(v);}
<a name="l03048"></a>03048 <span class="comment">// copy construct range [b,e) from sequence of source values</span>
<a name="l03049"></a>03049 <span class="keyword">static</span> <span class="keywordtype">void</span> copyConstruct(T* b, <span class="keyword">const</span> T* e, T* src)
<a name="l03050"></a>03050 {   <span class="keywordflow">while</span>(b!=e) <span class="keyword">new</span>(b++) T(*src++); }
<a name="l03051"></a>03051 <span class="comment">// Templatized copy construct will work if the source elements are</span>
<a name="l03052"></a>03052 <span class="comment">// assignment compatible with the destination elements.</span>
<a name="l03053"></a>03053 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l03054"></a>03054 <span class="keyword">static</span> <span class="keywordtype">void</span> copyConstruct(T* b, <span class="keyword">const</span> T* e, InputIterator src)
<a name="l03055"></a>03055 {   <span class="keywordflow">while</span>(b!=e) <span class="keyword">new</span>(b++) T(*src++); }
<a name="l03056"></a>03056 
<a name="l03057"></a>03057 <span class="comment">// Copy construct range [b,e] from sequence of source values and</span>
<a name="l03058"></a>03058 <span class="comment">// destruct the source after it is copied. It&#39;s better to alternate</span>
<a name="l03059"></a>03059 <span class="comment">// copying and destructing than to do this in two passes since we</span>
<a name="l03060"></a>03060 <span class="comment">// will already have touched the memory.</span>
<a name="l03061"></a>03061 <span class="keyword">static</span> <span class="keywordtype">void</span> copyConstructThenDestructSource(T* b, <span class="keyword">const</span> T* e, T* src)
<a name="l03062"></a>03062 {   <span class="keywordflow">while</span>(b!=e) {<span class="keyword">new</span>(b++) T(*src); src++-&gt;~T();} }
<a name="l03063"></a>03063 
<a name="l03064"></a>03064 <span class="comment">// We have an element at from that we would like to move into the currently-</span>
<a name="l03065"></a>03065 <span class="comment">// unconstructed slot at to. Both from and to are expected to be pointing to</span>
<a name="l03066"></a>03066 <span class="comment">// elements within the currently allocated space. From&#39;s slot will be left</span>
<a name="l03067"></a>03067 <span class="comment">// unconstructed.</span>
<a name="l03068"></a>03068 <span class="keywordtype">void</span> moveOneElement(T* to, T* from) {
<a name="l03069"></a>03069     assert(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>() &lt;= to   &amp;&amp; to   &lt; <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()+<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>());
<a name="l03070"></a>03070     assert(<a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>() &lt;= from &amp;&amp; from &lt; <a class="code" href="classSimTK_1_1Array__.html#aecd7415f4c933c8c572d93b486193c26" title="The const version of the data() method is identical to cdata().">data</a>()+<a class="code" href="classSimTK_1_1Array__.html#ab09f12c0986ba2025ece82fa7fe5df41" title="Return the amount of heap space owned by this array; this is the same as capacity() for owner arrays ...">allocated</a>());
<a name="l03071"></a>03071     copyConstruct(to, *from); 
<a name="l03072"></a>03072     destruct(from);
<a name="l03073"></a>03073 }
<a name="l03074"></a>03074 
<a name="l03075"></a>03075 
<a name="l03076"></a>03076 <span class="comment">// Move elements from p to end() down by n&gt;0 places to fill an unconstructed </span>
<a name="l03077"></a>03077 <span class="comment">// gap beginning at p-n. Any leftover space at the end will be unconstructed.</span>
<a name="l03078"></a>03078 <span class="keywordtype">void</span> moveElementsDown(T* p, <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n) {
<a name="l03079"></a>03079     assert(n &gt; 0);
<a name="l03080"></a>03080     <span class="keywordflow">for</span> (; p != <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(); ++p)
<a name="l03081"></a>03081         moveOneElement(p-n,p);
<a name="l03082"></a>03082 }
<a name="l03083"></a>03083 
<a name="l03084"></a>03084 <span class="comment">// Move elements from p to end() up by n&gt;0 places to make an unconstructed gap</span>
<a name="l03085"></a>03085 <span class="comment">// at [p,p+n). Note that this has to be done backwards so that we don&#39;t</span>
<a name="l03086"></a>03086 <span class="comment">// write on any elements until after they&#39;ve been copied.</span>
<a name="l03087"></a>03087 <span class="keywordtype">void</span> moveElementsUp(T* p, <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n) {
<a name="l03088"></a>03088     assert(n &gt; 0);
<a name="l03089"></a>03089     T* src = <a class="code" href="classSimTK_1_1Array__.html#a06a9152d785cb3d350e624d53d49af08" title="The const version of end() is the same as cend().">end</a>(); <span class="comment">// points one past source element (begin()-1 not allowed)</span>
<a name="l03090"></a>03090     <span class="keywordflow">while</span> (src != p) {
<a name="l03091"></a>03091         --src; <span class="comment">// now points to source</span>
<a name="l03092"></a>03092         moveOneElement(src+n, src);;
<a name="l03093"></a>03093     }
<a name="l03094"></a>03094 }
<a name="l03095"></a>03095 
<a name="l03096"></a>03096 <span class="comment">// destruct one element</span>
<a name="l03097"></a>03097 <span class="keyword">static</span> <span class="keywordtype">void</span> destruct(T* p) {p-&gt;~T();}
<a name="l03098"></a>03098 <span class="comment">// destruct range [b,e)</span>
<a name="l03099"></a>03099 <span class="keyword">static</span> <span class="keywordtype">void</span> destruct(T* b, <span class="keyword">const</span> T* e)
<a name="l03100"></a>03100 {   <span class="keywordflow">while</span>(b!=e) b++-&gt;~T(); }
<a name="l03101"></a>03101 
<a name="l03102"></a>03102 <span class="comment">// Check that growing this array by n elements wouldn&#39;t cause it to exceed</span>
<a name="l03103"></a>03103 <span class="comment">// its allowable maximum size.</span>
<a name="l03104"></a>03104 <span class="keyword">template</span> &lt;<span class="keyword">class</span> S&gt;
<a name="l03105"></a>03105 <span class="keywordtype">bool</span> isGrowthOK(S n)<span class="keyword"> const</span>
<a name="l03106"></a>03106 <span class="keyword"></span>{   <span class="keywordflow">return</span> this-&gt;isSizeOK(ullCapacity() + this-&gt;ull(n)); }
<a name="l03107"></a>03107 
<a name="l03108"></a>03108 <span class="comment">// The following private methods are protected methods in the ArrayView base </span>
<a name="l03109"></a>03109 <span class="comment">// class, so they should not need repeating here. Howevr, we explicitly </span>
<a name="l03110"></a>03110 <span class="comment">// forward to the Base methods to avoid gcc errors. The gcc complaint</span>
<a name="l03111"></a>03111 <span class="comment">// is due to their not depending on any template parameters; the &quot;this-&gt;&quot;</span>
<a name="l03112"></a>03112 <span class="comment">// apparently fixes that problem.</span>
<a name="l03113"></a>03113 
<a name="l03114"></a>03114 <span class="comment">// These provide direct access to the data members.</span>
<a name="l03115"></a>03115 <a class="code" href="classSimTK_1_1Array__.html#ab1b7dc77f42cab3244ec808e5d4d3ee3" title="The integral type we actually use internally to store size_type values.">packed_size_type</a> psize()<span class="keyword">      const </span>{<span class="keywordflow">return</span> this-&gt;CBase::psize();}
<a name="l03116"></a>03116 <a class="code" href="classSimTK_1_1Array__.html#ab1b7dc77f42cab3244ec808e5d4d3ee3" title="The integral type we actually use internally to store size_type values.">packed_size_type</a> pallocated()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;CBase::pallocated();}
<a name="l03117"></a>03117 
<a name="l03118"></a>03118 <span class="keywordtype">void</span> setData(<span class="keyword">const</span> T* p)        {this-&gt;CBase::setData(p);}
<a name="l03119"></a>03119 <span class="keywordtype">void</span> setSize(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n)       {this-&gt;CBase::setSize(n);}
<a name="l03120"></a>03120 <span class="keywordtype">void</span> incrSize()                 {this-&gt;CBase::incrSize();}
<a name="l03121"></a>03121 <span class="keywordtype">void</span> decrSize()                 {this-&gt;CBase::decrSize();}
<a name="l03122"></a>03122 <span class="keywordtype">void</span> setAllocated(<a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">size_type</a> n)  {this-&gt;CBase::setAllocated(n);}
<a name="l03123"></a>03123 <span class="comment">// This just cast sizes to unsigned long long so that we can do comparisons</span>
<a name="l03124"></a>03124 <span class="comment">// without getting warnings.</span>
<a name="l03125"></a>03125 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullSize()<span class="keyword">     const </span>{<span class="keywordflow">return</span> this-&gt;CBase::ullSize();}
<a name="l03126"></a>03126 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullCapacity()<span class="keyword"> const </span>{<span class="keywordflow">return</span> this-&gt;CBase::ullCapacity();}
<a name="l03127"></a>03127 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ullMaxSize()<span class="keyword">  const </span>{<span class="keywordflow">return</span> this-&gt;CBase::ullMaxSize();}
<a name="l03128"></a>03128 <span class="comment">// This is the index type name and is handy for error messages to explain</span>
<a name="l03129"></a>03129 <span class="comment">// why some size was too big.</span>
<a name="l03130"></a>03130 <span class="keyword">const</span> <span class="keywordtype">char</span>* indexName()<span class="keyword"> const   </span>{<span class="keywordflow">return</span> this-&gt;CBase::indexName();}
<a name="l03131"></a>03131 };
<a name="l03132"></a>03132 
<a name="l03133"></a>03133 
<a name="l03134"></a>03134 <span class="comment">// This &quot;private&quot; static method is used to implement ArrayView&#39;s </span>
<a name="l03135"></a>03135 <span class="comment">// fillArrayViewFromStream() and Array&#39;s readArrayFromStream() namespace-scope</span>
<a name="l03136"></a>03136 <span class="comment">// static methods, which are in turn used to implement ArrayView&#39;s and </span>
<a name="l03137"></a>03137 <span class="comment">// Array&#39;s stream extraction operators &quot;&gt;&gt;&quot;. This method has to be in the </span>
<a name="l03138"></a>03138 <span class="comment">// header file so that we don&#39;t need to pass streams through the API, but it </span>
<a name="l03139"></a>03139 <span class="comment">// is not intended for use by users and has no Doxygen presence, unlike </span>
<a name="l03140"></a>03140 <span class="comment">// fillArrayFromStream() and readArrayFromStream() and (more commonly)</span>
<a name="l03141"></a>03141 <span class="comment">// the extraction operators.</span>
<a name="l03142"></a>03142 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">static</span> <span class="keyword">inline</span> 
<a name="l03143"></a>03143 std::istream&amp; <a class="code" href="namespaceSimTK.html#a47ace16fb1192b2579d3b9bf9aaa8062">readArrayFromStreamHelper</a>
<a name="l03144"></a><a class="code" href="namespaceSimTK.html#a47ace16fb1192b2579d3b9bf9aaa8062">03144</a>    (std::istream&amp; in, <span class="keywordtype">bool</span> isFixedSize, <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>&amp; out)
<a name="l03145"></a>03145 {
<a name="l03146"></a>03146     <span class="comment">// If already failed, bad, or eof, set failed bit and return without </span>
<a name="l03147"></a>03147     <span class="comment">// touching the Array.</span>
<a name="l03148"></a>03148     <span class="keywordflow">if</span> (!in.good()) {in.setstate(std::ios::failbit); <span class="keywordflow">return</span> in;}
<a name="l03149"></a>03149 
<a name="l03150"></a>03150     <span class="comment">// If the passed-in Array isn&#39;t an owner, then we have to treat it as</span>
<a name="l03151"></a>03151     <span class="comment">// a fixed size ArrayView regardless of the setting of the isFixedSize</span>
<a name="l03152"></a>03152     <span class="comment">// argument.</span>
<a name="l03153"></a>03153     <span class="keywordflow">if</span> (!out.<a class="code" href="classSimTK_1_1Array__.html#a82f384696e84727ee28902212fc95a1d" title="Does this array own the data to which it refers? If not, it can&#39;t be resized, and the destructor will...">isOwner</a>())
<a name="l03154"></a>03154         isFixedSize = <span class="keyword">true</span>; <span class="comment">// might be overriding the argument here</span>
<a name="l03155"></a>03155 
<a name="l03156"></a>03156     <span class="comment">// numRequired will be ignored unless isFixedSize==true.</span>
<a name="l03157"></a>03157     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913" title="An integral type suitable for all indices and sizes for this array.">Array_&lt;T,X&gt;::size_type</a> 
<a name="l03158"></a>03158         numRequired = isFixedSize ? out.<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>() : 0;
<a name="l03159"></a>03159 
<a name="l03160"></a>03160     <span class="keywordflow">if</span> (!isFixedSize)
<a name="l03161"></a>03161         out.<a class="code" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa" title="Erase all the elements currently in this array without changing the capacity; equivalent to erase(beg...">clear</a>(); <span class="comment">// We&#39;re going to replace the entire contents of the Array.</span>
<a name="l03162"></a>03162 
<a name="l03163"></a>03163     <span class="comment">// Skip initial whitespace. If that results in eof this may be a successful</span>
<a name="l03164"></a>03164     <span class="comment">// read of a 0-length, unbracketed Array. That is OK for either a</span>
<a name="l03165"></a>03165     <span class="comment">// variable-length Array or a fixed-length ArrayView of length zero.</span>
<a name="l03166"></a>03166     std::ws(in); <span class="keywordflow">if</span> (in.fail()) <span class="keywordflow">return</span> in;
<a name="l03167"></a>03167     <span class="keywordflow">if</span> (in.eof()) {
<a name="l03168"></a>03168         <span class="keywordflow">if</span> (isFixedSize &amp;&amp; numRequired != 0)
<a name="l03169"></a>03169             in.setstate(std::ios_base::failbit); <span class="comment">// zero elements not OK</span>
<a name="l03170"></a>03170         <span class="keywordflow">return</span> in;
<a name="l03171"></a>03171     }
<a name="l03172"></a>03172     
<a name="l03173"></a>03173     <span class="comment">// Here the stream is good and the next character is non-white.</span>
<a name="l03174"></a>03174     assert(in.good());
<a name="l03175"></a>03175 
<a name="l03176"></a>03176     <span class="comment">// Use this for raw i/o (peeks and gets).</span>
<a name="l03177"></a>03177     <span class="keyword">typename</span>       std::iostream::int_type ch;
<a name="l03178"></a>03178     <span class="keyword">const</span> <span class="keyword">typename</span> std::iostream::int_type EOFch = 
<a name="l03179"></a>03179         std::iostream::traits_type::eof();
<a name="l03180"></a>03180 
<a name="l03181"></a>03181     <span class="comment">// Now see if the sequence is bare or surrounded by (), [], or {}.</span>
<a name="l03182"></a>03182     <span class="keywordtype">bool</span> lookForCloser = <span class="keyword">true</span>;
<a name="l03183"></a>03183     <span class="keywordtype">char</span> openBracket, closeBracket;
<a name="l03184"></a>03184     ch = in.peek(); <span class="keywordflow">if</span> (in.fail()) <span class="keywordflow">return</span> in;
<a name="l03185"></a>03185     assert(ch != EOFch); <span class="comment">// we already checked above</span>
<a name="l03186"></a>03186 
<a name="l03187"></a>03187     openBracket = (char)ch;
<a name="l03188"></a>03188     <span class="keywordflow">if</span>      (openBracket==<span class="charliteral">&#39;(&#39;</span>) {in.get(); closeBracket = <span class="charliteral">&#39;)&#39;</span>;}
<a name="l03189"></a>03189     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (openBracket==<span class="charliteral">&#39;[&#39;</span>) {in.get(); closeBracket = <span class="charliteral">&#39;]&#39;</span>;}
<a name="l03190"></a>03190     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (openBracket==<span class="charliteral">&#39;{&#39;</span>) {in.get(); closeBracket = <span class="charliteral">&#39;}&#39;</span>;}
<a name="l03191"></a>03191     <span class="keywordflow">else</span> lookForCloser = <span class="keyword">false</span>;
<a name="l03192"></a>03192 
<a name="l03193"></a>03193     <span class="comment">// If lookForCloser is true, then closeBracket contains the terminating</span>
<a name="l03194"></a>03194     <span class="comment">// delimiter, otherwise we&#39;re not going to quit until eof.</span>
<a name="l03195"></a>03195 
<a name="l03196"></a>03196     <span class="comment">// Eat whitespace after the opening bracket to see what&#39;s next.</span>
<a name="l03197"></a>03197     <span class="keywordflow">if</span> (in.good()) std::ws(in);
<a name="l03198"></a>03198 
<a name="l03199"></a>03199     <span class="comment">// If we&#39;re at eof now it must be because the open bracket was the</span>
<a name="l03200"></a>03200     <span class="comment">// last non-white character in the stream, which is an error.</span>
<a name="l03201"></a>03201     <span class="keywordflow">if</span> (!in.good()) {
<a name="l03202"></a>03202         <span class="keywordflow">if</span> (in.eof()) {
<a name="l03203"></a>03203             assert(lookForCloser); <span class="comment">// or we haven&#39;t read anything that could eof</span>
<a name="l03204"></a>03204             in.setstate(std::ios::failbit);
<a name="l03205"></a>03205         }
<a name="l03206"></a>03206         <span class="keywordflow">return</span> in;
<a name="l03207"></a>03207     }
<a name="l03208"></a>03208 
<a name="l03209"></a>03209     <span class="comment">// istream is good and next character is non-white; ready to read first</span>
<a name="l03210"></a>03210     <span class="comment">// value or terminator.</span>
<a name="l03211"></a>03211 
<a name="l03212"></a>03212     <span class="comment">// We need to figure out whether the elements are space- or comma-</span>
<a name="l03213"></a>03213     <span class="comment">// separated and then insist on consistency.</span>
<a name="l03214"></a>03214     <span class="keywordtype">bool</span> commaOK = <span class="keyword">true</span>, commaRequired = <span class="keyword">false</span>;
<a name="l03215"></a>03215     <span class="keywordtype">bool</span> terminatorSeen = <span class="keyword">false</span>;
<a name="l03216"></a>03216     X nextIndex(0);
<a name="l03217"></a>03217     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l03218"></a>03218         <span class="keywordtype">char</span> c;
<a name="l03219"></a>03219 
<a name="l03220"></a>03220         <span class="comment">// Here at the top of this loop, we have already successfully read </span>
<a name="l03221"></a>03221         <span class="comment">// n=nextIndex values of type T. For fixed-size reads, it might be</span>
<a name="l03222"></a>03222         <span class="comment">// the case that n==numRequired already, but we still may need to</span>
<a name="l03223"></a>03223         <span class="comment">// look for a closing bracket before we can declare victory.</span>
<a name="l03224"></a>03224         <span class="comment">// The stream is good() (not at eof) but it might be the case that </span>
<a name="l03225"></a>03225         <span class="comment">// there is nothing but white space left; we don&#39;t know yet because</span>
<a name="l03226"></a>03226         <span class="comment">// if we have satisfied the fixed-size count and are not expecting</span>
<a name="l03227"></a>03227         <span class="comment">// a terminator then we should quit without absorbing the trailing</span>
<a name="l03228"></a>03228         <span class="comment">// white space.</span>
<a name="l03229"></a>03229         assert(in.good());
<a name="l03230"></a>03230 
<a name="l03231"></a>03231         <span class="comment">// Look for closing bracket before trying to read value.</span>
<a name="l03232"></a>03232         <span class="keywordflow">if</span> (lookForCloser) {
<a name="l03233"></a>03233             <span class="comment">// Eat white space to find the closing bracket.</span>
<a name="l03234"></a>03234             std::ws(in); <span class="keywordflow">if</span> (!in.good()) <span class="keywordflow">break</span>; <span class="comment">// eof?</span>
<a name="l03235"></a>03235             ch = in.peek(); assert(ch != EOFch);
<a name="l03236"></a>03236             <span class="keywordflow">if</span> (!in.good()) <span class="keywordflow">break</span>;
<a name="l03237"></a>03237             c = (char)ch;
<a name="l03238"></a>03238             <span class="keywordflow">if</span> (c == closeBracket) {   
<a name="l03239"></a>03239                 in.get(); <span class="comment">// absorb the closing bracket</span>
<a name="l03240"></a>03240                 terminatorSeen = <span class="keyword">true</span>; 
<a name="l03241"></a>03241                 <span class="keywordflow">break</span>; 
<a name="l03242"></a>03242             }
<a name="l03243"></a>03243             <span class="comment">// next char not a closing bracket; fall through</span>
<a name="l03244"></a>03244         }
<a name="l03245"></a>03245 
<a name="l03246"></a>03246         <span class="comment">// We didn&#39;t look or didn&#39;t find a closing bracket. The istream is good </span>
<a name="l03247"></a>03247         <span class="comment">// but we might be looking at white space.</span>
<a name="l03248"></a>03248 
<a name="l03249"></a>03249         <span class="comment">// If we already got all the elements we want, break for final checks.</span>
<a name="l03250"></a>03250         <span class="keywordflow">if</span> (isFixedSize &amp;&amp; (nextIndex == numRequired))
<a name="l03251"></a>03251             <span class="keywordflow">break</span>; <span class="comment">// that&#39;s a full count.</span>
<a name="l03252"></a>03252 
<a name="l03253"></a>03253         <span class="comment">// Look for comma before value, except the first time.</span>
<a name="l03254"></a>03254         <span class="keywordflow">if</span> (commaOK &amp;&amp; nextIndex != 0) {
<a name="l03255"></a>03255             <span class="comment">// Eat white space to find the comma.</span>
<a name="l03256"></a>03256             std::ws(in); <span class="keywordflow">if</span> (!in.good()) <span class="keywordflow">break</span>; <span class="comment">// eof?</span>
<a name="l03257"></a>03257             ch = in.peek(); assert(ch != EOFch);
<a name="l03258"></a>03258             <span class="keywordflow">if</span> (!in.good()) <span class="keywordflow">break</span>;
<a name="l03259"></a>03259             c = (char)ch;
<a name="l03260"></a>03260             <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;,&#39;</span>) {
<a name="l03261"></a>03261                 in.get(); <span class="comment">// absorb comma</span>
<a name="l03262"></a>03262                 commaRequired = <span class="keyword">true</span>; <span class="comment">// all commas from now on</span>
<a name="l03263"></a>03263             } <span class="keywordflow">else</span> { <span class="comment">// next char not a comma</span>
<a name="l03264"></a>03264                 <span class="keywordflow">if</span> (commaRequired) <span class="comment">// bad, e.g.: v1, v2, v3 v4 </span>
<a name="l03265"></a>03265                 {   in.setstate(std::ios::failbit); <span class="keywordflow">break</span>; }
<a name="l03266"></a>03266                 <span class="keywordflow">else</span> commaOK = <span class="keyword">false</span>; <span class="comment">// saw: v1 v2 (no commas now)</span>
<a name="l03267"></a>03267             }
<a name="l03268"></a>03268             <span class="keywordflow">if</span> (!in.good()) <span class="keywordflow">break</span>; <span class="comment">// might be eof</span>
<a name="l03269"></a>03269         }
<a name="l03270"></a>03270 
<a name="l03271"></a>03271         <span class="comment">// No closing bracket yet; don&#39;t have enough elements; skipped comma </span>
<a name="l03272"></a>03272         <span class="comment">// if any; istream is good; might be looking at white space.</span>
<a name="l03273"></a>03273         assert(in.good());
<a name="l03274"></a>03274 
<a name="l03275"></a>03275         <span class="comment">// Now read in an element of type T.</span>
<a name="l03276"></a>03276         <span class="comment">// The extractor T::operator&gt;&gt;() will ignore leading white space.</span>
<a name="l03277"></a>03277         <span class="keywordflow">if</span> (!isFixedSize)
<a name="l03278"></a>03278             out.<a class="code" href="classSimTK_1_1Array__.html#a13b95bc701e5bd09dad7ee38e069b669" title="This method increases the size of the Array by one element at the end and initializes that element by...">push_back</a>(); <span class="comment">// grow by one (default consructed)</span>
<a name="l03279"></a>03279         in &gt;&gt; out[nextIndex]; <span class="keywordflow">if</span> (in.fail()) <span class="keywordflow">break</span>;
<a name="l03280"></a>03280         ++nextIndex;
<a name="l03281"></a>03281 
<a name="l03282"></a>03282         <span class="keywordflow">if</span> (!in.good()) <span class="keywordflow">break</span>; <span class="comment">// might be eof</span>
<a name="l03283"></a>03283     }
<a name="l03284"></a>03284 
<a name="l03285"></a>03285     <span class="comment">// We will get here under a number of circumstances:</span>
<a name="l03286"></a>03286     <span class="comment">//  - the fail bit is set in the istream, or</span>
<a name="l03287"></a>03287     <span class="comment">//  - we reached eof</span>
<a name="l03288"></a>03288     <span class="comment">//  - we saw a closing brace</span>
<a name="l03289"></a>03289     <span class="comment">//  - we got all the elements we wanted (for a fixed-size read)</span>
<a name="l03290"></a>03290     <span class="comment">// Note that it is possible that we consumed everything except some</span>
<a name="l03291"></a>03291     <span class="comment">// trailing white space (meaning we&#39;re not technically at eof), but</span>
<a name="l03292"></a>03292     <span class="comment">// for consistency with built-in operator&gt;&gt;()&#39;s we won&#39;t try to absorb</span>
<a name="l03293"></a>03293     <span class="comment">// that trailing white space.</span>
<a name="l03294"></a>03294 
<a name="l03295"></a>03295     <span class="keywordflow">if</span> (!in.fail()) {
<a name="l03296"></a>03296         <span class="keywordflow">if</span> (lookForCloser &amp;&amp; !terminatorSeen)
<a name="l03297"></a>03297             in.setstate(std::ios::failbit); <span class="comment">// missing terminator</span>
<a name="l03298"></a>03298 
<a name="l03299"></a>03299         <span class="keywordflow">if</span> (isFixedSize &amp;&amp; nextIndex != numRequired)
<a name="l03300"></a>03300             in.setstate(std::ios::failbit); <span class="comment">// wrong number of values</span>
<a name="l03301"></a>03301     }
<a name="l03302"></a>03302 
<a name="l03303"></a>03303     <span class="keywordflow">return</span> in;
<a name="l03304"></a>03304 }
<a name="l03305"></a>03305 
<a name="l03306"></a>03306 
<a name="l03307"></a>03307 
<a name="l03308"></a>03308 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l03309"></a>03309 <span class="comment">//                          RELATED GLOBAL OPERATORS</span>
<a name="l03310"></a>03310 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l03311"></a>03311 <span class="comment">// These are logically part of the Array_&lt;T,X&gt; class but are not actually </span>
<a name="l03312"></a>03312 <span class="comment">// class members; that is, they are in the SimTK namespace.</span>
<a name="l03313"></a>03313 
<a name="l03314"></a>03314 <span class="comment">// Some of the serialization methods could have been member functions but </span>
<a name="l03315"></a>03315 <span class="comment">// then an attempt to explicitly instantiate the whole Array_&lt;T&gt; class for</span>
<a name="l03316"></a>03316 <span class="comment">// some type T would fail if T did not support the requisite I/O operations</span>
<a name="l03317"></a>03317 <span class="comment">// even if those operations were never used. This came up when Chris Bruns was</span>
<a name="l03318"></a>03318 <span class="comment">// trying to wrap Array objects for Python, which requires explicit </span>
<a name="l03319"></a>03319 <span class="comment">// instantiation.</span>
<a name="l03320"></a>03320 
<a name="l03328"></a>03328 
<a name="l03332"></a>03332 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03333"></a><a class="code" href="classSimTK_1_1Array__.html#a015cef5d8e534e632955fcca6ea444f8">03333</a> <a class="code" href="classSimTK_1_1Array__.html#a015cef5d8e534e632955fcca6ea444f8" title="Specialize writeUnformatted() for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating t...">writeUnformatted</a>(std::ostream&amp; o, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>&amp; v) {
<a name="l03334"></a>03334     <span class="keywordflow">for</span> (X i(0); i &lt; v.<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(); ++i) {
<a name="l03335"></a>03335         <span class="keywordflow">if</span> (i != 0) o &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l03336"></a>03336         <a class="code" href="group__writeUnformatted.html#gaae02786573d73eb2fcdb5e552a6fa891" title="The default implementation of writeUnformatted&lt;T&gt; converts the object to a String using the templatiz...">writeUnformatted</a>(o, v[i]);
<a name="l03337"></a>03337     }
<a name="l03338"></a>03338 }
<a name="l03339"></a>03339 
<a name="l03340"></a>03340 
<a name="l03344"></a>03344 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03345"></a><a class="code" href="classSimTK_1_1Array__.html#a6abedbcfc5b21bd9fa859208247aec72">03345</a> <a class="code" href="classSimTK_1_1Array__.html#a6abedbcfc5b21bd9fa859208247aec72" title="Specialize writeFormatted() for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parenthes...">writeFormatted</a>(std::ostream&amp; o, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>&amp; v) {
<a name="l03346"></a>03346     o &lt;&lt; <span class="charliteral">&#39;(&#39;</span>;
<a name="l03347"></a>03347     <span class="keywordflow">for</span> (X i(0); i &lt; v.<a class="code" href="classSimTK_1_1Array__.html#a00d92f7cb1c2c6ad7d8ff7267a67ee0a" title="Return the current number of elements stored in this array.">size</a>(); ++i) {
<a name="l03348"></a>03348         <span class="keywordflow">if</span> (i != 0) o &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;
<a name="l03349"></a>03349         <a class="code" href="group__writeFormatted.html#gade1630adab11d517027b2971162f8a62" title="The default implementation of writeFormatted&lt;T&gt; converts the object to a String using the templatized...">writeFormatted</a>(o, v[i]);
<a name="l03350"></a>03350     }
<a name="l03351"></a>03351     o &lt;&lt; <span class="charliteral">&#39;)&#39;</span>;
<a name="l03352"></a>03352 }
<a name="l03353"></a>03353 
<a name="l03360"></a>03360 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span> 
<a name="l03361"></a>03361 std::ostream&amp;
<a name="l03362"></a><a class="code" href="classSimTK_1_1Array__.html#a8575e59ff1ed3dcb8e52d7dd44ebb426">03362</a> <a class="code" href="namespaceSimTK.html#a306139f1a6a0d5bf28030ca561aa0370">operator&lt;&lt;</a>(std::ostream&amp; o, 
<a name="l03363"></a>03363            <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T,X&gt;</a>&amp; a) 
<a name="l03364"></a>03364 {
<a name="l03365"></a>03365     o &lt;&lt; <span class="charliteral">&#39;(&#39;</span>;
<a name="l03366"></a>03366     <span class="keywordflow">if</span> (!a.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c" title="Return true if there are no elements currently stored in this array.">empty</a>()) {
<a name="l03367"></a>03367         o &lt;&lt; a.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554" title="Return a const reference to the first element in this array, which must not be empty (we&#39;ll check in ...">front</a>();
<a name="l03368"></a>03368         <span class="keywordflow">for</span> (<span class="keyword">const</span> T* p = a.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin().">begin</a>()+1; p != a.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend().">end</a>(); ++p)
<a name="l03369"></a>03369             o &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; *p;
<a name="l03370"></a>03370     }
<a name="l03371"></a>03371     <span class="keywordflow">return</span> o &lt;&lt; <span class="charliteral">&#39;)&#39;</span>;
<a name="l03372"></a>03372 } 
<a name="l03373"></a>03373 
<a name="l03374"></a>03374 
<a name="l03378"></a>03378 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03379"></a><a class="code" href="classSimTK_1_1Array__.html#a6b300ce2032c6315983114f0b7e84e92">03379</a> <a class="code" href="classSimTK_1_1Array__.html#a6b300ce2032c6315983114f0b7e84e92" title="Specialization of readUnformatted() for variable-length Array_&lt;T,X&gt;; continues reading whitespace-sep...">readUnformatted</a>(std::istream&amp; in, <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>&amp; v) {
<a name="l03380"></a>03380     v.<a class="code" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa" title="Erase all the elements currently in this array without changing the capacity; equivalent to erase(beg...">clear</a>();
<a name="l03381"></a>03381     T element;
<a name="l03382"></a>03382     std::ws(in); <span class="comment">// Make sure we&#39;re at eof if stream is all whitespace.</span>
<a name="l03383"></a>03383     <span class="keywordflow">while</span> (!in.eof() &amp;&amp; <a class="code" href="namespaceSimTK.html#a2b08d1545f0d1cd18dcfbd1f9e37468c" title="Read fixed-size VectorView from input stream.">readUnformatted</a>(in, element))
<a name="l03384"></a>03384         v.<a class="code" href="classSimTK_1_1Array__.html#a13b95bc701e5bd09dad7ee38e069b669" title="This method increases the size of the Array by one element at the end and initializes that element by...">push_back</a>(element);
<a name="l03385"></a>03385     <span class="keywordflow">return</span> !in.fail(); <span class="comment">// eof is expected and ok</span>
<a name="l03386"></a>03386 }
<a name="l03387"></a>03387 
<a name="l03392"></a>03392 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03393"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3">03393</a> <a class="code" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3" title="Specialization of readUnformatted() for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated toke...">readUnformatted</a>(std::istream&amp; in, <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T,X&gt;</a>&amp; v) {
<a name="l03394"></a>03394     <span class="keywordflow">for</span> (X i(0); i &lt; v.<a class="code" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926" title="Return the current number of elements stored in this array.">size</a>(); ++i)
<a name="l03395"></a>03395         <span class="keywordflow">if</span> (!<a class="code" href="namespaceSimTK.html#a2b08d1545f0d1cd18dcfbd1f9e37468c" title="Read fixed-size VectorView from input stream.">readUnformatted</a>(in, v[i])) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03396"></a>03396     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03397"></a>03397 }
<a name="l03398"></a>03398 
<a name="l03399"></a>03399 
<a name="l03405"></a>03405 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03406"></a><a class="code" href="classSimTK_1_1Array__.html#a65a8a24c48ad3dff0c852095f0347941">03406</a> <a class="code" href="classSimTK_1_1Array__.html#a65a8a24c48ad3dff0c852095f0347941" title="Specialization of readFormatted() for variable-length Array_&lt;T,X&gt;; uses readArrayFromStream() to cons...">readFormatted</a>(std::istream&amp; in, <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>&amp; v) {
<a name="l03407"></a>03407     <span class="keywordflow">return</span> !readArrayFromStream(in,v).fail();
<a name="l03408"></a>03408 }
<a name="l03409"></a>03409 
<a name="l03415"></a>03415 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03416"></a><a class="code" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91">03416</a> <a class="code" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91" title="Specialization of readFormatted() for fixed-length ArrayView_&lt;T,X&gt;; uses fillArrayViewFromStream() to...">readFormatted</a>(std::istream&amp; in, <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T,X&gt;</a>&amp; v) {
<a name="l03417"></a>03417     <span class="keywordflow">return</span> !fillArrayViewFromStream(in,v).fail();
<a name="l03418"></a>03418 }
<a name="l03419"></a>03419 
<a name="l03449"></a>03449 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">static</span> <span class="keyword">inline</span> 
<a name="l03450"></a><a class="code" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15">03450</a> std::istream&amp; readArrayFromStream(std::istream&amp; in, <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>&amp; out)
<a name="l03451"></a>03451 {   <span class="keywordflow">return</span> readArrayFromStreamHelper&lt;T,X&gt;(in, <span class="keyword">false</span> <span class="comment">/*variable sizez*/</span>, out); }
<a name="l03452"></a>03452 
<a name="l03453"></a>03453 
<a name="l03454"></a>03454 
<a name="l03479"></a>03479 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">static</span> <span class="keyword">inline</span> 
<a name="l03480"></a><a class="code" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce">03480</a> std::istream&amp; fillArrayFromStream(std::istream&amp; in, <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>&amp; out)
<a name="l03481"></a>03481 {   <span class="keywordflow">return</span> readArrayFromStreamHelper&lt;T,X&gt;(in, <span class="keyword">true</span> <span class="comment">/*fixed size*/</span>, out); }
<a name="l03482"></a>03482 
<a name="l03487"></a>03487 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">static</span> <span class="keyword">inline</span> 
<a name="l03488"></a><a class="code" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03">03488</a> std::istream&amp; fillArrayViewFromStream(std::istream&amp; in, <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T,X&gt;</a>&amp; out)
<a name="l03489"></a>03489 {   <span class="keywordflow">return</span> readArrayFromStreamHelper&lt;T,X&gt;(in, <span class="keyword">true</span> <span class="comment">/*fixed size*/</span>, out); }
<a name="l03490"></a>03490 
<a name="l03491"></a>03491 
<a name="l03492"></a>03492 
<a name="l03493"></a>03493 
<a name="l03503"></a>03503 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span>
<a name="l03504"></a><a class="code" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82">03504</a> std::istream&amp; <a class="code" href="namespaceSimTK.html#a32bc3311eb9591b84552fb442a6567c5">operator&gt;&gt;</a>(std::istream&amp; in, <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_&lt;T,X&gt;</a>&amp; out) 
<a name="l03505"></a>03505 {   <span class="keywordflow">return</span> readArrayFromStream&lt;T,X&gt;(in, out); }
<a name="l03506"></a>03506 
<a name="l03514"></a>03514 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span>
<a name="l03515"></a><a class="code" href="classSimTK_1_1ArrayView__.html#acc7c28435897527058bfecae5e2f407a">03515</a> std::istream&amp; <a class="code" href="namespaceSimTK.html#a32bc3311eb9591b84552fb442a6567c5">operator&gt;&gt;</a>(std::istream&amp; in, <a class="code" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_&lt;T,X&gt;</a>&amp; out) 
<a name="l03516"></a>03516 {   <span class="keywordflow">return</span> fillArrayViewFromStream&lt;T,X&gt;(in, out); }
<a name="l03517"></a>03517 
<a name="l03527"></a>03527 
<a name="l03530"></a>03530 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03531"></a><a class="code" href="classSimTK_1_1Array__.html#a1e25d47eeb9e34faa78ee38812b194d8">03531</a> <a class="code" href="classSimTK_1_1Array__.html#a1e25d47eeb9e34faa78ee38812b194d8" title="Two Array_ objects are equal if and only if they are the same size() and each element compares equal ...">operator==</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,X1&gt;</a>&amp; a1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2) {
<a name="l03532"></a>03532     <span class="comment">// Avoid warnings in size comparison by using common type.</span>
<a name="l03533"></a>03533     <span class="keyword">const</span> ptrdiff_t sz1 = a1.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend().">end</a>()-a1.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l03534"></a>03534     <span class="keyword">const</span> ptrdiff_t sz2 = a2.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend().">end</a>()-a2.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l03535"></a>03535     <span class="keywordflow">if</span> (sz1 != sz2) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03536"></a>03536     <span class="keyword">const</span> T1* p1 = a1.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l03537"></a>03537     <span class="keyword">const</span> T2* p2 = a2.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l03538"></a>03538     <span class="keywordflow">while</span> (p1 != a1.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend().">end</a>())
<a name="l03539"></a>03539         <span class="keywordflow">if</span> (!(*p1++ == *p2++)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03540"></a>03540     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03541"></a>03541 }
<a name="l03544"></a>03544 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03545"></a><a class="code" href="classSimTK_1_1Array__.html#aa79b082dbed61adf809400e05027c595">03545</a> <a class="code" href="namespaceSimTK.html#aac639daeeac2aca1f6b4e6d8da68488d">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,X1&gt;</a>&amp; a1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03546"></a>03546 {   <span class="keywordflow">return</span> !(a1 == a2); }
<a name="l03547"></a>03547 
<a name="l03552"></a>03552 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03553"></a><a class="code" href="classSimTK_1_1Array__.html#a0e1218fae627e26b17ed948a62e87cc8">03553</a> operator&lt;(const ArrayViewConst_&lt;T1,X1&gt;&amp; a1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2) {
<a name="l03554"></a>03554     <span class="keyword">const</span> T1* p1 = a1.<a class="code" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin().">begin</a>();
<a name="l03555"></a>03555     <span class="keyword">const</span> T2* p2 = a2.begin();
<a name="l03556"></a>03556     <span class="keywordflow">while</span> (p1 != a1.end() &amp;&amp; p2 != a2.end()) {
<a name="l03557"></a>03557         <span class="keywordflow">if</span> (!(*p1 == *p2))
<a name="l03558"></a>03558             <span class="keywordflow">return</span> *p1 &lt; *p2; // otherwise p1 &gt; p2
<a name="l03559"></a>03559         ++p1; ++p2;
<a name="l03560"></a>03560     }
<a name="l03561"></a>03561     <span class="comment">// All elements were equal until one or both arrays ran out of elements.</span>
<a name="l03562"></a>03562     <span class="comment">// a1 is less than a2 only if a1 ran out and a2 didn&#39;t.</span>
<a name="l03563"></a>03563     <span class="keywordflow">return</span> p1 == a1.end() &amp;&amp; p2 != a2.end();
<a name="l03564"></a>03564 }
<a name="l03567"></a>03567 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03568"></a><a class="code" href="classSimTK_1_1Array__.html#ad80423b9a73fd93e07d8465c97e999af">03568</a> <a class="code" href="namespaceSimTK.html#aaaa7f3ecb83f7d1b95d91ee8e34d8f9f" title="bool = v1[i] &gt;= v2[i], for all elements i This is not the same as !(v1&lt;v2).">operator&gt;=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,X1&gt;</a>&amp; a1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03569"></a>03569 {   <span class="keywordflow">return</span> !(a1 &lt; a2); }
<a name="l03573"></a>03573 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03574"></a><a class="code" href="classSimTK_1_1Array__.html#ac93cc22c503f9f75f1be2cbbb2c97714">03574</a> <a class="code" href="namespaceSimTK.html#a5ccd5a2794e529c57597ff59419e3b8d" title="bool = v1[i] &gt; v2[i], for all elements i">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,X1&gt;</a>&amp; a1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03575"></a>03575 {   <span class="keywordflow">return</span> a2 &lt; a1; }
<a name="l03578"></a>03578 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03579"></a><a class="code" href="classSimTK_1_1Array__.html#a8822b4815845e58a47af6b5720791698">03579</a> operator&lt;=(const ArrayViewConst_&lt;T1,X1&gt;&amp; a1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03580"></a>03580 {   <span class="keywordflow">return</span> !(a1 &gt; a2); }
<a name="l03581"></a>03581 
<a name="l03585"></a>03585 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> A2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03586"></a><a class="code" href="classSimTK_1_1Array__.html#a39975ed123e3738da698ea6d0ddc7a4a">03586</a> <a class="code" href="namespaceSimTK.html#ac56336ea74b71f07f371d943bd5cdba0">operator==</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,X1&gt;</a>&amp; a1, <span class="keyword">const</span> std::vector&lt;T2,A2&gt;&amp; v2)
<a name="l03587"></a>03587 {   <span class="keywordflow">return</span> a1 == <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,size_t&gt;</a>(v2); }
<a name="l03588"></a>03588 
<a name="l03592"></a>03592 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> A1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03593"></a><a class="code" href="classSimTK_1_1Array__.html#a5bef2d3446751e985a922ecb0681653c">03593</a> <a class="code" href="namespaceSimTK.html#ac56336ea74b71f07f371d943bd5cdba0">operator==</a>(<span class="keyword">const</span> std::vector&lt;T1,A1&gt;&amp; v1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03594"></a>03594 {   <span class="keywordflow">return</span> a2 == v1; }
<a name="l03595"></a>03595 
<a name="l03598"></a>03598 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> A2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03599"></a><a class="code" href="classSimTK_1_1Array__.html#a688f8af308de34d0431205f7d854aee3">03599</a> <a class="code" href="namespaceSimTK.html#aac639daeeac2aca1f6b4e6d8da68488d">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,X1&gt;</a>&amp; a1, <span class="keyword">const</span> std::vector&lt;T2,A2&gt;&amp; v2)
<a name="l03600"></a>03600 {   <span class="keywordflow">return</span> !(a1 == v2); }
<a name="l03603"></a>03603 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> A1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03604"></a><a class="code" href="classSimTK_1_1Array__.html#a7d04f55c1a275128219e677a974254c9">03604</a> <a class="code" href="namespaceSimTK.html#aac639daeeac2aca1f6b4e6d8da68488d">operator!=</a>(<span class="keyword">const</span> std::vector&lt;T1,A1&gt;&amp; v1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03605"></a>03605 {   <span class="keywordflow">return</span> !(a2 == v1); }
<a name="l03606"></a>03606 
<a name="l03612"></a>03612 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> A2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03613"></a><a class="code" href="classSimTK_1_1Array__.html#addbec0e1348a20404c060b9c5523544f">03613</a> operator&lt;(const ArrayViewConst_&lt;T1,X1&gt;&amp; a1, <span class="keyword">const</span> std::vector&lt;T2,A2&gt;&amp; v2)
<a name="l03614"></a>03614 {   <span class="keywordflow">return</span> a1 &lt; ArrayViewConst_&lt;T2,size_t&gt;(v2); }
<a name="l03615"></a>03615 
<a name="l03621"></a>03621 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> A1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03622"></a><a class="code" href="classSimTK_1_1Array__.html#aa929813dea46bf41f7ffee7053566f86">03622</a> operator&lt;(const std::vector&lt;T1,A1&gt;&amp; v1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03623"></a>03623 {   <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,size_t&gt;</a>(v1) &lt; a2; }
<a name="l03624"></a>03624 
<a name="l03627"></a>03627 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> A2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03628"></a><a class="code" href="classSimTK_1_1Array__.html#a81e151401cab82f28a4d2f6c43bdaeb0">03628</a> <a class="code" href="namespaceSimTK.html#aaaa7f3ecb83f7d1b95d91ee8e34d8f9f" title="bool = v1[i] &gt;= v2[i], for all elements i This is not the same as !(v1&lt;v2).">operator&gt;=</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,X1&gt;</a>&amp; a1, <span class="keyword">const</span> std::vector&lt;T2,A2&gt;&amp; v2)
<a name="l03629"></a>03629 {   <span class="keywordflow">return</span> !(a1 &lt; v2); }
<a name="l03632"></a>03632 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> A1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03633"></a><a class="code" href="classSimTK_1_1Array__.html#a1c9fc6fb86e0e02b422ea858ba216f94">03633</a> <a class="code" href="namespaceSimTK.html#aaaa7f3ecb83f7d1b95d91ee8e34d8f9f" title="bool = v1[i] &gt;= v2[i], for all elements i This is not the same as !(v1&lt;v2).">operator&gt;=</a>(<span class="keyword">const</span> std::vector&lt;T1,A1&gt;&amp; v1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03634"></a>03634 {   <span class="keywordflow">return</span> !(v1 &lt; a2); }
<a name="l03635"></a>03635 
<a name="l03639"></a>03639 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> A2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03640"></a><a class="code" href="classSimTK_1_1Array__.html#ad057e98ddbd0b80ab053519caa9dd2ea">03640</a> <a class="code" href="namespaceSimTK.html#a5ccd5a2794e529c57597ff59419e3b8d" title="bool = v1[i] &gt; v2[i], for all elements i">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T1,X1&gt;</a>&amp; a1, <span class="keyword">const</span> std::vector&lt;T2,A2&gt;&amp; v2)
<a name="l03641"></a>03641 {   <span class="keywordflow">return</span> v2 &lt; a1; }
<a name="l03645"></a>03645 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> A1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03646"></a><a class="code" href="classSimTK_1_1Array__.html#ad7d14e73a05783839ed5c679278764d4">03646</a> <a class="code" href="namespaceSimTK.html#a5ccd5a2794e529c57597ff59419e3b8d" title="bool = v1[i] &gt; v2[i], for all elements i">operator&gt;</a>(<span class="keyword">const</span> std::vector&lt;T1,A1&gt;&amp; v1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03647"></a>03647 {   <span class="keywordflow">return</span> a2 &lt; v1; }
<a name="l03648"></a>03648 
<a name="l03651"></a>03651 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> X1, <span class="keyword">class</span> T2, <span class="keyword">class</span> A2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03652"></a><a class="code" href="classSimTK_1_1Array__.html#ad6219dc0d49e5f4d40d4a5d7954c5adb">03652</a> operator&lt;=(const ArrayViewConst_&lt;T1,X1&gt;&amp; a1, <span class="keyword">const</span> std::vector&lt;T2,A2&gt;&amp; v2)
<a name="l03653"></a>03653 {   <span class="keywordflow">return</span> !(a1 &gt; v2); }
<a name="l03656"></a>03656 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> A1, <span class="keyword">class</span> T2, <span class="keyword">class</span> X2&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> 
<a name="l03657"></a><a class="code" href="classSimTK_1_1Array__.html#a463986b88adfd8319e9a2ddcb7b21d0e">03657</a> operator&lt;=(const std::vector&lt;T1,A1&gt;&amp; v1, <span class="keyword">const</span> <a class="code" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_&lt;T2,X2&gt;</a>&amp; a2)
<a name="l03658"></a>03658 {   <span class="keywordflow">return</span> !(v1 &gt; a2); }
<a name="l03659"></a>03659 
<a name="l03662"></a>03662 } <span class="comment">// namespace SimTK</span>
<a name="l03663"></a>03663 
<a name="l03664"></a>03664 <span class="keyword">namespace </span>std {
<a name="l03668"></a>03668 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> X&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03669"></a><a class="code" href="classSimTK_1_1Array__.html#a8a1771c28a26738d4e217ec67586f9c8">03669</a> <a class="code" href="classSimTK_1_1Array__.html#a8a1771c28a26738d4e217ec67586f9c8" title="This is a specialization of the STL std::swap() algorithm which uses the constant time built-in swap(...">swap</a>(<a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_&lt;T,X&gt;</a>&amp; a1, <a class="code" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">SimTK::Array_&lt;T,X&gt;</a>&amp; a2) {
<a name="l03670"></a>03670     a1.<a class="code" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92" title="This is a specialized algorithm providing constant time exchange of data with another array that has ...">swap</a>(a2);
<a name="l03671"></a>03671 }
<a name="l03672"></a>03672 
<a name="l03673"></a>03673 } <span class="comment">// namespace std</span>
<a name="l03674"></a>03674   
<a name="l03675"></a>03675 <span class="preprocessor">#endif // SimTK_SimTKCOMMON_ARRAY_H_</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="Array_8h.html">Array.h</a>      </li>

    <li class="footer">Generated on Wed Oct 9 2013 08:38:29 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
